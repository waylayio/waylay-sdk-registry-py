# coding: utf-8
"""Waylay Function Registry query parameters.

This code was generated from the OpenAPI documentation of 'Waylay Function Registry'

Generated by OpenAPI Generator (https://openapi-generator.tech)

Do not edit the class manually.
"""

from __future__ import annotations  # for Python 3.7â€“3.9

from typing import Any, List

from pydantic import (
    ConfigDict,
    Field,
    StrictBool,
    StrictStr,
)
from typing_extensions import (
    Annotated,  # >=3.11
)

from waylay.sdk.api._models import BaseModel as WaylayBaseModel

from ..models.archive_format_filter import ArchiveFormatFilter
from ..models.function_type import FunctionType
from ..models.job_state_result import JobStateResult
from ..models.job_type_schema import JobTypeSchema
from ..models.plug_type import PlugType
from ..models.rebuild_policy import RebuildPolicy
from ..models.status_filter import StatusFilter


def _create_query_alias_for(field_name: str) -> str:
    if field_name == "deploy":
        return "deploy"
    if field_name == "author":
        return "author"
    if field_name == "comment":
        return "comment"
    if field_name == "scale_to_zero":
        return "scaleToZero"
    if field_name == "deprecate_previous":
        return "deprecatePrevious"
    if field_name == "dry_run":
        return "dryRun"
    if field_name == "var_async":
        return "async"
    if field_name == "version":
        return "version"
    if field_name == "name":
        return "name"
    if field_name == "draft":
        return "draft"
    if field_name == "runtime":
        return "runtime"
    if field_name == "copy_from":
        return "copy"
    return field_name


class CreateQuery(WaylayBaseModel):
    """Model for `create` query parameters."""

    deploy: Annotated[
        StrictBool | None,
        Field(
            description="Indicates that a function should be _deployed_ when its assets are valid.  * If `true` (default), jobs to build and deploy the function will be initiated after it is checked that the assets are valid. Invalid assets lead to a validation error, and the function and its assets are not created or updated. * If `false`, the uploaded assets are stored and the function is created/updated in `registered` state. Asset validation errors are only returned as warning, and stored as `failureReason` on the function entity. Use an _asset update_ or _rebuild_ to initiate a build and deploy at a later stage."
        ),
    ] = None
    author: Annotated[
        StrictStr | None,
        Field(
            description="Optionally changes the author metadata when updating a function."
        ),
    ] = None
    comment: Annotated[
        StrictStr | None,
        Field(
            description="An optional user-specified comment corresponding to the operation."
        ),
    ] = None
    scale_to_zero: Annotated[
        StrictBool | None,
        Field(
            description="If set to <code>true</code>, after successful deployment, the deployed function will be scaled to zero. This saves computing resources when the function is not to be used immediately."
        ),
    ] = None
    deprecate_previous: Annotated[
        Any | None,
        Field(
            description="Set the cleanup policy used to automatically deprecate/delete previous versions."
        ),
    ] = None
    dry_run: Annotated[
        StrictBool | None,
        Field(
            description="If set to <code>true</code>, validates the deployment conditions, but does not change anything."
        ),
    ] = None
    var_async: Annotated[
        StrictBool | None,
        Field(
            description="Unless this is set to <code>false</code>, the server will start the required job actions asynchronously and return a <code>202</code> <em>Accepted</em> response. If <code>false</code> the request will block until the job actions are completed, or a timeout occurs."
        ),
    ] = None
    version: Annotated[
        Any | None,
        Field(
            description="If set, the function version will be an increment of the latest existing version that satisfies the `version` range. Note that this increment always takes precedence over an explicit `version` in the function manifest."
        ),
    ] = None
    name: Annotated[
        StrictStr | None,
        Field(
            description="If set, the value will be used as the function name instead of the one specified in the manifest."
        ),
    ] = None
    draft: Annotated[
        StrictBool | None,
        Field(
            description="If set, the created function will be a draft function and its assets are still mutable. A build and deploy is initiated only in the case when all necessary assets are present and valid."
        ),
    ] = None
    runtime: Annotated[
        Annotated[str, Field(strict=True)] | None,
        Field(
            description="If set, the created function will use the indicated runtime (latest version within specified range).  This takes precedence over the runtime specified in a function manifest (copied or from request body)."
        ),
    ] = None
    copy_from: Annotated[
        Any | None,
        Field(
            description="Indicates the _source_ of initial assets for a _new function_.  When using this query parameter, the request body does not need to contain assets, but any assets in the request body will overwrite the copied assets.  #### Selection of _assets_ source  * If set as `<sourceName>[@<sourceVersionRange>]`, the _new function_ will be created with copied assets of the selected _source function_. * If set as `!example`, a `runtime` query parameter is required, and the _new function_ will be initialized with assets of the _runtime example_.  #### Selection of the _source function_  When `<sourceVersionRange>` is a range (or is not given), the latest _published_ version (in that range) is used.  If no _published_ version exists, the latest _draft_ is selected.  If no versions in the range exist, a `404` _Not Found_ error is returned.  #### The `name` of the _new function_  If a `name` is NOT specified (either as query parameter, or in an optional manifest asset in the request body), the `name` of the _new function_ will be that of the _source function_.  #### The `version` of the _new function_  When the _target_ and _source_ name are equal, the `version` query parameters is defaulted to `<sourceVersionRange>` (`~<sourceVersionRange>` when it's an exact version)  The version of the _new function_ will be: * If a `version` is NOT specified (either as query parameter, in an optional manifest asset, or as `<sourceVersionRange>` _default_)    * a **patch increment** (`<major>.<minor>.<patch>+1`) of the latest **existing version** with the target `name`    * **`1.0.0`** otherwise  * If a `version` is specified:    * the **lowest version** in that range **if no existing version** is in that range.    * an **increment** of the latest existing version, **at the highest level** (_major_,_minor_,_patch_) allowed by that range.    * otherwise, if all allowed versions already exist, a **`409` _Duplicate_ error** is raised.  #### Deployment overrides  The new function will use the deployment overrides of the copied function, unless a _manifest_ was specified in the request body."
        ),
    ] = None

    model_config = ConfigDict(
        protected_namespaces=(),
        extra="allow",
        alias_generator=_create_query_alias_for,
        populate_by_name=True,
    )


def _delete_asset_query_alias_for(field_name: str) -> str:
    if field_name == "scale_to_zero":
        return "scaleToZero"
    if field_name == "deploy":
        return "deploy"
    if field_name == "chown":
        return "chown"
    if field_name == "comment":
        return "comment"
    if field_name == "author":
        return "author"
    if field_name == "var_async":
        return "async"
    return field_name


class DeleteAssetQuery(WaylayBaseModel):
    """Model for `delete_asset` query parameters."""

    scale_to_zero: Annotated[
        StrictBool | None,
        Field(
            description="If set to <code>true</code>, after successful deployment, the deployed function will be scaled to zero. This saves computing resources when the function is not to be used immediately."
        ),
    ] = None
    deploy: Annotated[
        StrictBool | None,
        Field(
            description="Indicates that a function should be _deployed_ when its assets are valid.  * If `true` (default), jobs to build and deploy the function will be initiated after it is checked that the assets are valid. Invalid assets lead to a validation error, and the function and its assets are not created or updated. * If `false`, the uploaded assets are stored and the function is created/updated in `registered` state. Asset validation errors are only returned as warning, and stored as `failureReason` on the function entity. Use an _asset update_ or _rebuild_ to initiate a build and deploy at a later stage."
        ),
    ] = None
    chown: Annotated[
        StrictBool | None,
        Field(
            description="If set, ownership of a draft function is transferred to the current user."
        ),
    ] = None
    comment: Annotated[
        StrictStr | None,
        Field(
            description="An optional user-specified comment corresponding to the operation."
        ),
    ] = None
    author: Annotated[
        StrictStr | None,
        Field(
            description="Optionally changes the author metadata when updating a function."
        ),
    ] = None
    var_async: Annotated[
        StrictBool | None,
        Field(
            description="Unless this is set to <code>false</code>, the server will start the required job actions asynchronously and return a <code>202</code> <em>Accepted</em> response. If <code>false</code> the request will block until the job actions are completed, or a timeout occurs."
        ),
    ] = None

    model_config = ConfigDict(
        protected_namespaces=(),
        extra="allow",
        alias_generator=_delete_asset_query_alias_for,
        populate_by_name=True,
    )


def _get_archive_query_alias_for(field_name: str) -> str:
    if field_name == "ls":
        return "ls"
    return field_name


class GetArchiveQuery(WaylayBaseModel):
    """Model for `get_archive` query parameters."""

    ls: Annotated[
        StrictBool | None,
        Field(
            description="If set to `true`, the result will be a listing of the files in the asset, annotated with metadata and validation report from the asset conditions of the functions runtime."
        ),
    ] = None

    model_config = ConfigDict(
        protected_namespaces=(),
        extra="allow",
        alias_generator=_get_archive_query_alias_for,
        populate_by_name=True,
    )


def _get_asset_query_alias_for(field_name: str) -> str:
    if field_name == "ls":
        return "ls"
    return field_name


class GetAssetQuery(WaylayBaseModel):
    """Model for `get_asset` query parameters."""

    ls: Annotated[
        StrictBool | None,
        Field(
            description="If set to `true`, the result will be a listing of the files in the asset, annotated with metadata and validation report from the asset conditions of the functions runtime."
        ),
    ] = None

    model_config = ConfigDict(
        protected_namespaces=(),
        extra="allow",
        alias_generator=_get_asset_query_alias_for,
        populate_by_name=True,
    )


def _get_latest_query_alias_for(field_name: str) -> str:
    if field_name == "type":
        return "type"
    if field_name == "show_tags":
        return "showTags"
    if field_name == "include_draft":
        return "includeDraft"
    if field_name == "include_deprecated":
        return "includeDeprecated"
    return field_name


class GetLatestQuery(WaylayBaseModel):
    """Model for `get_latest` query parameters."""

    type: Annotated[
        PlugType | None, Field(description="If set, filters on the type of plug.")
    ] = None
    show_tags: Annotated[
        Any | None,
        Field(
            description="Instructs how tag (objects) should be rendered in responses. The tags are show at the `tags` property of the manifest (legacy: the `metadata.tags` property) - `inline`: Show full tag objects in the manifest. - `embed`: Show tag references in the manifest.          Referenced full tag objects are included in a separate `_embedded` HAL section. - `none`: Show tag references in the manifest. Do not render tag objects.  The default behaviour depends on deployment settings."
        ),
    ] = None
    include_draft: Annotated[
        StrictBool | None,
        Field(
            description="Configures the inclusion of _draft_ versions when selecting latest versions per name. By default, draft versions are only considered when no other versions are available. If set to `true`, draft versions are **included**. If set to `false`, draft versions are **excluded**."
        ),
    ] = None
    include_deprecated: Annotated[
        StrictBool | None,
        Field(
            description="Configures the inclusion of _deprecated_ versions when selecting latest versions per name. By default, deprecated versions are only considered when no other versions are available. If set to `true`, deprecated versions are **included**. If set to `false`, deprecated versions are **excluded**."
        ),
    ] = None

    model_config = ConfigDict(
        protected_namespaces=(),
        extra="allow",
        alias_generator=_get_latest_query_alias_for,
        populate_by_name=True,
    )


def _get_query_alias_for(field_name: str) -> str:
    if field_name == "show_tags":
        return "showTags"
    return field_name


class GetQuery(WaylayBaseModel):
    """Model for `get` query parameters."""

    show_tags: Annotated[
        Any | None,
        Field(
            description="Instructs how tag (objects) should be rendered in responses. The tags are show at the `tags` property of the manifest (legacy: the `metadata.tags` property) - `inline`: Show full tag objects in the manifest. - `embed`: Show tag references in the manifest.          Referenced full tag objects are included in a separate `_embedded` HAL section. - `none`: Show tag references in the manifest. Do not render tag objects.  The default behaviour depends on deployment settings."
        ),
    ] = None

    model_config = ConfigDict(
        protected_namespaces=(),
        extra="allow",
        alias_generator=_get_query_alias_for,
        populate_by_name=True,
    )


def _jobs_query_alias_for(field_name: str) -> str:
    if field_name == "limit":
        return "limit"
    if field_name == "type":
        return "type"
    if field_name == "state":
        return "state"
    if field_name == "function_type":
        return "functionType"
    if field_name == "created_before":
        return "createdBefore"
    if field_name == "created_after":
        return "createdAfter"
    return field_name


class JobsQuery(WaylayBaseModel):
    """Model for `jobs` query parameters."""

    limit: Annotated[
        Annotated[float, Field(strict=True, ge=0)]
        | Annotated[int, Field(strict=True, ge=0)]
        | None,
        Field(
            description="The maximum number of items to be return from this query. Has a deployment-defined default and maximum value."
        ),
    ] = None
    type: Annotated[
        List[JobTypeSchema] | None, Field(description="Filter on job type")
    ] = None
    state: Annotated[
        List[JobStateResult] | None, Field(description="Filter on job state")
    ] = None
    function_type: Annotated[
        List[FunctionType] | None, Field(description="Filter on function type")
    ] = None
    created_before: Annotated[
        Any | None,
        Field(
            description="Filter on jobs that created before the given timestamp or age"
        ),
    ] = None
    created_after: Annotated[
        Any | None,
        Field(
            description="Filter on jobs that created after the given timestamp or age"
        ),
    ] = None

    model_config = ConfigDict(
        protected_namespaces=(),
        extra="allow",
        alias_generator=_jobs_query_alias_for,
        populate_by_name=True,
    )


def _list_query_alias_for(field_name: str) -> str:
    if field_name == "type":
        return "type"
    if field_name == "limit":
        return "limit"
    if field_name == "page":
        return "page"
    if field_name == "include_draft":
        return "includeDraft"
    if field_name == "include_deprecated":
        return "includeDeprecated"
    if field_name == "deprecated":
        return "deprecated"
    if field_name == "draft":
        return "draft"
    if field_name == "name_version":
        return "nameVersion"
    if field_name == "show_tags":
        return "showTags"
    if field_name == "tags":
        return "tags"
    if field_name == "wql":
        return "wql"
    if field_name == "version":
        return "version"
    if field_name == "status":
        return "status"
    if field_name == "runtime_version":
        return "runtimeVersion"
    if field_name == "created_by":
        return "createdBy"
    if field_name == "updated_by":
        return "updatedBy"
    if field_name == "created_before":
        return "createdBefore"
    if field_name == "created_after":
        return "createdAfter"
    if field_name == "updated_before":
        return "updatedBefore"
    if field_name == "updated_after":
        return "updatedAfter"
    if field_name == "name":
        return "name"
    if field_name == "archive_format":
        return "archiveFormat"
    if field_name == "runtime":
        return "runtime"
    if field_name == "latest":
        return "latest"
    if field_name == "show_related":
        return "showRelated"
    return field_name


class ListQuery(WaylayBaseModel):
    """Model for `list` query parameters."""

    type: Annotated[
        PlugType | None, Field(description="If set, filters on the type of plug.")
    ] = None
    limit: Annotated[
        Annotated[float, Field(strict=True, ge=0)]
        | Annotated[int, Field(strict=True, ge=0)]
        | None,
        Field(
            description="The maximum number of items to be return from this query. Has a deployment-defined default and maximum value."
        ),
    ] = None
    page: Annotated[
        Annotated[float, Field(strict=True, ge=0)]
        | Annotated[int, Field(strict=True, ge=0)]
        | None,
        Field(
            description="The number of pages to skip when returning result to this query."
        ),
    ] = None
    include_draft: Annotated[
        StrictBool | None,
        Field(
            description="Configures the inclusion of _draft_ versions when selecting latest versions per name. By default, draft versions are only considered when no other versions are available. If set to `true`, draft versions are **included**. If set to `false`, draft versions are **excluded**."
        ),
    ] = None
    include_deprecated: Annotated[
        StrictBool | None,
        Field(
            description="Configures the inclusion of _deprecated_ versions when selecting latest versions per name. By default, deprecated versions are only considered when no other versions are available. If set to `true`, deprecated versions are **included**. If set to `false`, deprecated versions are **excluded**."
        ),
    ] = None
    deprecated: Annotated[
        StrictBool | None,
        Field(description="Filter on the deprecation status of the function."),
    ] = None
    draft: Annotated[
        StrictBool | None,
        Field(description="Filter on the draft status of the function."),
    ] = None
    name_version: Annotated[
        List[Annotated[str, Field(strict=True)]] | None,
        Field(
            description="Filter on exact `{name}@{version}` functions. Using this filter implies a `latest=false` default, returning multiple versions of the same named versions if they are filtered."
        ),
    ] = None
    show_tags: Annotated[
        Any | None,
        Field(
            description="Instructs how tag (objects) should be rendered in responses. The tags are show at the `tags` property of the manifest (legacy: the `metadata.tags` property) - `inline`: Show full tag objects in the manifest. - `embed`: Show tag references in the manifest.          Referenced full tag objects are included in a separate `_embedded` HAL section. - `none`: Show tag references in the manifest. Do not render tag objects.  The default behaviour depends on deployment settings."
        ),
    ] = None
    tags: Annotated[
        Any | None,
        Field(
            description="Filter on the tags of the item. Can be a single tag, or a list of tags. When multiple tags are specified, an item must have all of the tags to be selected."
        ),
    ] = None
    wql: Annotated[
        StrictStr | None,
        Field(
            description='Query filter using the \'wql\' query language.  This is a unstable preview feature, currently supporting the following _match terms_: * `tag:<name>` entity has a tag that fully matches `<name>` (case insensitive). * `tag:<name1>,<name2>` entity has a tag that fully matches any of `<name1>`, `<name2>` (case insensitive). * `tag:inIgnoreCase(<name1>,<name2>)` is the fully specified format for the previous statements.   `inIgnoreCase` is the _default match predicate_. * `tag:in(<name1>,<name2>)` entity has a tag matches one of `<name1>`,`<name2>` (case sensitive) * `tag:equals(<name>)` entity has a tag matches `<name>` (case sensitive) * `tag:like(<pattern>)` entity has a tag that matches `<pattern>` (case insensitive),    where `<pattern>` can contain `*` (multiple characters) and `?` (single character) wildcards.  Each _argument_ of a _match term_ (like `<name>` above) can either be a * a _quoted match argument_, quoted using `"`, can contain any character except `"`: `tag:"Status:In Review"`. * a _safe match argument_ can only contain alpha-numeric characters or `_`: `tag:Status_In_Review`.  Multiple _match term_s can be combined in a boolean predicate using the `AND`, `OR` and `NOT` operators: * `tag:abc AND tag:"My Demo" AND tag:like("prj:*")`: entity has a tag matching `abc` **AND** a tag matching `"My Demo"` **AND**    a tag that has the `prj:` prefix * `tag:abc tag:"My Demo" tag:like("prj:*")`: same as the previous statement: a (space-deliminated) list of terms is     implicitly combined with `AND`. * `tag:abc OR tag:"My Demo"`: entity has a tag matching `abc` **OR** a tag matching `"My Demo"` * `NOT tag:abc`: entity **does not have** a tag matching `abc`  Round brackets can be used to combine predicates with different operators: * `(tag:abc OR tag:"My Demo") AND tag:like("prj:*")`: entity has a tag `abc` or a tag `My Demo`, and a tag with prefix `prj:*`  For a _multi-valued attribute_ like `tag`, each _match term_ tests the existence of a matching tag assigned to the entity. When _multiple match predicates on the **same** tag_ need to be specified, the boolean operators `not`, `all`, `any` can be used _within_ the match term:  * `tag:all(like("prj:*"),not(like("*:Done")))`: entity has a tag that starts with `prj:` and does NOT end with `:Done`. * `tag:not(Done)`: entity has a tag that does not match `Done` (this excludes entities without tags, and with a single `Done` tag!). * `NOT tag:not(in(abc,def))`: each tag of the entity is in `abc` or `def` (matches entities without tags!) * `tag:any(like("prj:*"),not(done)))`: entity has a tag that either starts with `prj:` or does not match `done`.'
        ),
    ] = None
    version: Annotated[
        StrictStr | None,
        Field(
            description="Filter on the version of the function (case-sensitive, supports wildcards)."
        ),
    ] = None
    status: Annotated[
        List[StatusFilter] | None,
        Field(
            description="Filter on the status of the plug. Filter values with a `-` postfix exclude the status. Use the `any` filter value to include all states. When not specified, a default `undeployed-` filter excludes _undeployed_ functions."
        ),
    ] = None
    runtime_version: Annotated[
        Any | None, Field(description="Filter on the runtime version.")
    ] = None
    created_by: Annotated[
        StrictStr | None,
        Field(
            description="Filter on the user that create the plug. You can use the `@me` token to indicate your own plugs."
        ),
    ] = None
    updated_by: Annotated[
        StrictStr | None,
        Field(
            description="Filter on the user that last updated the plug. You can use the `@me` token to indicate your own plugs."
        ),
    ] = None
    created_before: Annotated[
        Any | None,
        Field(
            description="Filter on funtions that were created before the given timestamp or age."
        ),
    ] = None
    created_after: Annotated[
        Any | None,
        Field(
            description="Filter on funtions that were created after the given timestamp or age."
        ),
    ] = None
    updated_before: Annotated[
        Any | None,
        Field(
            description="Filter on funtions that were updated before the given timestamp or age."
        ),
    ] = None
    updated_after: Annotated[
        Any | None,
        Field(
            description="Filter on funtions that were updated after the given timestamp or age."
        ),
    ] = None
    name: Annotated[
        StrictStr | None,
        Field(
            description="Filter on the name of the function. This is case-insensitive and supports wild-cards `?` (any one character) and `*` (any sequence of characters)."
        ),
    ] = None
    archive_format: Annotated[
        List[ArchiveFormatFilter] | None,
        Field(description="Filter on the archive format of the function."),
    ] = None
    runtime: Annotated[
        List[StrictStr] | None,
        Field(description="Filter on the runtime of the function."),
    ] = None
    latest: Annotated[
        StrictBool | None,
        Field(
            description="When `true`, only the latest version per function name is returned. If set to `false`, multiple versions per named function can be returned. Defaults to `true`, except when specific versions are selected with the `nameVersion` filter."
        ),
    ] = None
    show_related: Annotated[
        Any | None,
        Field(
            description="Sets the representation of related function versions (like the _latest_ draft and/or published) in the response. Ignored (forced to `none`) when any of the _version filter_ query params are used. - `embed`: as full summary representation (in `_embedded`). - `link`: as HAL link in (in `_links`). - `none`: omitted."
        ),
    ] = None

    model_config = ConfigDict(
        protected_namespaces=(),
        extra="allow",
        alias_generator=_list_query_alias_for,
        populate_by_name=True,
    )


def _list_versions_query_alias_for(field_name: str) -> str:
    if field_name == "limit":
        return "limit"
    if field_name == "page":
        return "page"
    if field_name == "deprecated":
        return "deprecated"
    if field_name == "draft":
        return "draft"
    if field_name == "show_tags":
        return "showTags"
    if field_name == "tags":
        return "tags"
    if field_name == "version":
        return "version"
    if field_name == "status":
        return "status"
    if field_name == "runtime_version":
        return "runtimeVersion"
    if field_name == "created_by":
        return "createdBy"
    if field_name == "updated_by":
        return "updatedBy"
    if field_name == "created_before":
        return "createdBefore"
    if field_name == "created_after":
        return "createdAfter"
    if field_name == "updated_before":
        return "updatedBefore"
    if field_name == "updated_after":
        return "updatedAfter"
    if field_name == "archive_format":
        return "archiveFormat"
    if field_name == "runtime":
        return "runtime"
    return field_name


class ListVersionsQuery(WaylayBaseModel):
    """Model for `list_versions` query parameters."""

    limit: Annotated[
        Annotated[float, Field(strict=True, ge=0)]
        | Annotated[int, Field(strict=True, ge=0)]
        | None,
        Field(
            description="The maximum number of items to be return from this query. Has a deployment-defined default and maximum value."
        ),
    ] = None
    page: Annotated[
        Annotated[float, Field(strict=True, ge=0)]
        | Annotated[int, Field(strict=True, ge=0)]
        | None,
        Field(
            description="The number of pages to skip when returning result to this query."
        ),
    ] = None
    deprecated: Annotated[
        StrictBool | None,
        Field(description="Filter on the deprecation status of the function."),
    ] = None
    draft: Annotated[
        StrictBool | None,
        Field(description="Filter on the draft status of the function."),
    ] = None
    show_tags: Annotated[
        Any | None,
        Field(
            description="Instructs how tag (objects) should be rendered in responses. The tags are show at the `tags` property of the manifest (legacy: the `metadata.tags` property) - `inline`: Show full tag objects in the manifest. - `embed`: Show tag references in the manifest.          Referenced full tag objects are included in a separate `_embedded` HAL section. - `none`: Show tag references in the manifest. Do not render tag objects.  The default behaviour depends on deployment settings."
        ),
    ] = None
    tags: Annotated[
        Any | None,
        Field(
            description="Filter on the tags of the item. Can be a single tag, or a list of tags. When multiple tags are specified, an item must have all of the tags to be selected."
        ),
    ] = None
    version: Annotated[
        StrictStr | None,
        Field(
            description="Filter on the version of the function (case-sensitive, supports wildcards)."
        ),
    ] = None
    status: Annotated[
        List[StatusFilter] | None,
        Field(
            description="Filter on the status of the plug. Filter values with a `-` postfix exclude the status. Use the `any` filter value to include all states. When not specified, a default `undeployed-` filter excludes _undeployed_ functions."
        ),
    ] = None
    runtime_version: Annotated[
        Any | None, Field(description="Filter on the runtime version.")
    ] = None
    created_by: Annotated[
        StrictStr | None,
        Field(
            description="Filter on the user that create the plug. You can use the `@me` token to indicate your own plugs."
        ),
    ] = None
    updated_by: Annotated[
        StrictStr | None,
        Field(
            description="Filter on the user that last updated the plug. You can use the `@me` token to indicate your own plugs."
        ),
    ] = None
    created_before: Annotated[
        Any | None,
        Field(
            description="Filter on funtions that were created before the given timestamp or age."
        ),
    ] = None
    created_after: Annotated[
        Any | None,
        Field(
            description="Filter on funtions that were created after the given timestamp or age."
        ),
    ] = None
    updated_before: Annotated[
        Any | None,
        Field(
            description="Filter on funtions that were updated before the given timestamp or age."
        ),
    ] = None
    updated_after: Annotated[
        Any | None,
        Field(
            description="Filter on funtions that were updated after the given timestamp or age."
        ),
    ] = None
    archive_format: Annotated[
        List[ArchiveFormatFilter] | None,
        Field(description="Filter on the archive format of the function."),
    ] = None
    runtime: Annotated[
        List[StrictStr] | None,
        Field(description="Filter on the runtime of the function."),
    ] = None

    model_config = ConfigDict(
        protected_namespaces=(),
        extra="allow",
        alias_generator=_list_versions_query_alias_for,
        populate_by_name=True,
    )


def _patch_interface_query_alias_for(field_name: str) -> str:
    if field_name == "comment":
        return "comment"
    if field_name == "show_tags":
        return "showTags"
    return field_name


class PatchInterfaceQuery(WaylayBaseModel):
    """Model for `patch_interface` query parameters."""

    comment: Annotated[
        StrictStr | None,
        Field(
            description="An optional user-specified comment corresponding to the operation."
        ),
    ] = None
    show_tags: Annotated[
        Any | None,
        Field(
            description="Instructs how tag (objects) should be rendered in responses. The tags are show at the `tags` property of the manifest (legacy: the `metadata.tags` property) - `inline`: Show full tag objects in the manifest. - `embed`: Show tag references in the manifest.          Referenced full tag objects are included in a separate `_embedded` HAL section. - `none`: Show tag references in the manifest. Do not render tag objects.  The default behaviour depends on deployment settings."
        ),
    ] = None

    model_config = ConfigDict(
        protected_namespaces=(),
        extra="allow",
        alias_generator=_patch_interface_query_alias_for,
        populate_by_name=True,
    )


def _patch_metadata_query_alias_for(field_name: str) -> str:
    if field_name == "comment":
        return "comment"
    if field_name == "show_tags":
        return "showTags"
    return field_name


class PatchMetadataQuery(WaylayBaseModel):
    """Model for `patch_metadata` query parameters."""

    comment: Annotated[
        StrictStr | None,
        Field(
            description="An optional user-specified comment corresponding to the operation."
        ),
    ] = None
    show_tags: Annotated[
        Any | None,
        Field(
            description="Instructs how tag (objects) should be rendered in responses. The tags are show at the `tags` property of the manifest (legacy: the `metadata.tags` property) - `inline`: Show full tag objects in the manifest. - `embed`: Show tag references in the manifest.          Referenced full tag objects are included in a separate `_embedded` HAL section. - `none`: Show tag references in the manifest. Do not render tag objects.  The default behaviour depends on deployment settings."
        ),
    ] = None

    model_config = ConfigDict(
        protected_namespaces=(),
        extra="allow",
        alias_generator=_patch_metadata_query_alias_for,
        populate_by_name=True,
    )


def _protect_query_alias_for(field_name: str) -> str:
    if field_name == "author":
        return "author"
    if field_name == "chown":
        return "chown"
    if field_name == "comment":
        return "comment"
    if field_name == "show_tags":
        return "showTags"
    if field_name == "enable":
        return "enable"
    return field_name


class ProtectQuery(WaylayBaseModel):
    """Model for `protect` query parameters."""

    author: Annotated[
        StrictStr | None,
        Field(
            description="Optionally changes the author metadata when updating a function."
        ),
    ] = None
    chown: Annotated[
        StrictBool | None,
        Field(
            description="If set, ownership of a draft function is transferred to the current user."
        ),
    ] = None
    comment: Annotated[
        StrictStr | None,
        Field(
            description="An optional user-specified comment corresponding to the operation."
        ),
    ] = None
    show_tags: Annotated[
        Any | None,
        Field(
            description="Instructs how tag (objects) should be rendered in responses. The tags are show at the `tags` property of the manifest (legacy: the `metadata.tags` property) - `inline`: Show full tag objects in the manifest. - `embed`: Show tag references in the manifest.          Referenced full tag objects are included in a separate `_embedded` HAL section. - `none`: Show tag references in the manifest. Do not render tag objects.  The default behaviour depends on deployment settings."
        ),
    ] = None
    enable: Annotated[
        StrictBool | None,
        Field(
            description="If set to `true`, the function assets (including its code) will be protected by requiring additional permissions. If set to `false`, the function assets will no longer be protected."
        ),
    ] = None

    model_config = ConfigDict(
        protected_namespaces=(),
        extra="allow",
        alias_generator=_protect_query_alias_for,
        populate_by_name=True,
    )


def _protect_versions_query_alias_for(field_name: str) -> str:
    if field_name == "author":
        return "author"
    if field_name == "chown":
        return "chown"
    if field_name == "comment":
        return "comment"
    if field_name == "show_tags":
        return "showTags"
    if field_name == "enable":
        return "enable"
    return field_name


class ProtectVersionsQuery(WaylayBaseModel):
    """Model for `protect_versions` query parameters."""

    author: Annotated[
        StrictStr | None,
        Field(
            description="Optionally changes the author metadata when updating a function."
        ),
    ] = None
    chown: Annotated[
        StrictBool | None,
        Field(
            description="If set, ownership of a draft function is transferred to the current user."
        ),
    ] = None
    comment: Annotated[
        StrictStr | None,
        Field(
            description="An optional user-specified comment corresponding to the operation."
        ),
    ] = None
    show_tags: Annotated[
        Any | None,
        Field(
            description="Instructs how tag (objects) should be rendered in responses. The tags are show at the `tags` property of the manifest (legacy: the `metadata.tags` property) - `inline`: Show full tag objects in the manifest. - `embed`: Show tag references in the manifest.          Referenced full tag objects are included in a separate `_embedded` HAL section. - `none`: Show tag references in the manifest. Do not render tag objects.  The default behaviour depends on deployment settings."
        ),
    ] = None
    enable: Annotated[
        StrictBool | None,
        Field(
            description="If set to `true`, the function assets (including its code) will be protected by requiring additional permissions. If set to `false`, the function assets will no longer be protected."
        ),
    ] = None

    model_config = ConfigDict(
        protected_namespaces=(),
        extra="allow",
        alias_generator=_protect_versions_query_alias_for,
        populate_by_name=True,
    )


def _publish_query_alias_for(field_name: str) -> str:
    if field_name == "chown":
        return "chown"
    if field_name == "comment":
        return "comment"
    if field_name == "author":
        return "author"
    if field_name == "deprecate_previous":
        return "deprecatePrevious"
    if field_name == "var_async":
        return "async"
    return field_name


class PublishQuery(WaylayBaseModel):
    """Model for `publish` query parameters."""

    chown: Annotated[
        StrictBool | None,
        Field(
            description="If set, ownership of a draft function is transferred to the current user."
        ),
    ] = None
    comment: Annotated[
        StrictStr | None,
        Field(
            description="An optional user-specified comment corresponding to the operation."
        ),
    ] = None
    author: Annotated[
        StrictStr | None,
        Field(
            description="Optionally changes the author metadata when updating a function."
        ),
    ] = None
    deprecate_previous: Annotated[
        Any | None,
        Field(
            description="Set the cleanup policy used to automatically deprecate/delete previous versions."
        ),
    ] = None
    var_async: Annotated[
        StrictBool | None,
        Field(
            description="Unless this is set to <code>false</code>, the server will start the required job actions asynchronously and return a <code>202</code> <em>Accepted</em> response. If <code>false</code> the request will block until the job actions are completed, or a timeout occurs."
        ),
    ] = None

    model_config = ConfigDict(
        protected_namespaces=(),
        extra="allow",
        alias_generator=_publish_query_alias_for,
        populate_by_name=True,
    )


def _rebuild_query_alias_for(field_name: str) -> str:
    if field_name == "scale_to_zero":
        return "scaleToZero"
    if field_name == "comment":
        return "comment"
    if field_name == "dry_run":
        return "dryRun"
    if field_name == "var_async":
        return "async"
    if field_name == "show_tags":
        return "showTags"
    if field_name == "upgrade":
        return "upgrade"
    if field_name == "force_version":
        return "forceVersion"
    if field_name == "ignore_checks":
        return "ignoreChecks"
    if field_name == "skip_rebuild":
        return "skipRebuild"
    if field_name == "skip_verify":
        return "skipVerify"
    return field_name


class RebuildQuery(WaylayBaseModel):
    """Model for `rebuild` query parameters."""

    scale_to_zero: Annotated[
        StrictBool | None,
        Field(
            description="Indicates whether the function needs to be scaled down after successful verification. If not set, the function is scaled to zero only if it was not active before this command."
        ),
    ] = None
    comment: Annotated[
        StrictStr | None,
        Field(
            description="An optional user-specified comment corresponding to the operation."
        ),
    ] = None
    dry_run: Annotated[
        StrictBool | None,
        Field(
            description="If set to <code>true</code>, checks whether rebuild jobs are needed, but do not start any jobs."
        ),
    ] = None
    var_async: Annotated[
        StrictBool | None,
        Field(
            description="Unless this is set to <code>false</code>, the server will start the required job actions asynchronously and return a <code>202</code> <em>Accepted</em> response. If <code>false</code> the request will block until the job actions are completed, or a timeout occurs."
        ),
    ] = None
    show_tags: Annotated[
        Any | None,
        Field(
            description="Instructs how tag (objects) should be rendered in responses. The tags are show at the `tags` property of the manifest (legacy: the `metadata.tags` property) - `inline`: Show full tag objects in the manifest. - `embed`: Show tag references in the manifest.          Referenced full tag objects are included in a separate `_embedded` HAL section. - `none`: Show tag references in the manifest. Do not render tag objects.  The default behaviour depends on deployment settings."
        ),
    ] = None
    upgrade: Annotated[
        RebuildPolicy | None,
        Field(
            description="If set, force a rebuild with the given <em>runtime</em> version selection policy. <ul>  <li><code>same</code> <b>patch</b> version.   This should only include backward compatible upgrades.  </li>  <li><code>minor</code> <b>major</b> version.   This might include an upgrade of e.g. the language runtime and/or provided   dependencies that could break compatiblity with the function. .</li> </ul>"
        ),
    ] = None
    force_version: Annotated[
        Annotated[str, Field(strict=True)] | None,
        Field(
            description="If set, force a rebuild with the given runtime version (including downgrades). This parameter is mutually exclusive to the `upgrade` parameter."
        ),
    ] = None
    ignore_checks: Annotated[
        StrictBool | None,
        Field(
            description="If set to true, checks that normally prevent a rebuild are overriden. These checks include: * function state in `pending`, `running`, `failed` or `undeployed` * backoff period due to recent failures * usage of deprecated dependencies * running jobs on entity * the `dryRun` option"
        ),
    ] = None
    skip_rebuild: Annotated[
        StrictBool | None,
        Field(
            description="If set, the function will not be rebuild. Always uses the current runtime version when re-deploying/re-verifying the function."
        ),
    ] = None
    skip_verify: Annotated[
        StrictBool | None,
        Field(
            description="If set, the function will not be validated: it transitions to `running` without verification of it's deployment health. When a `scaleToZero` is requested or implied, it is executed at the end of the deployment job, rather than as a separate job."
        ),
    ] = None

    model_config = ConfigDict(
        protected_namespaces=(),
        extra="allow",
        alias_generator=_rebuild_query_alias_for,
        populate_by_name=True,
    )


def _remove_version_query_alias_for(field_name: str) -> str:
    if field_name == "comment":
        return "comment"
    if field_name == "var_async":
        return "async"
    if field_name == "force":
        return "force"
    if field_name == "undeploy":
        return "undeploy"
    if field_name == "reset":
        return "reset"
    return field_name


class RemoveVersionQuery(WaylayBaseModel):
    """Model for `remove_version` query parameters."""

    comment: Annotated[
        StrictStr | None,
        Field(
            description="An optional user-specified comment corresponding to the operation."
        ),
    ] = None
    var_async: Annotated[
        StrictBool | None,
        Field(
            description="Unless this is set to <code>false</code>, the server will start the required job actions asynchronously and return a <code>202</code> <em>Accepted</em> response. If <code>false</code> the request will block until the job actions are completed, or a timeout occurs."
        ),
    ] = None
    force: Annotated[
        StrictBool | None,
        Field(
            description="If <code>true</code>, the plug version(s) will be undeployed and removed. Otherwise, the plug version(s) will only be <code>deprecated</code>, i.e removed from regular listings."
        ),
    ] = None
    undeploy: Annotated[
        StrictBool | None,
        Field(
            description="If `true`, the `DELETE` operation * undeploys the (openfaas) function for the plug: it becomes no longer available for invocation. * does NOT remove the plug from registry: it stays in an `undeployed` status.  All assets and definitions are retained, so the plug can be restored later with a  _rebuild_ action.  If `false`, the `DELETE` operation * _only_ marks the plug version(s) as _deprecated_: the plug remains active but is removed from the default listings.   This also applies to _draft_ versions.  Setting this parameter is incompatible with `force=true` or `reset=true`.  If not set the default behaviour applies: * _draft_ versions are _undeployed_ and _removed_ from registry. * non-_draft_ versions are marked _deprecated_ only."
        ),
    ] = None
    reset: Annotated[
        StrictBool | None,
        Field(
            description="If `true`, the function version will be immediately undeployed and reset to `registered` state as a _draft_. This is incompatible with `force=true` or `undeploy=false`."
        ),
    ] = None

    model_config = ConfigDict(
        protected_namespaces=(),
        extra="allow",
        alias_generator=_remove_version_query_alias_for,
        populate_by_name=True,
    )


def _remove_versions_query_alias_for(field_name: str) -> str:
    if field_name == "comment":
        return "comment"
    if field_name == "var_async":
        return "async"
    if field_name == "force":
        return "force"
    if field_name == "undeploy":
        return "undeploy"
    if field_name == "reset":
        return "reset"
    return field_name


class RemoveVersionsQuery(WaylayBaseModel):
    """Model for `remove_versions` query parameters."""

    comment: Annotated[
        StrictStr | None,
        Field(
            description="An optional user-specified comment corresponding to the operation."
        ),
    ] = None
    var_async: Annotated[
        StrictBool | None,
        Field(
            description="Unless this is set to <code>false</code>, the server will start the required job actions asynchronously and return a <code>202</code> <em>Accepted</em> response. If <code>false</code> the request will block until the job actions are completed, or a timeout occurs."
        ),
    ] = None
    force: Annotated[
        StrictBool | None,
        Field(
            description="If <code>true</code>, the plug version(s) will be undeployed and removed. Otherwise, the plug version(s) will only be <code>deprecated</code>, i.e removed from regular listings."
        ),
    ] = None
    undeploy: Annotated[
        StrictBool | None,
        Field(
            description="If `true`, the `DELETE` operation * undeploys the (openfaas) function for the plug: it becomes no longer available for invocation. * does NOT remove the plug from registry: it stays in an `undeployed` status.  All assets and definitions are retained, so the plug can be restored later with a  _rebuild_ action.  If `false`, the `DELETE` operation * _only_ marks the plug version(s) as _deprecated_: the plug remains active but is removed from the default listings.   This also applies to _draft_ versions.  Setting this parameter is incompatible with `force=true` or `reset=true`.  If not set the default behaviour applies: * _draft_ versions are _undeployed_ and _removed_ from registry. * non-_draft_ versions are marked _deprecated_ only."
        ),
    ] = None
    reset: Annotated[
        StrictBool | None,
        Field(
            description="If `true`, the function version will be immediately undeployed and reset to `registered` state as a _draft_. This is incompatible with `force=true` or `undeploy=false`."
        ),
    ] = None

    model_config = ConfigDict(
        protected_namespaces=(),
        extra="allow",
        alias_generator=_remove_versions_query_alias_for,
        populate_by_name=True,
    )


def _update_asset_query_alias_for(field_name: str) -> str:
    if field_name == "scale_to_zero":
        return "scaleToZero"
    if field_name == "deploy":
        return "deploy"
    if field_name == "chown":
        return "chown"
    if field_name == "comment":
        return "comment"
    if field_name == "author":
        return "author"
    if field_name == "var_async":
        return "async"
    return field_name


class UpdateAssetQuery(WaylayBaseModel):
    """Model for `update_asset` query parameters."""

    scale_to_zero: Annotated[
        StrictBool | None,
        Field(
            description="If set to <code>true</code>, after successful deployment, the deployed function will be scaled to zero. This saves computing resources when the function is not to be used immediately."
        ),
    ] = None
    deploy: Annotated[
        StrictBool | None,
        Field(
            description="Indicates that a function should be _deployed_ when its assets are valid.  * If `true` (default), jobs to build and deploy the function will be initiated after it is checked that the assets are valid. Invalid assets lead to a validation error, and the function and its assets are not created or updated. * If `false`, the uploaded assets are stored and the function is created/updated in `registered` state. Asset validation errors are only returned as warning, and stored as `failureReason` on the function entity. Use an _asset update_ or _rebuild_ to initiate a build and deploy at a later stage."
        ),
    ] = None
    chown: Annotated[
        StrictBool | None,
        Field(
            description="If set, ownership of a draft function is transferred to the current user."
        ),
    ] = None
    comment: Annotated[
        StrictStr | None,
        Field(
            description="An optional user-specified comment corresponding to the operation."
        ),
    ] = None
    author: Annotated[
        StrictStr | None,
        Field(
            description="Optionally changes the author metadata when updating a function."
        ),
    ] = None
    var_async: Annotated[
        StrictBool | None,
        Field(
            description="Unless this is set to <code>false</code>, the server will start the required job actions asynchronously and return a <code>202</code> <em>Accepted</em> response. If <code>false</code> the request will block until the job actions are completed, or a timeout occurs."
        ),
    ] = None

    model_config = ConfigDict(
        protected_namespaces=(),
        extra="allow",
        alias_generator=_update_asset_query_alias_for,
        populate_by_name=True,
    )


def _update_assets_query_alias_for(field_name: str) -> str:
    if field_name == "scale_to_zero":
        return "scaleToZero"
    if field_name == "deploy":
        return "deploy"
    if field_name == "chown":
        return "chown"
    if field_name == "comment":
        return "comment"
    if field_name == "author":
        return "author"
    if field_name == "var_async":
        return "async"
    return field_name


class UpdateAssetsQuery(WaylayBaseModel):
    """Model for `update_assets` query parameters."""

    scale_to_zero: Annotated[
        StrictBool | None,
        Field(
            description="If set to <code>true</code>, after successful deployment, the deployed function will be scaled to zero. This saves computing resources when the function is not to be used immediately."
        ),
    ] = None
    deploy: Annotated[
        StrictBool | None,
        Field(
            description="Indicates that a function should be _deployed_ when its assets are valid.  * If `true` (default), jobs to build and deploy the function will be initiated after it is checked that the assets are valid. Invalid assets lead to a validation error, and the function and its assets are not created or updated. * If `false`, the uploaded assets are stored and the function is created/updated in `registered` state. Asset validation errors are only returned as warning, and stored as `failureReason` on the function entity. Use an _asset update_ or _rebuild_ to initiate a build and deploy at a later stage."
        ),
    ] = None
    chown: Annotated[
        StrictBool | None,
        Field(
            description="If set, ownership of a draft function is transferred to the current user."
        ),
    ] = None
    comment: Annotated[
        StrictStr | None,
        Field(
            description="An optional user-specified comment corresponding to the operation."
        ),
    ] = None
    author: Annotated[
        StrictStr | None,
        Field(
            description="Optionally changes the author metadata when updating a function."
        ),
    ] = None
    var_async: Annotated[
        StrictBool | None,
        Field(
            description="Unless this is set to <code>false</code>, the server will start the required job actions asynchronously and return a <code>202</code> <em>Accepted</em> response. If <code>false</code> the request will block until the job actions are completed, or a timeout occurs."
        ),
    ] = None

    model_config = ConfigDict(
        protected_namespaces=(),
        extra="allow",
        alias_generator=_update_assets_query_alias_for,
        populate_by_name=True,
    )


def _verify_query_alias_for(field_name: str) -> str:
    if field_name == "scale_to_zero":
        return "scaleToZero"
    if field_name == "show_tags":
        return "showTags"
    if field_name == "var_async":
        return "async"
    return field_name


class VerifyQuery(WaylayBaseModel):
    """Model for `verify` query parameters."""

    scale_to_zero: Annotated[
        StrictBool | None,
        Field(
            description="Indicates whether the function needs to be scaled down after successful verification. If not set, the function is scaled to zero only if it was not active before this command."
        ),
    ] = None
    show_tags: Annotated[
        Any | None,
        Field(
            description="Instructs how tag (objects) should be rendered in responses. The tags are show at the `tags` property of the manifest (legacy: the `metadata.tags` property) - `inline`: Show full tag objects in the manifest. - `embed`: Show tag references in the manifest.          Referenced full tag objects are included in a separate `_embedded` HAL section. - `none`: Show tag references in the manifest. Do not render tag objects.  The default behaviour depends on deployment settings."
        ),
    ] = None
    var_async: Annotated[
        StrictBool | None,
        Field(
            description="Unless this is set to <code>false</code>, the server will start the required job actions asynchronously and return a <code>202</code> <em>Accepted</em> response. If <code>false</code> the request will block until the job actions are completed, or a timeout occurs."
        ),
    ] = None

    model_config = ConfigDict(
        protected_namespaces=(),
        extra="allow",
        alias_generator=_verify_query_alias_for,
        populate_by_name=True,
    )
