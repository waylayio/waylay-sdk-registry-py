# coding: utf-8
"""Waylay Function Registry api.

This code was generated from the OpenAPI documentation of 'Waylay Function Registry'

Generated by OpenAPI Generator (https://openapi-generator.tech)

Do not edit the class manually.
"""

from __future__ import annotations  # for Python 3.7â€“3.9

from typing import (
    TYPE_CHECKING,
    Any,
    Dict,
    Literal,
    TypeVar,
    overload,
)

from pydantic import (
    Field,
    StrictBool,
    StrictStr,
    TypeAdapter,
)
from typing_extensions import (
    Annotated,  # >=3.9,
)
from waylay.sdk.api import (
    HeaderTypes,
    QueryParamTypes,
    Response,
)
from waylay.sdk.api._models import Model
from waylay.sdk.plugin import WithApiClient

if TYPE_CHECKING:
    from waylay.services.registry.models import (
        RuntimeSummaryResponse,
        RuntimeVersionResponse,
        SemanticVersionRange,
    )
    from waylay.services.registry.queries.runtimes_api import (
        ExampleArchiveQuery,
        GetExampleAssetQuery,
        GetLatestQuery,
        GetQuery,
        ListQuery,
        ListVersionsQuery,
    )


try:
    from waylay.services.registry.models import (
        RuntimeSummaryResponse,
        RuntimeVersionResponse,
        SemanticVersionRange,
    )
    from waylay.services.registry.queries.runtimes_api import (
        ExampleArchiveQuery,
        GetExampleAssetQuery,
        GetLatestQuery,
        GetQuery,
        ListQuery,
        ListVersionsQuery,
    )

    MODELS_AVAILABLE = True
except ImportError:
    MODELS_AVAILABLE = False

    if not TYPE_CHECKING:
        SemanticVersionRange = str
        ExampleArchiveQuery = dict

        SemanticVersionRange = str
        GetExampleAssetQuery = dict

        GetLatestQuery = dict
        RuntimeVersionResponse = Model

        SemanticVersionRange = str
        GetQuery = dict
        RuntimeVersionResponse = Model

        ListQuery = dict
        RuntimeSummaryResponse = Model

        ListVersionsQuery = dict
        RuntimeSummaryResponse = Model


T = TypeVar("T")


class RuntimesApi(WithApiClient):
    """RuntimesApi service methods.

    NOTE: This class is auto generated by OpenAPI Generator
    Ref: https://openapi-generator.tech

    Do not edit the class manually.
    """

    @overload
    async def example_archive(
        self,
        name: Annotated[StrictStr, Field(description="The name of a <em>runtime</em>")],
        version: Annotated[
            Any, Field(description="A version range for a <em>runtime</em>")
        ],
        *,
        query: ExampleArchiveQuery | QueryParamTypes | None = None,
        raw_response: Literal[False] = False,
        select_path: Literal[""] = "",
        response_type: Literal[None] = None,
        validate_request: StrictBool = True,
        headers: HeaderTypes | None = None,
        **kwargs,
    ) -> bytearray: ...

    @overload
    async def example_archive(
        self,
        name: Annotated[StrictStr, Field(description="The name of a <em>runtime</em>")],
        version: Annotated[
            Any, Field(description="A version range for a <em>runtime</em>")
        ],
        *,
        query: ExampleArchiveQuery | QueryParamTypes | None = None,
        raw_response: Literal[False] = False,
        select_path: Literal[""] = "",
        response_type: T,
        validate_request: StrictBool = True,
        headers: HeaderTypes | None = None,
        **kwargs,
    ) -> T: ...

    @overload
    async def example_archive(
        self,
        name: Annotated[StrictStr, Field(description="The name of a <em>runtime</em>")],
        version: Annotated[
            Any, Field(description="A version range for a <em>runtime</em>")
        ],
        *,
        query: ExampleArchiveQuery | QueryParamTypes | None = None,
        raw_response: Literal[True],
        select_path: Literal["_not_used_"] = "_not_used_",
        response_type: Literal[None] = None,  # not used
        validate_request: StrictBool = True,
        headers: HeaderTypes | None = None,
        **kwargs,
    ) -> Response: ...

    @overload
    async def example_archive(
        self,
        name: Annotated[StrictStr, Field(description="The name of a <em>runtime</em>")],
        version: Annotated[
            Any, Field(description="A version range for a <em>runtime</em>")
        ],
        *,
        query: ExampleArchiveQuery | QueryParamTypes | None = None,
        raw_response: Literal[False] = False,
        select_path: str,
        response_type: Literal[None] = None,
        validate_request: StrictBool = True,
        headers: HeaderTypes | None = None,
        **kwargs,
    ) -> Model: ...

    @overload
    async def example_archive(
        self,
        name: Annotated[StrictStr, Field(description="The name of a <em>runtime</em>")],
        version: Annotated[
            Any, Field(description="A version range for a <em>runtime</em>")
        ],
        *,
        query: ExampleArchiveQuery | QueryParamTypes | None = None,
        raw_response: Literal[False] = False,
        select_path: str,
        response_type: T,
        validate_request: StrictBool = True,
        headers: HeaderTypes | None = None,
        **kwargs,
    ) -> T: ...

    async def example_archive(
        self,
        name: Annotated[StrictStr, Field(description="The name of a <em>runtime</em>")],
        version: Annotated[
            Any, Field(description="A version range for a <em>runtime</em>")
        ],
        *,
        query: ExampleArchiveQuery | QueryParamTypes | None = None,
        raw_response: StrictBool = False,
        select_path: str = "",
        response_type: T | None = None,
        validate_request: StrictBool = True,
        headers: HeaderTypes | None = None,
        **kwargs,
    ) -> bytearray | T | Response | Model:
        """Get Runtime Example Archive.

        Get an example of the specification archive of the runtime.
        :param name: The name of a <em>runtime</em> (required)
        :type name: str
        :param version: A version range for a <em>runtime</em> (required)
        :type version: SemanticVersionRange
        :param query: URL Query parameters.
        :type query: ExampleArchiveQuery | QueryParamTypes, optional
        :param query['ls'] (dict) <br> query.ls (Query) : If set to `true`, the result will be a listing of the files in the asset, annotated with metadata and validation report from the asset conditions of the functions runtime.
        :type query['ls']: bool
        :param query['includeDeprecated'] (dict) <br> query.include_deprecated (Query) : If set to `true`, deprecated runtimes will be included in the query.
        :type query['includeDeprecated']: bool
        :param raw_response: If true, return the http Response object instead of returning an api model object, or throwing an ApiError.
        :param select_path: Denotes the json path applied to the response object before returning it.
                Set it to the empty string `""` to receive the full response object.
        :param response_type: If specified, the response is parsed into an instance of the specified type.
        :param validate_request: If set to false, the request body and query parameters are NOT validated against the models in the service types package, even when available.
        :param headers: Header parameters for this request
        :type headers: dict, optional
        :param `**kwargs`: Additional parameters passed on to the http client.
            See below.
        :Keyword Arguments:
            * timeout: a single numeric timeout in seconds,
                or a tuple of _connect_, _read_, _write_ and _pool_ timeouts.
            * stream: if true, the response will be in streaming mode
            * cookies
            * extensions
            * auth
            * follow_redirects: bool

        :return: Returns the result object if the http request succeeded with status code '2XX'.
        :raises APIError: If the http request has a status code different from `2XX`. This
            object wraps both the http Response and any parsed data.
        """

        # path parameters
        path_params: Dict[str, str] = {
            "name": str(name),
            "version": str(version),
        }

        ## named body parameters
        body_args: Dict[str, Any] = {}

        # query parameters
        if query is not None and MODELS_AVAILABLE and validate_request:
            query = TypeAdapter(ExampleArchiveQuery).validate_python(query)

        response_types_map: Dict[str, Any] = (
            {"2XX": response_type}
            if response_type is not None
            else {
                "200": bytearray if not select_path else Model,
            }
        )
        non_200_response_types_map: Dict[str, Any] = {}
        response_types_map.update(non_200_response_types_map)

        ## peform request
        return await self.api_client.request(
            method="GET",
            resource_path="/registry/v2/runtimes/{name}/versions/{version}/example",
            path_params=path_params,
            params=query,
            **body_args,
            headers=headers,
            **kwargs,
            response_type=response_types_map,
            select_path=select_path,
            raw_response=raw_response,
        )

    @overload
    async def get_example_asset(
        self,
        name: Annotated[StrictStr, Field(description="The name of a <em>runtime</em>")],
        version: Annotated[
            Any, Field(description="A version range for a <em>runtime</em>")
        ],
        wildcard: Annotated[
            StrictStr,
            Field(
                description="Full path or path prefix of the asset within the archive"
            ),
        ],
        *,
        query: GetExampleAssetQuery | QueryParamTypes | None = None,
        raw_response: Literal[False] = False,
        select_path: Literal[""] = "",
        response_type: Literal[None] = None,
        validate_request: StrictBool = True,
        headers: HeaderTypes | None = None,
        **kwargs,
    ) -> bytearray: ...

    @overload
    async def get_example_asset(
        self,
        name: Annotated[StrictStr, Field(description="The name of a <em>runtime</em>")],
        version: Annotated[
            Any, Field(description="A version range for a <em>runtime</em>")
        ],
        wildcard: Annotated[
            StrictStr,
            Field(
                description="Full path or path prefix of the asset within the archive"
            ),
        ],
        *,
        query: GetExampleAssetQuery | QueryParamTypes | None = None,
        raw_response: Literal[False] = False,
        select_path: Literal[""] = "",
        response_type: T,
        validate_request: StrictBool = True,
        headers: HeaderTypes | None = None,
        **kwargs,
    ) -> T: ...

    @overload
    async def get_example_asset(
        self,
        name: Annotated[StrictStr, Field(description="The name of a <em>runtime</em>")],
        version: Annotated[
            Any, Field(description="A version range for a <em>runtime</em>")
        ],
        wildcard: Annotated[
            StrictStr,
            Field(
                description="Full path or path prefix of the asset within the archive"
            ),
        ],
        *,
        query: GetExampleAssetQuery | QueryParamTypes | None = None,
        raw_response: Literal[True],
        select_path: Literal["_not_used_"] = "_not_used_",
        response_type: Literal[None] = None,  # not used
        validate_request: StrictBool = True,
        headers: HeaderTypes | None = None,
        **kwargs,
    ) -> Response: ...

    @overload
    async def get_example_asset(
        self,
        name: Annotated[StrictStr, Field(description="The name of a <em>runtime</em>")],
        version: Annotated[
            Any, Field(description="A version range for a <em>runtime</em>")
        ],
        wildcard: Annotated[
            StrictStr,
            Field(
                description="Full path or path prefix of the asset within the archive"
            ),
        ],
        *,
        query: GetExampleAssetQuery | QueryParamTypes | None = None,
        raw_response: Literal[False] = False,
        select_path: str,
        response_type: Literal[None] = None,
        validate_request: StrictBool = True,
        headers: HeaderTypes | None = None,
        **kwargs,
    ) -> Model: ...

    @overload
    async def get_example_asset(
        self,
        name: Annotated[StrictStr, Field(description="The name of a <em>runtime</em>")],
        version: Annotated[
            Any, Field(description="A version range for a <em>runtime</em>")
        ],
        wildcard: Annotated[
            StrictStr,
            Field(
                description="Full path or path prefix of the asset within the archive"
            ),
        ],
        *,
        query: GetExampleAssetQuery | QueryParamTypes | None = None,
        raw_response: Literal[False] = False,
        select_path: str,
        response_type: T,
        validate_request: StrictBool = True,
        headers: HeaderTypes | None = None,
        **kwargs,
    ) -> T: ...

    async def get_example_asset(
        self,
        name: Annotated[StrictStr, Field(description="The name of a <em>runtime</em>")],
        version: Annotated[
            Any, Field(description="A version range for a <em>runtime</em>")
        ],
        wildcard: Annotated[
            StrictStr,
            Field(
                description="Full path or path prefix of the asset within the archive"
            ),
        ],
        *,
        query: GetExampleAssetQuery | QueryParamTypes | None = None,
        raw_response: StrictBool = False,
        select_path: str = "",
        response_type: T | None = None,
        validate_request: StrictBool = True,
        headers: HeaderTypes | None = None,
        **kwargs,
    ) -> bytearray | T | Response | Model:
        """Get File From Runtime Example Archive.

        Get a file from the example specification archive of the runtime.
        :param name: The name of a <em>runtime</em> (required)
        :type name: str
        :param version: A version range for a <em>runtime</em> (required)
        :type version: SemanticVersionRange
        :param wildcard: Full path or path prefix of the asset within the archive (required)
        :type wildcard: str
        :param query: URL Query parameters.
        :type query: GetExampleAssetQuery | QueryParamTypes, optional
        :param query['ls'] (dict) <br> query.ls (Query) : If set to `true`, the result will be a listing of the files in the asset, annotated with metadata and validation report from the asset conditions of the functions runtime.
        :type query['ls']: bool
        :param query['includeDeprecated'] (dict) <br> query.include_deprecated (Query) : If set to `true`, deprecated runtimes will be included in the query.
        :type query['includeDeprecated']: bool
        :param raw_response: If true, return the http Response object instead of returning an api model object, or throwing an ApiError.
        :param select_path: Denotes the json path applied to the response object before returning it.
                Set it to the empty string `""` to receive the full response object.
        :param response_type: If specified, the response is parsed into an instance of the specified type.
        :param validate_request: If set to false, the request body and query parameters are NOT validated against the models in the service types package, even when available.
        :param headers: Header parameters for this request
        :type headers: dict, optional
        :param `**kwargs`: Additional parameters passed on to the http client.
            See below.
        :Keyword Arguments:
            * timeout: a single numeric timeout in seconds,
                or a tuple of _connect_, _read_, _write_ and _pool_ timeouts.
            * stream: if true, the response will be in streaming mode
            * cookies
            * extensions
            * auth
            * follow_redirects: bool

        :return: Returns the result object if the http request succeeded with status code '2XX'.
        :raises APIError: If the http request has a status code different from `2XX`. This
            object wraps both the http Response and any parsed data.
        """

        # path parameters
        path_params: Dict[str, str] = {
            "name": str(name),
            "version": str(version),
            "wildcard": str(wildcard),
        }

        ## named body parameters
        body_args: Dict[str, Any] = {}

        # query parameters
        if query is not None and MODELS_AVAILABLE and validate_request:
            query = TypeAdapter(GetExampleAssetQuery).validate_python(query)

        response_types_map: Dict[str, Any] = (
            {"2XX": response_type}
            if response_type is not None
            else {
                "200": bytearray if not select_path else Model,
            }
        )
        non_200_response_types_map: Dict[str, Any] = {}
        response_types_map.update(non_200_response_types_map)

        ## peform request
        return await self.api_client.request(
            method="GET",
            resource_path="/registry/v2/runtimes/{name}/versions/{version}/example/{wildcard}",
            path_params=path_params,
            params=query,
            **body_args,
            headers=headers,
            **kwargs,
            response_type=response_types_map,
            select_path=select_path,
            raw_response=raw_response,
        )

    @overload
    async def get_latest(
        self,
        name: Annotated[StrictStr, Field(description="The name of a <em>runtime</em>")],
        *,
        query: GetLatestQuery | QueryParamTypes | None = None,
        raw_response: Literal[False] = False,
        select_path: Literal[""] = "",
        response_type: Literal[None] = None,
        validate_request: StrictBool = True,
        headers: HeaderTypes | None = None,
        **kwargs,
    ) -> RuntimeVersionResponse: ...

    @overload
    async def get_latest(
        self,
        name: Annotated[StrictStr, Field(description="The name of a <em>runtime</em>")],
        *,
        query: GetLatestQuery | QueryParamTypes | None = None,
        raw_response: Literal[False] = False,
        select_path: Literal[""] = "",
        response_type: T,
        validate_request: StrictBool = True,
        headers: HeaderTypes | None = None,
        **kwargs,
    ) -> T: ...

    @overload
    async def get_latest(
        self,
        name: Annotated[StrictStr, Field(description="The name of a <em>runtime</em>")],
        *,
        query: GetLatestQuery | QueryParamTypes | None = None,
        raw_response: Literal[True],
        select_path: Literal["_not_used_"] = "_not_used_",
        response_type: Literal[None] = None,  # not used
        validate_request: StrictBool = True,
        headers: HeaderTypes | None = None,
        **kwargs,
    ) -> Response: ...

    @overload
    async def get_latest(
        self,
        name: Annotated[StrictStr, Field(description="The name of a <em>runtime</em>")],
        *,
        query: GetLatestQuery | QueryParamTypes | None = None,
        raw_response: Literal[False] = False,
        select_path: str,
        response_type: Literal[None] = None,
        validate_request: StrictBool = True,
        headers: HeaderTypes | None = None,
        **kwargs,
    ) -> Model: ...

    @overload
    async def get_latest(
        self,
        name: Annotated[StrictStr, Field(description="The name of a <em>runtime</em>")],
        *,
        query: GetLatestQuery | QueryParamTypes | None = None,
        raw_response: Literal[False] = False,
        select_path: str,
        response_type: T,
        validate_request: StrictBool = True,
        headers: HeaderTypes | None = None,
        **kwargs,
    ) -> T: ...

    async def get_latest(
        self,
        name: Annotated[StrictStr, Field(description="The name of a <em>runtime</em>")],
        *,
        query: GetLatestQuery | QueryParamTypes | None = None,
        raw_response: StrictBool = False,
        select_path: str = "",
        response_type: T | None = None,
        validate_request: StrictBool = True,
        headers: HeaderTypes | None = None,
        **kwargs,
    ) -> RuntimeVersionResponse | T | Response | Model:
        """Get Latest Runtime Version.

        Get a representation of the default runtime version by name.
        :param name: The name of a <em>runtime</em> (required)
        :type name: str
        :param query: URL Query parameters.
        :type query: GetLatestQuery | QueryParamTypes, optional
        :param query['version'] (dict) <br> query.version (Query) : If set, filters on the <code>version</code> of a runtime. Supports [version ranges](https://devhints.io/semver).
        :type query['version']: SemanticVersionRange
        :param query['includeDeprecated'] (dict) <br> query.include_deprecated (Query) : If set to `true`, deprecated runtimes will be included in the query.
        :type query['includeDeprecated']: bool
        :param query['functionType'] (dict) <br> query.function_type (Query) : If set, filters on the <code>functionType</code> of a runtime. Uses an exact match.
        :type query['functionType']: List[FunctionType]
        :param query['archiveFormat'] (dict) <br> query.archive_format (Query) : If set, filters on the <code>archiveFormat</code> of a runtime. Uses an exact match.
        :type query['archiveFormat']: List[ArchiveFormat]
        :param raw_response: If true, return the http Response object instead of returning an api model object, or throwing an ApiError.
        :param select_path: Denotes the json path applied to the response object before returning it.
                Set it to the empty string `""` to receive the full response object.
        :param response_type: If specified, the response is parsed into an instance of the specified type.
        :param validate_request: If set to false, the request body and query parameters are NOT validated against the models in the service types package, even when available.
        :param headers: Header parameters for this request
        :type headers: dict, optional
        :param `**kwargs`: Additional parameters passed on to the http client.
            See below.
        :Keyword Arguments:
            * timeout: a single numeric timeout in seconds,
                or a tuple of _connect_, _read_, _write_ and _pool_ timeouts.
            * stream: if true, the response will be in streaming mode
            * cookies
            * extensions
            * auth
            * follow_redirects: bool

        :return: Returns the result object if the http request succeeded with status code '2XX'.
        :raises APIError: If the http request has a status code different from `2XX`. This
            object wraps both the http Response and any parsed data.
        """

        # path parameters
        path_params: Dict[str, str] = {
            "name": str(name),
        }

        ## named body parameters
        body_args: Dict[str, Any] = {}

        # query parameters
        if query is not None and MODELS_AVAILABLE and validate_request:
            query = TypeAdapter(GetLatestQuery).validate_python(query)

        response_types_map: Dict[str, Any] = (
            {"2XX": response_type}
            if response_type is not None
            else {
                "200": RuntimeVersionResponse if not select_path else Model,
            }
        )
        non_200_response_types_map: Dict[str, Any] = {}
        response_types_map.update(non_200_response_types_map)

        ## peform request
        return await self.api_client.request(
            method="GET",
            resource_path="/registry/v2/runtimes/{name}",
            path_params=path_params,
            params=query,
            **body_args,
            headers=headers,
            **kwargs,
            response_type=response_types_map,
            select_path=select_path,
            raw_response=raw_response,
        )

    @overload
    async def get(
        self,
        name: Annotated[StrictStr, Field(description="The name of a <em>runtime</em>")],
        version: Annotated[
            Any, Field(description="A version range for a <em>runtime</em>")
        ],
        *,
        query: GetQuery | QueryParamTypes | None = None,
        raw_response: Literal[False] = False,
        select_path: Literal[""] = "",
        response_type: Literal[None] = None,
        validate_request: StrictBool = True,
        headers: HeaderTypes | None = None,
        **kwargs,
    ) -> RuntimeVersionResponse: ...

    @overload
    async def get(
        self,
        name: Annotated[StrictStr, Field(description="The name of a <em>runtime</em>")],
        version: Annotated[
            Any, Field(description="A version range for a <em>runtime</em>")
        ],
        *,
        query: GetQuery | QueryParamTypes | None = None,
        raw_response: Literal[False] = False,
        select_path: Literal[""] = "",
        response_type: T,
        validate_request: StrictBool = True,
        headers: HeaderTypes | None = None,
        **kwargs,
    ) -> T: ...

    @overload
    async def get(
        self,
        name: Annotated[StrictStr, Field(description="The name of a <em>runtime</em>")],
        version: Annotated[
            Any, Field(description="A version range for a <em>runtime</em>")
        ],
        *,
        query: GetQuery | QueryParamTypes | None = None,
        raw_response: Literal[True],
        select_path: Literal["_not_used_"] = "_not_used_",
        response_type: Literal[None] = None,  # not used
        validate_request: StrictBool = True,
        headers: HeaderTypes | None = None,
        **kwargs,
    ) -> Response: ...

    @overload
    async def get(
        self,
        name: Annotated[StrictStr, Field(description="The name of a <em>runtime</em>")],
        version: Annotated[
            Any, Field(description="A version range for a <em>runtime</em>")
        ],
        *,
        query: GetQuery | QueryParamTypes | None = None,
        raw_response: Literal[False] = False,
        select_path: str,
        response_type: Literal[None] = None,
        validate_request: StrictBool = True,
        headers: HeaderTypes | None = None,
        **kwargs,
    ) -> Model: ...

    @overload
    async def get(
        self,
        name: Annotated[StrictStr, Field(description="The name of a <em>runtime</em>")],
        version: Annotated[
            Any, Field(description="A version range for a <em>runtime</em>")
        ],
        *,
        query: GetQuery | QueryParamTypes | None = None,
        raw_response: Literal[False] = False,
        select_path: str,
        response_type: T,
        validate_request: StrictBool = True,
        headers: HeaderTypes | None = None,
        **kwargs,
    ) -> T: ...

    async def get(
        self,
        name: Annotated[StrictStr, Field(description="The name of a <em>runtime</em>")],
        version: Annotated[
            Any, Field(description="A version range for a <em>runtime</em>")
        ],
        *,
        query: GetQuery | QueryParamTypes | None = None,
        raw_response: StrictBool = False,
        select_path: str = "",
        response_type: T | None = None,
        validate_request: StrictBool = True,
        headers: HeaderTypes | None = None,
        **kwargs,
    ) -> RuntimeVersionResponse | T | Response | Model:
        """Get Runtime Version.

        Get a representation of the default runtime version by name.
        :param name: The name of a <em>runtime</em> (required)
        :type name: str
        :param version: A version range for a <em>runtime</em> (required)
        :type version: SemanticVersionRange
        :param query: URL Query parameters.
        :type query: GetQuery | QueryParamTypes, optional
        :param query['includeDeprecated'] (dict) <br> query.include_deprecated (Query) : If set to `true`, deprecated runtimes will be included in the query.
        :type query['includeDeprecated']: bool
        :param raw_response: If true, return the http Response object instead of returning an api model object, or throwing an ApiError.
        :param select_path: Denotes the json path applied to the response object before returning it.
                Set it to the empty string `""` to receive the full response object.
        :param response_type: If specified, the response is parsed into an instance of the specified type.
        :param validate_request: If set to false, the request body and query parameters are NOT validated against the models in the service types package, even when available.
        :param headers: Header parameters for this request
        :type headers: dict, optional
        :param `**kwargs`: Additional parameters passed on to the http client.
            See below.
        :Keyword Arguments:
            * timeout: a single numeric timeout in seconds,
                or a tuple of _connect_, _read_, _write_ and _pool_ timeouts.
            * stream: if true, the response will be in streaming mode
            * cookies
            * extensions
            * auth
            * follow_redirects: bool

        :return: Returns the result object if the http request succeeded with status code '2XX'.
        :raises APIError: If the http request has a status code different from `2XX`. This
            object wraps both the http Response and any parsed data.
        """

        # path parameters
        path_params: Dict[str, str] = {
            "name": str(name),
            "version": str(version),
        }

        ## named body parameters
        body_args: Dict[str, Any] = {}

        # query parameters
        if query is not None and MODELS_AVAILABLE and validate_request:
            query = TypeAdapter(GetQuery).validate_python(query)

        response_types_map: Dict[str, Any] = (
            {"2XX": response_type}
            if response_type is not None
            else {
                "200": RuntimeVersionResponse if not select_path else Model,
            }
        )
        non_200_response_types_map: Dict[str, Any] = {}
        response_types_map.update(non_200_response_types_map)

        ## peform request
        return await self.api_client.request(
            method="GET",
            resource_path="/registry/v2/runtimes/{name}/versions/{version}",
            path_params=path_params,
            params=query,
            **body_args,
            headers=headers,
            **kwargs,
            response_type=response_types_map,
            select_path=select_path,
            raw_response=raw_response,
        )

    @overload
    async def list(
        self,
        *,
        query: ListQuery | QueryParamTypes | None = None,
        raw_response: Literal[False] = False,
        select_path: Literal[""] = "",
        response_type: Literal[None] = None,
        validate_request: StrictBool = True,
        headers: HeaderTypes | None = None,
        **kwargs,
    ) -> RuntimeSummaryResponse: ...

    @overload
    async def list(
        self,
        *,
        query: ListQuery | QueryParamTypes | None = None,
        raw_response: Literal[False] = False,
        select_path: Literal[""] = "",
        response_type: T,
        validate_request: StrictBool = True,
        headers: HeaderTypes | None = None,
        **kwargs,
    ) -> T: ...

    @overload
    async def list(
        self,
        *,
        query: ListQuery | QueryParamTypes | None = None,
        raw_response: Literal[True],
        select_path: Literal["_not_used_"] = "_not_used_",
        response_type: Literal[None] = None,  # not used
        validate_request: StrictBool = True,
        headers: HeaderTypes | None = None,
        **kwargs,
    ) -> Response: ...

    @overload
    async def list(
        self,
        *,
        query: ListQuery | QueryParamTypes | None = None,
        raw_response: Literal[False] = False,
        select_path: str,
        response_type: Literal[None] = None,
        validate_request: StrictBool = True,
        headers: HeaderTypes | None = None,
        **kwargs,
    ) -> Model: ...

    @overload
    async def list(
        self,
        *,
        query: ListQuery | QueryParamTypes | None = None,
        raw_response: Literal[False] = False,
        select_path: str,
        response_type: T,
        validate_request: StrictBool = True,
        headers: HeaderTypes | None = None,
        **kwargs,
    ) -> T: ...

    async def list(
        self,
        *,
        query: ListQuery | QueryParamTypes | None = None,
        raw_response: StrictBool = False,
        select_path: str = "",
        response_type: T | None = None,
        validate_request: StrictBool = True,
        headers: HeaderTypes | None = None,
        **kwargs,
    ) -> RuntimeSummaryResponse | T | Response | Model:
        """List Runtimes.

        List the runtimes that function registry supports.
        :param query: URL Query parameters.
        :type query: ListQuery | QueryParamTypes, optional
        :param query['version'] (dict) <br> query.version (Query) : If set, filters on the <code>version</code> of a runtime. Supports [version ranges](https://devhints.io/semver).
        :type query['version']: SemanticVersionRange
        :param query['latest'] (dict) <br> query.latest (Query) : If set, filters on the level of latest versions that will be included in the query. * `major`: include at most one latest version per name and major release. * `minor`: include at most one latest version per name and minor release. * `patch`: include each matching patch version. * `true`: include the latest matching version. * `false`: include any matching version (same as `patch`).  This filter is applied after all other selection criteria.
        :type query['latest']: LatestVersionLevel
        :param query['includeDeprecated'] (dict) <br> query.include_deprecated (Query) : If set to `true`, deprecated runtimes will be included in the query.
        :type query['includeDeprecated']: bool
        :param query['name'] (dict) <br> query.name (Query) : If set, filters on the <code>name</code> of a runtime. Supports <code>*</code> and <code>?</code> wildcards and is case-insensitive.
        :type query['name']: str
        :param query['functionType'] (dict) <br> query.function_type (Query) : If set, filters on the <code>functionType</code> of a runtime. Uses an exact match.
        :type query['functionType']: List[FunctionType]
        :param query['archiveFormat'] (dict) <br> query.archive_format (Query) : If set, filters on the <code>archiveFormat</code> of a runtime. Uses an exact match.
        :type query['archiveFormat']: List[ArchiveFormat]
        :param raw_response: If true, return the http Response object instead of returning an api model object, or throwing an ApiError.
        :param select_path: Denotes the json path applied to the response object before returning it.
                Set it to the empty string `""` to receive the full response object.
        :param response_type: If specified, the response is parsed into an instance of the specified type.
        :param validate_request: If set to false, the request body and query parameters are NOT validated against the models in the service types package, even when available.
        :param headers: Header parameters for this request
        :type headers: dict, optional
        :param `**kwargs`: Additional parameters passed on to the http client.
            See below.
        :Keyword Arguments:
            * timeout: a single numeric timeout in seconds,
                or a tuple of _connect_, _read_, _write_ and _pool_ timeouts.
            * stream: if true, the response will be in streaming mode
            * cookies
            * extensions
            * auth
            * follow_redirects: bool

        :return: Returns the result object if the http request succeeded with status code '2XX'.
        :raises APIError: If the http request has a status code different from `2XX`. This
            object wraps both the http Response and any parsed data.
        """

        # path parameters
        path_params: Dict[str, str] = {}

        ## named body parameters
        body_args: Dict[str, Any] = {}

        # query parameters
        if query is not None and MODELS_AVAILABLE and validate_request:
            query = TypeAdapter(ListQuery).validate_python(query)

        response_types_map: Dict[str, Any] = (
            {"2XX": response_type}
            if response_type is not None
            else {
                "200": RuntimeSummaryResponse if not select_path else Model,
            }
        )
        non_200_response_types_map: Dict[str, Any] = {}
        response_types_map.update(non_200_response_types_map)

        ## peform request
        return await self.api_client.request(
            method="GET",
            resource_path="/registry/v2/runtimes/",
            path_params=path_params,
            params=query,
            **body_args,
            headers=headers,
            **kwargs,
            response_type=response_types_map,
            select_path=select_path,
            raw_response=raw_response,
        )

    @overload
    async def list_versions(
        self,
        name: Annotated[StrictStr, Field(description="The name of a <em>runtime</em>")],
        *,
        query: ListVersionsQuery | QueryParamTypes | None = None,
        raw_response: Literal[False] = False,
        select_path: Literal[""] = "",
        response_type: Literal[None] = None,
        validate_request: StrictBool = True,
        headers: HeaderTypes | None = None,
        **kwargs,
    ) -> RuntimeSummaryResponse: ...

    @overload
    async def list_versions(
        self,
        name: Annotated[StrictStr, Field(description="The name of a <em>runtime</em>")],
        *,
        query: ListVersionsQuery | QueryParamTypes | None = None,
        raw_response: Literal[False] = False,
        select_path: Literal[""] = "",
        response_type: T,
        validate_request: StrictBool = True,
        headers: HeaderTypes | None = None,
        **kwargs,
    ) -> T: ...

    @overload
    async def list_versions(
        self,
        name: Annotated[StrictStr, Field(description="The name of a <em>runtime</em>")],
        *,
        query: ListVersionsQuery | QueryParamTypes | None = None,
        raw_response: Literal[True],
        select_path: Literal["_not_used_"] = "_not_used_",
        response_type: Literal[None] = None,  # not used
        validate_request: StrictBool = True,
        headers: HeaderTypes | None = None,
        **kwargs,
    ) -> Response: ...

    @overload
    async def list_versions(
        self,
        name: Annotated[StrictStr, Field(description="The name of a <em>runtime</em>")],
        *,
        query: ListVersionsQuery | QueryParamTypes | None = None,
        raw_response: Literal[False] = False,
        select_path: str,
        response_type: Literal[None] = None,
        validate_request: StrictBool = True,
        headers: HeaderTypes | None = None,
        **kwargs,
    ) -> Model: ...

    @overload
    async def list_versions(
        self,
        name: Annotated[StrictStr, Field(description="The name of a <em>runtime</em>")],
        *,
        query: ListVersionsQuery | QueryParamTypes | None = None,
        raw_response: Literal[False] = False,
        select_path: str,
        response_type: T,
        validate_request: StrictBool = True,
        headers: HeaderTypes | None = None,
        **kwargs,
    ) -> T: ...

    async def list_versions(
        self,
        name: Annotated[StrictStr, Field(description="The name of a <em>runtime</em>")],
        *,
        query: ListVersionsQuery | QueryParamTypes | None = None,
        raw_response: StrictBool = False,
        select_path: str = "",
        response_type: T | None = None,
        validate_request: StrictBool = True,
        headers: HeaderTypes | None = None,
        **kwargs,
    ) -> RuntimeSummaryResponse | T | Response | Model:
        """List Runtime Versions.

        List the supported versions of a specific runtime.
        :param name: The name of a <em>runtime</em> (required)
        :type name: str
        :param query: URL Query parameters.
        :type query: ListVersionsQuery | QueryParamTypes, optional
        :param query['version'] (dict) <br> query.version (Query) : If set, filters on the <code>version</code> of a runtime. Supports [version ranges](https://devhints.io/semver).
        :type query['version']: SemanticVersionRange
        :param query['latest'] (dict) <br> query.latest (Query) : If set, filters on the level of latest versions that will be included in the query. * `major`: include at most one latest version per name and major release. * `minor`: include at most one latest version per name and minor release. * `patch`: include each matching patch version. * `true`: include the latest matching version. * `false`: include any matching version (same as `patch`).  This filter is applied after all other selection criteria.
        :type query['latest']: LatestVersionLevel
        :param query['includeDeprecated'] (dict) <br> query.include_deprecated (Query) : If set to `true`, deprecated runtimes will be included in the query.
        :type query['includeDeprecated']: bool
        :param query['functionType'] (dict) <br> query.function_type (Query) : If set, filters on the <code>functionType</code> of a runtime. Uses an exact match.
        :type query['functionType']: List[FunctionType]
        :param query['archiveFormat'] (dict) <br> query.archive_format (Query) : If set, filters on the <code>archiveFormat</code> of a runtime. Uses an exact match.
        :type query['archiveFormat']: List[ArchiveFormat]
        :param raw_response: If true, return the http Response object instead of returning an api model object, or throwing an ApiError.
        :param select_path: Denotes the json path applied to the response object before returning it.
                Set it to the empty string `""` to receive the full response object.
        :param response_type: If specified, the response is parsed into an instance of the specified type.
        :param validate_request: If set to false, the request body and query parameters are NOT validated against the models in the service types package, even when available.
        :param headers: Header parameters for this request
        :type headers: dict, optional
        :param `**kwargs`: Additional parameters passed on to the http client.
            See below.
        :Keyword Arguments:
            * timeout: a single numeric timeout in seconds,
                or a tuple of _connect_, _read_, _write_ and _pool_ timeouts.
            * stream: if true, the response will be in streaming mode
            * cookies
            * extensions
            * auth
            * follow_redirects: bool

        :return: Returns the result object if the http request succeeded with status code '2XX'.
        :raises APIError: If the http request has a status code different from `2XX`. This
            object wraps both the http Response and any parsed data.
        """

        # path parameters
        path_params: Dict[str, str] = {
            "name": str(name),
        }

        ## named body parameters
        body_args: Dict[str, Any] = {}

        # query parameters
        if query is not None and MODELS_AVAILABLE and validate_request:
            query = TypeAdapter(ListVersionsQuery).validate_python(query)

        response_types_map: Dict[str, Any] = (
            {"2XX": response_type}
            if response_type is not None
            else {
                "200": RuntimeSummaryResponse if not select_path else Model,
            }
        )
        non_200_response_types_map: Dict[str, Any] = {}
        response_types_map.update(non_200_response_types_map)

        ## peform request
        return await self.api_client.request(
            method="GET",
            resource_path="/registry/v2/runtimes/{name}/versions",
            path_params=path_params,
            params=query,
            **body_args,
            headers=headers,
            **kwargs,
            response_type=response_types_map,
            select_path=select_path,
            raw_response=raw_response,
        )
