# coding: utf-8
"""Waylay Function Registry api.

This code was generated from the OpenAPI documentation of 'Waylay Function Registry'

Generated by OpenAPI Generator (https://openapi-generator.tech)

Do not edit the class manually.
"""

from __future__ import annotations  # for Python 3.7â€“3.9

from typing import (
    TYPE_CHECKING,
    Any,
    Dict,
    Literal,
    Optional,
    TypeVar,
    overload,
)

from pydantic import (
    Field,
    StrictBool,
    StrictStr,
    TypeAdapter,
)
from typing_extensions import (
    Annotated,  # >=3.9,
)

from waylay.sdk.api import (
    HeaderTypes,
    QueryParamTypes,
    Response,
)
from waylay.sdk.api._models import Model
from waylay.sdk.plugin import WithApiClient

if TYPE_CHECKING:
    from waylay.services.registry.models import (
        ErrorAndStatusResponse,
        FunctionTagResponse,
        FunctionTagsResponse,
        UpdateTagsRequestV2,
    )
    from waylay.services.registry.queries.webscript_tags_api import (
        AddAllQuery,
        AddQuery,
        ClearAllQuery,
        ClearQuery,
        FindAllQuery,
        FindQuery,
        ListAllQuery,
        ListQuery,
        PutAllQuery,
        PutQuery,
        RemoveAllQuery,
        RemoveQuery,
        ReplaceAllQuery,
        ReplaceQuery,
    )


try:
    from waylay.services.registry.models import (
        ErrorAndStatusResponse,
        FunctionTagResponse,
        FunctionTagsResponse,
        UpdateTagsRequestV2,
    )
    from waylay.services.registry.queries.webscript_tags_api import (
        AddAllQuery,
        AddQuery,
        ClearAllQuery,
        ClearQuery,
        FindAllQuery,
        FindQuery,
        ListAllQuery,
        ListQuery,
        PutAllQuery,
        PutQuery,
        RemoveAllQuery,
        RemoveQuery,
        ReplaceAllQuery,
        ReplaceQuery,
    )

    MODELS_AVAILABLE = True
except ImportError:
    MODELS_AVAILABLE = False

    if not TYPE_CHECKING:
        UpdateTagsRequestV2 = Model

        AddAllQuery = dict
        FunctionTagsResponse = Model

        UpdateTagsRequestV2 = Model

        AddQuery = dict
        FunctionTagsResponse = Model

        ClearAllQuery = dict
        FunctionTagsResponse = Model

        ClearQuery = dict
        FunctionTagsResponse = Model

        FindAllQuery = dict
        FunctionTagResponse = Model

        ErrorAndStatusResponse = Model

        FindQuery = dict
        FunctionTagResponse = Model

        ErrorAndStatusResponse = Model

        ListAllQuery = dict
        FunctionTagsResponse = Model

        ListQuery = dict
        FunctionTagsResponse = Model

        PutAllQuery = dict
        FunctionTagResponse = Model

        PutQuery = dict
        FunctionTagResponse = Model

        RemoveAllQuery = dict
        FunctionTagResponse = Model

        ErrorAndStatusResponse = Model

        RemoveQuery = dict
        FunctionTagResponse = Model

        ErrorAndStatusResponse = Model

        UpdateTagsRequestV2 = Model

        ReplaceAllQuery = dict
        FunctionTagsResponse = Model

        UpdateTagsRequestV2 = Model

        ReplaceQuery = dict
        FunctionTagsResponse = Model


T = TypeVar("T")


class WebscriptTagsApi(WithApiClient):
    """WebscriptTagsApi service methods.

    NOTE: This class is auto generated by OpenAPI Generator
    Ref: https://openapi-generator.tech

    Do not edit the class manually.
    """

    @overload
    async def add_all(
        self,
        name: Annotated[StrictStr, Field(description="The name of the function.")],
        *,
        json: UpdateTagsRequestV2 | None = None,
        query: AddAllQuery | QueryParamTypes | None = None,
        raw_response: Literal[False] = False,
        select_path: Literal[""] = "",
        response_type: Literal[None] = None,
        validate_request: StrictBool = True,
        headers: HeaderTypes | None = None,
        **kwargs,
    ) -> FunctionTagsResponse: ...

    @overload
    async def add_all(
        self,
        name: Annotated[StrictStr, Field(description="The name of the function.")],
        *,
        json: UpdateTagsRequestV2 | None = None,
        query: AddAllQuery | QueryParamTypes | None = None,
        raw_response: Literal[False] = False,
        select_path: Literal[""] = "",
        response_type: T,
        validate_request: StrictBool = True,
        headers: HeaderTypes | None = None,
        **kwargs,
    ) -> T: ...

    @overload
    async def add_all(
        self,
        name: Annotated[StrictStr, Field(description="The name of the function.")],
        *,
        json: UpdateTagsRequestV2 | None = None,
        query: AddAllQuery | QueryParamTypes | None = None,
        raw_response: Literal[True],
        select_path: Literal["_not_used_"] = "_not_used_",
        response_type: Literal[None] = None,  # not used
        validate_request: StrictBool = True,
        headers: HeaderTypes | None = None,
        **kwargs,
    ) -> Response: ...

    @overload
    async def add_all(
        self,
        name: Annotated[StrictStr, Field(description="The name of the function.")],
        *,
        json: UpdateTagsRequestV2 | None = None,
        query: AddAllQuery | QueryParamTypes | None = None,
        raw_response: Literal[False] = False,
        select_path: str,
        response_type: Literal[None] = None,
        validate_request: StrictBool = True,
        headers: HeaderTypes | None = None,
        **kwargs,
    ) -> Model: ...

    @overload
    async def add_all(
        self,
        name: Annotated[StrictStr, Field(description="The name of the function.")],
        *,
        json: UpdateTagsRequestV2 | None = None,
        query: AddAllQuery | QueryParamTypes | None = None,
        raw_response: Literal[False] = False,
        select_path: str,
        response_type: T,
        validate_request: StrictBool = True,
        headers: HeaderTypes | None = None,
        **kwargs,
    ) -> T: ...

    async def add_all(
        self,
        name: Annotated[StrictStr, Field(description="The name of the function.")],
        *,
        json: UpdateTagsRequestV2 | None = None,
        query: AddAllQuery | QueryParamTypes | None = None,
        raw_response: StrictBool = False,
        select_path: str = "",
        response_type: T | None = None,
        validate_request: StrictBool = True,
        headers: HeaderTypes | None = None,
        **kwargs,
    ) -> FunctionTagsResponse | T | Response | Model:
        """Add Tags On All.

        Add tags to all versions of a named webscript version.
        :param name: The name of the function. (required)
        :type name: str
        :param json: The json request body.
        :type json: UpdateTagsRequestV2, optional
        :param query: URL Query parameters.
        :type query: AddAllQuery | QueryParamTypes, optional
        :param raw_response: If true, return the http Response object instead of returning an api model object, or throwing an ApiError.
        :param select_path: Denotes the json path applied to the response object before returning it.
                Set it to the empty string `""` to receive the full response object.
        :param response_type: If specified, the response is parsed into an instance of the specified type.
        :param validate_request: If set to false, the request body and query parameters are NOT validated against the models in the service types package, even when available.
        :param headers: Header parameters for this request
        :type headers: dict, optional
        :param `**kwargs`: Additional parameters passed on to the http client.
            See below.
        :Keyword Arguments:
            * timeout: a single numeric timeout in seconds,
                or a tuple of _connect_, _read_, _write_ and _pool_ timeouts.
            * stream: if true, the response will be in streaming mode
            * cookies
            * extensions
            * auth
            * follow_redirects: bool

        :return: Returns the result object if the http request succeeded with status code '2XX'.
        :raises APIError: If the http request has a status code different from `2XX`. This
            object wraps both the http Response and any parsed data.
        """

        # path parameters
        path_params: Dict[str, str] = {
            "name": str(name),
        }

        ## named body parameters
        body_args: Dict[str, Any] = {}
        if json is not None and validate_request:
            body_adapter: Any = TypeAdapter(Optional[UpdateTagsRequestV2])
            json = body_adapter.validate_python(json)  # type: ignore # https://github.com/pydantic/pydantic/discussions/7094
        body_args["json"] = json

        # query parameters
        if query is not None and MODELS_AVAILABLE and validate_request:
            query = TypeAdapter(AddAllQuery).validate_python(query)

        response_types_map: Dict[str, Any] = (
            {"2XX": response_type}
            if response_type is not None
            else {
                "200": FunctionTagsResponse if not select_path else Model,
            }
        )
        non_200_response_types_map: Dict[str, Any] = {}
        response_types_map.update(non_200_response_types_map)

        ## peform request
        return await self.api_client.request(
            method="PATCH",
            resource_path="/registry/v2/webscripts/{name}/tags",
            path_params=path_params,
            params=query,
            **body_args,
            headers=headers,
            **kwargs,
            response_type=response_types_map,
            select_path=select_path,
            raw_response=raw_response,
        )

    @overload
    async def add(
        self,
        name: Annotated[StrictStr, Field(description="The name of the function.")],
        version: Annotated[
            str, Field(strict=True, description="The version of the function.")
        ],
        *,
        json: UpdateTagsRequestV2 | None = None,
        query: AddQuery | QueryParamTypes | None = None,
        raw_response: Literal[False] = False,
        select_path: Literal[""] = "",
        response_type: Literal[None] = None,
        validate_request: StrictBool = True,
        headers: HeaderTypes | None = None,
        **kwargs,
    ) -> FunctionTagsResponse: ...

    @overload
    async def add(
        self,
        name: Annotated[StrictStr, Field(description="The name of the function.")],
        version: Annotated[
            str, Field(strict=True, description="The version of the function.")
        ],
        *,
        json: UpdateTagsRequestV2 | None = None,
        query: AddQuery | QueryParamTypes | None = None,
        raw_response: Literal[False] = False,
        select_path: Literal[""] = "",
        response_type: T,
        validate_request: StrictBool = True,
        headers: HeaderTypes | None = None,
        **kwargs,
    ) -> T: ...

    @overload
    async def add(
        self,
        name: Annotated[StrictStr, Field(description="The name of the function.")],
        version: Annotated[
            str, Field(strict=True, description="The version of the function.")
        ],
        *,
        json: UpdateTagsRequestV2 | None = None,
        query: AddQuery | QueryParamTypes | None = None,
        raw_response: Literal[True],
        select_path: Literal["_not_used_"] = "_not_used_",
        response_type: Literal[None] = None,  # not used
        validate_request: StrictBool = True,
        headers: HeaderTypes | None = None,
        **kwargs,
    ) -> Response: ...

    @overload
    async def add(
        self,
        name: Annotated[StrictStr, Field(description="The name of the function.")],
        version: Annotated[
            str, Field(strict=True, description="The version of the function.")
        ],
        *,
        json: UpdateTagsRequestV2 | None = None,
        query: AddQuery | QueryParamTypes | None = None,
        raw_response: Literal[False] = False,
        select_path: str,
        response_type: Literal[None] = None,
        validate_request: StrictBool = True,
        headers: HeaderTypes | None = None,
        **kwargs,
    ) -> Model: ...

    @overload
    async def add(
        self,
        name: Annotated[StrictStr, Field(description="The name of the function.")],
        version: Annotated[
            str, Field(strict=True, description="The version of the function.")
        ],
        *,
        json: UpdateTagsRequestV2 | None = None,
        query: AddQuery | QueryParamTypes | None = None,
        raw_response: Literal[False] = False,
        select_path: str,
        response_type: T,
        validate_request: StrictBool = True,
        headers: HeaderTypes | None = None,
        **kwargs,
    ) -> T: ...

    async def add(
        self,
        name: Annotated[StrictStr, Field(description="The name of the function.")],
        version: Annotated[
            str, Field(strict=True, description="The version of the function.")
        ],
        *,
        json: UpdateTagsRequestV2 | None = None,
        query: AddQuery | QueryParamTypes | None = None,
        raw_response: StrictBool = False,
        select_path: str = "",
        response_type: T | None = None,
        validate_request: StrictBool = True,
        headers: HeaderTypes | None = None,
        **kwargs,
    ) -> FunctionTagsResponse | T | Response | Model:
        """Add Tags.

        Add tags used on a webscript version.
        :param name: The name of the function. (required)
        :type name: str
        :param version: The version of the function. (required)
        :type version: str
        :param json: The json request body.
        :type json: UpdateTagsRequestV2, optional
        :param query: URL Query parameters.
        :type query: AddQuery | QueryParamTypes, optional
        :param raw_response: If true, return the http Response object instead of returning an api model object, or throwing an ApiError.
        :param select_path: Denotes the json path applied to the response object before returning it.
                Set it to the empty string `""` to receive the full response object.
        :param response_type: If specified, the response is parsed into an instance of the specified type.
        :param validate_request: If set to false, the request body and query parameters are NOT validated against the models in the service types package, even when available.
        :param headers: Header parameters for this request
        :type headers: dict, optional
        :param `**kwargs`: Additional parameters passed on to the http client.
            See below.
        :Keyword Arguments:
            * timeout: a single numeric timeout in seconds,
                or a tuple of _connect_, _read_, _write_ and _pool_ timeouts.
            * stream: if true, the response will be in streaming mode
            * cookies
            * extensions
            * auth
            * follow_redirects: bool

        :return: Returns the result object if the http request succeeded with status code '2XX'.
        :raises APIError: If the http request has a status code different from `2XX`. This
            object wraps both the http Response and any parsed data.
        """

        # path parameters
        path_params: Dict[str, str] = {
            "name": str(name),
            "version": str(version),
        }

        ## named body parameters
        body_args: Dict[str, Any] = {}
        if json is not None and validate_request:
            body_adapter: Any = TypeAdapter(Optional[UpdateTagsRequestV2])
            json = body_adapter.validate_python(json)  # type: ignore # https://github.com/pydantic/pydantic/discussions/7094
        body_args["json"] = json

        # query parameters
        if query is not None and MODELS_AVAILABLE and validate_request:
            query = TypeAdapter(AddQuery).validate_python(query)

        response_types_map: Dict[str, Any] = (
            {"2XX": response_type}
            if response_type is not None
            else {
                "200": FunctionTagsResponse if not select_path else Model,
            }
        )
        non_200_response_types_map: Dict[str, Any] = {}
        response_types_map.update(non_200_response_types_map)

        ## peform request
        return await self.api_client.request(
            method="PATCH",
            resource_path="/registry/v2/webscripts/{name}/versions/{version}/tags",
            path_params=path_params,
            params=query,
            **body_args,
            headers=headers,
            **kwargs,
            response_type=response_types_map,
            select_path=select_path,
            raw_response=raw_response,
        )

    @overload
    async def clear_all(
        self,
        name: Annotated[StrictStr, Field(description="The name of the function.")],
        *,
        query: ClearAllQuery | QueryParamTypes | None = None,
        raw_response: Literal[False] = False,
        select_path: Literal[""] = "",
        response_type: Literal[None] = None,
        validate_request: StrictBool = True,
        headers: HeaderTypes | None = None,
        **kwargs,
    ) -> FunctionTagsResponse: ...

    @overload
    async def clear_all(
        self,
        name: Annotated[StrictStr, Field(description="The name of the function.")],
        *,
        query: ClearAllQuery | QueryParamTypes | None = None,
        raw_response: Literal[False] = False,
        select_path: Literal[""] = "",
        response_type: T,
        validate_request: StrictBool = True,
        headers: HeaderTypes | None = None,
        **kwargs,
    ) -> T: ...

    @overload
    async def clear_all(
        self,
        name: Annotated[StrictStr, Field(description="The name of the function.")],
        *,
        query: ClearAllQuery | QueryParamTypes | None = None,
        raw_response: Literal[True],
        select_path: Literal["_not_used_"] = "_not_used_",
        response_type: Literal[None] = None,  # not used
        validate_request: StrictBool = True,
        headers: HeaderTypes | None = None,
        **kwargs,
    ) -> Response: ...

    @overload
    async def clear_all(
        self,
        name: Annotated[StrictStr, Field(description="The name of the function.")],
        *,
        query: ClearAllQuery | QueryParamTypes | None = None,
        raw_response: Literal[False] = False,
        select_path: str,
        response_type: Literal[None] = None,
        validate_request: StrictBool = True,
        headers: HeaderTypes | None = None,
        **kwargs,
    ) -> Model: ...

    @overload
    async def clear_all(
        self,
        name: Annotated[StrictStr, Field(description="The name of the function.")],
        *,
        query: ClearAllQuery | QueryParamTypes | None = None,
        raw_response: Literal[False] = False,
        select_path: str,
        response_type: T,
        validate_request: StrictBool = True,
        headers: HeaderTypes | None = None,
        **kwargs,
    ) -> T: ...

    async def clear_all(
        self,
        name: Annotated[StrictStr, Field(description="The name of the function.")],
        *,
        query: ClearAllQuery | QueryParamTypes | None = None,
        raw_response: StrictBool = False,
        select_path: str = "",
        response_type: T | None = None,
        validate_request: StrictBool = True,
        headers: HeaderTypes | None = None,
        **kwargs,
    ) -> FunctionTagsResponse | T | Response | Model:
        """Clear Tags On Any/All.

        Remove all tags used on any or all versions of a named webscript.         With 'from=all', a tag is only removed when it was set to all versions.
        :param name: The name of the function. (required)
        :type name: str
        :param query: URL Query parameters.
        :type query: ClearAllQuery | QueryParamTypes, optional
        :param query['scope'] (dict) <br> query.scope (Query) : Tagging operations on a _named_ function can either operate on - `any` versions: operate on tags that are are associated on _any_ version (union) - `all` versions: operate on tags that are are associated with _all_ versions (intersection)
        :type query['scope']: TaggingScopeOption
        :param raw_response: If true, return the http Response object instead of returning an api model object, or throwing an ApiError.
        :param select_path: Denotes the json path applied to the response object before returning it.
                Set it to the empty string `""` to receive the full response object.
        :param response_type: If specified, the response is parsed into an instance of the specified type.
        :param validate_request: If set to false, the request body and query parameters are NOT validated against the models in the service types package, even when available.
        :param headers: Header parameters for this request
        :type headers: dict, optional
        :param `**kwargs`: Additional parameters passed on to the http client.
            See below.
        :Keyword Arguments:
            * timeout: a single numeric timeout in seconds,
                or a tuple of _connect_, _read_, _write_ and _pool_ timeouts.
            * stream: if true, the response will be in streaming mode
            * cookies
            * extensions
            * auth
            * follow_redirects: bool

        :return: Returns the result object if the http request succeeded with status code '2XX'.
        :raises APIError: If the http request has a status code different from `2XX`. This
            object wraps both the http Response and any parsed data.
        """

        # path parameters
        path_params: Dict[str, str] = {
            "name": str(name),
        }

        ## named body parameters
        body_args: Dict[str, Any] = {}

        # query parameters
        if query is not None and MODELS_AVAILABLE and validate_request:
            query = TypeAdapter(ClearAllQuery).validate_python(query)

        response_types_map: Dict[str, Any] = (
            {"2XX": response_type}
            if response_type is not None
            else {
                "200": FunctionTagsResponse if not select_path else Model,
            }
        )
        non_200_response_types_map: Dict[str, Any] = {}
        response_types_map.update(non_200_response_types_map)

        ## peform request
        return await self.api_client.request(
            method="DELETE",
            resource_path="/registry/v2/webscripts/{name}/tags",
            path_params=path_params,
            params=query,
            **body_args,
            headers=headers,
            **kwargs,
            response_type=response_types_map,
            select_path=select_path,
            raw_response=raw_response,
        )

    @overload
    async def clear(
        self,
        name: Annotated[StrictStr, Field(description="The name of the function.")],
        version: Annotated[
            str, Field(strict=True, description="The version of the function.")
        ],
        *,
        query: ClearQuery | QueryParamTypes | None = None,
        raw_response: Literal[False] = False,
        select_path: Literal[""] = "",
        response_type: Literal[None] = None,
        validate_request: StrictBool = True,
        headers: HeaderTypes | None = None,
        **kwargs,
    ) -> FunctionTagsResponse: ...

    @overload
    async def clear(
        self,
        name: Annotated[StrictStr, Field(description="The name of the function.")],
        version: Annotated[
            str, Field(strict=True, description="The version of the function.")
        ],
        *,
        query: ClearQuery | QueryParamTypes | None = None,
        raw_response: Literal[False] = False,
        select_path: Literal[""] = "",
        response_type: T,
        validate_request: StrictBool = True,
        headers: HeaderTypes | None = None,
        **kwargs,
    ) -> T: ...

    @overload
    async def clear(
        self,
        name: Annotated[StrictStr, Field(description="The name of the function.")],
        version: Annotated[
            str, Field(strict=True, description="The version of the function.")
        ],
        *,
        query: ClearQuery | QueryParamTypes | None = None,
        raw_response: Literal[True],
        select_path: Literal["_not_used_"] = "_not_used_",
        response_type: Literal[None] = None,  # not used
        validate_request: StrictBool = True,
        headers: HeaderTypes | None = None,
        **kwargs,
    ) -> Response: ...

    @overload
    async def clear(
        self,
        name: Annotated[StrictStr, Field(description="The name of the function.")],
        version: Annotated[
            str, Field(strict=True, description="The version of the function.")
        ],
        *,
        query: ClearQuery | QueryParamTypes | None = None,
        raw_response: Literal[False] = False,
        select_path: str,
        response_type: Literal[None] = None,
        validate_request: StrictBool = True,
        headers: HeaderTypes | None = None,
        **kwargs,
    ) -> Model: ...

    @overload
    async def clear(
        self,
        name: Annotated[StrictStr, Field(description="The name of the function.")],
        version: Annotated[
            str, Field(strict=True, description="The version of the function.")
        ],
        *,
        query: ClearQuery | QueryParamTypes | None = None,
        raw_response: Literal[False] = False,
        select_path: str,
        response_type: T,
        validate_request: StrictBool = True,
        headers: HeaderTypes | None = None,
        **kwargs,
    ) -> T: ...

    async def clear(
        self,
        name: Annotated[StrictStr, Field(description="The name of the function.")],
        version: Annotated[
            str, Field(strict=True, description="The version of the function.")
        ],
        *,
        query: ClearQuery | QueryParamTypes | None = None,
        raw_response: StrictBool = False,
        select_path: str = "",
        response_type: T | None = None,
        validate_request: StrictBool = True,
        headers: HeaderTypes | None = None,
        **kwargs,
    ) -> FunctionTagsResponse | T | Response | Model:
        """Clear Tags.

        Remove all tags used on a webscript version.
        :param name: The name of the function. (required)
        :type name: str
        :param version: The version of the function. (required)
        :type version: str
        :param query: URL Query parameters.
        :type query: ClearQuery | QueryParamTypes, optional
        :param raw_response: If true, return the http Response object instead of returning an api model object, or throwing an ApiError.
        :param select_path: Denotes the json path applied to the response object before returning it.
                Set it to the empty string `""` to receive the full response object.
        :param response_type: If specified, the response is parsed into an instance of the specified type.
        :param validate_request: If set to false, the request body and query parameters are NOT validated against the models in the service types package, even when available.
        :param headers: Header parameters for this request
        :type headers: dict, optional
        :param `**kwargs`: Additional parameters passed on to the http client.
            See below.
        :Keyword Arguments:
            * timeout: a single numeric timeout in seconds,
                or a tuple of _connect_, _read_, _write_ and _pool_ timeouts.
            * stream: if true, the response will be in streaming mode
            * cookies
            * extensions
            * auth
            * follow_redirects: bool

        :return: Returns the result object if the http request succeeded with status code '2XX'.
        :raises APIError: If the http request has a status code different from `2XX`. This
            object wraps both the http Response and any parsed data.
        """

        # path parameters
        path_params: Dict[str, str] = {
            "name": str(name),
            "version": str(version),
        }

        ## named body parameters
        body_args: Dict[str, Any] = {}

        # query parameters
        if query is not None and MODELS_AVAILABLE and validate_request:
            query = TypeAdapter(ClearQuery).validate_python(query)

        response_types_map: Dict[str, Any] = (
            {"2XX": response_type}
            if response_type is not None
            else {
                "200": FunctionTagsResponse if not select_path else Model,
            }
        )
        non_200_response_types_map: Dict[str, Any] = {}
        response_types_map.update(non_200_response_types_map)

        ## peform request
        return await self.api_client.request(
            method="DELETE",
            resource_path="/registry/v2/webscripts/{name}/versions/{version}/tags",
            path_params=path_params,
            params=query,
            **body_args,
            headers=headers,
            **kwargs,
            response_type=response_types_map,
            select_path=select_path,
            raw_response=raw_response,
        )

    @overload
    async def find_all(
        self,
        tag_name: Annotated[
            StrictStr,
            Field(
                description="The name of the tag that might be applied to a function."
            ),
        ],
        name: Annotated[StrictStr, Field(description="The name of the function.")],
        *,
        query: FindAllQuery | QueryParamTypes | None = None,
        raw_response: Literal[False] = False,
        select_path: Literal[""] = "",
        response_type: Literal[None] = None,
        validate_request: StrictBool = True,
        headers: HeaderTypes | None = None,
        **kwargs,
    ) -> FunctionTagResponse: ...

    @overload
    async def find_all(
        self,
        tag_name: Annotated[
            StrictStr,
            Field(
                description="The name of the tag that might be applied to a function."
            ),
        ],
        name: Annotated[StrictStr, Field(description="The name of the function.")],
        *,
        query: FindAllQuery | QueryParamTypes | None = None,
        raw_response: Literal[False] = False,
        select_path: Literal[""] = "",
        response_type: T,
        validate_request: StrictBool = True,
        headers: HeaderTypes | None = None,
        **kwargs,
    ) -> T: ...

    @overload
    async def find_all(
        self,
        tag_name: Annotated[
            StrictStr,
            Field(
                description="The name of the tag that might be applied to a function."
            ),
        ],
        name: Annotated[StrictStr, Field(description="The name of the function.")],
        *,
        query: FindAllQuery | QueryParamTypes | None = None,
        raw_response: Literal[True],
        select_path: Literal["_not_used_"] = "_not_used_",
        response_type: Literal[None] = None,  # not used
        validate_request: StrictBool = True,
        headers: HeaderTypes | None = None,
        **kwargs,
    ) -> Response: ...

    @overload
    async def find_all(
        self,
        tag_name: Annotated[
            StrictStr,
            Field(
                description="The name of the tag that might be applied to a function."
            ),
        ],
        name: Annotated[StrictStr, Field(description="The name of the function.")],
        *,
        query: FindAllQuery | QueryParamTypes | None = None,
        raw_response: Literal[False] = False,
        select_path: str,
        response_type: Literal[None] = None,
        validate_request: StrictBool = True,
        headers: HeaderTypes | None = None,
        **kwargs,
    ) -> Model: ...

    @overload
    async def find_all(
        self,
        tag_name: Annotated[
            StrictStr,
            Field(
                description="The name of the tag that might be applied to a function."
            ),
        ],
        name: Annotated[StrictStr, Field(description="The name of the function.")],
        *,
        query: FindAllQuery | QueryParamTypes | None = None,
        raw_response: Literal[False] = False,
        select_path: str,
        response_type: T,
        validate_request: StrictBool = True,
        headers: HeaderTypes | None = None,
        **kwargs,
    ) -> T: ...

    async def find_all(
        self,
        tag_name: Annotated[
            StrictStr,
            Field(
                description="The name of the tag that might be applied to a function."
            ),
        ],
        name: Annotated[StrictStr, Field(description="The name of the function.")],
        *,
        query: FindAllQuery | QueryParamTypes | None = None,
        raw_response: StrictBool = False,
        select_path: str = "",
        response_type: T | None = None,
        validate_request: StrictBool = True,
        headers: HeaderTypes | None = None,
        **kwargs,
    ) -> FunctionTagResponse | T | Response | Model:
        """Find Tags On Any/All.

        Check the existence of a tag on any or all versions of a named webscript.
        :param tag_name: The name of the tag that might be applied to a function. (required)
        :type tag_name: str
        :param name: The name of the function. (required)
        :type name: str
        :param query: URL Query parameters.
        :type query: FindAllQuery | QueryParamTypes, optional
        :param query['scope'] (dict) <br> query.scope (Query) : Tagging operations on a _named_ function can either operate on - `any` versions: operate on tags that are are associated on _any_ version (union) - `all` versions: operate on tags that are are associated with _all_ versions (intersection)
        :type query['scope']: TaggingScopeOption
        :param raw_response: If true, return the http Response object instead of returning an api model object, or throwing an ApiError.
        :param select_path: Denotes the json path applied to the response object before returning it.
                Set it to the empty string `""` to receive the full response object.
        :param response_type: If specified, the response is parsed into an instance of the specified type.
        :param validate_request: If set to false, the request body and query parameters are NOT validated against the models in the service types package, even when available.
        :param headers: Header parameters for this request
        :type headers: dict, optional
        :param `**kwargs`: Additional parameters passed on to the http client.
            See below.
        :Keyword Arguments:
            * timeout: a single numeric timeout in seconds,
                or a tuple of _connect_, _read_, _write_ and _pool_ timeouts.
            * stream: if true, the response will be in streaming mode
            * cookies
            * extensions
            * auth
            * follow_redirects: bool

        :return: Returns the result object if the http request succeeded with status code '2XX'.
        :raises APIError: If the http request has a status code different from `2XX`. This
            object wraps both the http Response and any parsed data.
        """

        # path parameters
        path_params: Dict[str, str] = {
            "tagName": str(tag_name),
            "name": str(name),
        }

        ## named body parameters
        body_args: Dict[str, Any] = {}

        # query parameters
        if query is not None and MODELS_AVAILABLE and validate_request:
            query = TypeAdapter(FindAllQuery).validate_python(query)

        response_types_map: Dict[str, Any] = (
            {"2XX": response_type}
            if response_type is not None
            else {
                "200": FunctionTagResponse if not select_path else Model,
            }
        )
        non_200_response_types_map: Dict[str, Any] = {
            "404": ErrorAndStatusResponse,
        }
        response_types_map.update(non_200_response_types_map)

        ## peform request
        return await self.api_client.request(
            method="GET",
            resource_path="/registry/v2/webscripts/{name}/tags/{tagName}",
            path_params=path_params,
            params=query,
            **body_args,
            headers=headers,
            **kwargs,
            response_type=response_types_map,
            select_path=select_path,
            raw_response=raw_response,
        )

    @overload
    async def find(
        self,
        tag_name: Annotated[
            StrictStr,
            Field(
                description="The name of the tag that might be applied to a function."
            ),
        ],
        name: Annotated[StrictStr, Field(description="The name of the function.")],
        version: Annotated[
            str, Field(strict=True, description="The version of the function.")
        ],
        *,
        query: FindQuery | QueryParamTypes | None = None,
        raw_response: Literal[False] = False,
        select_path: Literal[""] = "",
        response_type: Literal[None] = None,
        validate_request: StrictBool = True,
        headers: HeaderTypes | None = None,
        **kwargs,
    ) -> FunctionTagResponse: ...

    @overload
    async def find(
        self,
        tag_name: Annotated[
            StrictStr,
            Field(
                description="The name of the tag that might be applied to a function."
            ),
        ],
        name: Annotated[StrictStr, Field(description="The name of the function.")],
        version: Annotated[
            str, Field(strict=True, description="The version of the function.")
        ],
        *,
        query: FindQuery | QueryParamTypes | None = None,
        raw_response: Literal[False] = False,
        select_path: Literal[""] = "",
        response_type: T,
        validate_request: StrictBool = True,
        headers: HeaderTypes | None = None,
        **kwargs,
    ) -> T: ...

    @overload
    async def find(
        self,
        tag_name: Annotated[
            StrictStr,
            Field(
                description="The name of the tag that might be applied to a function."
            ),
        ],
        name: Annotated[StrictStr, Field(description="The name of the function.")],
        version: Annotated[
            str, Field(strict=True, description="The version of the function.")
        ],
        *,
        query: FindQuery | QueryParamTypes | None = None,
        raw_response: Literal[True],
        select_path: Literal["_not_used_"] = "_not_used_",
        response_type: Literal[None] = None,  # not used
        validate_request: StrictBool = True,
        headers: HeaderTypes | None = None,
        **kwargs,
    ) -> Response: ...

    @overload
    async def find(
        self,
        tag_name: Annotated[
            StrictStr,
            Field(
                description="The name of the tag that might be applied to a function."
            ),
        ],
        name: Annotated[StrictStr, Field(description="The name of the function.")],
        version: Annotated[
            str, Field(strict=True, description="The version of the function.")
        ],
        *,
        query: FindQuery | QueryParamTypes | None = None,
        raw_response: Literal[False] = False,
        select_path: str,
        response_type: Literal[None] = None,
        validate_request: StrictBool = True,
        headers: HeaderTypes | None = None,
        **kwargs,
    ) -> Model: ...

    @overload
    async def find(
        self,
        tag_name: Annotated[
            StrictStr,
            Field(
                description="The name of the tag that might be applied to a function."
            ),
        ],
        name: Annotated[StrictStr, Field(description="The name of the function.")],
        version: Annotated[
            str, Field(strict=True, description="The version of the function.")
        ],
        *,
        query: FindQuery | QueryParamTypes | None = None,
        raw_response: Literal[False] = False,
        select_path: str,
        response_type: T,
        validate_request: StrictBool = True,
        headers: HeaderTypes | None = None,
        **kwargs,
    ) -> T: ...

    async def find(
        self,
        tag_name: Annotated[
            StrictStr,
            Field(
                description="The name of the tag that might be applied to a function."
            ),
        ],
        name: Annotated[StrictStr, Field(description="The name of the function.")],
        version: Annotated[
            str, Field(strict=True, description="The version of the function.")
        ],
        *,
        query: FindQuery | QueryParamTypes | None = None,
        raw_response: StrictBool = False,
        select_path: str = "",
        response_type: T | None = None,
        validate_request: StrictBool = True,
        headers: HeaderTypes | None = None,
        **kwargs,
    ) -> FunctionTagResponse | T | Response | Model:
        """Find Tag.

        Check the existence of a tag on a webscript version.
        :param tag_name: The name of the tag that might be applied to a function. (required)
        :type tag_name: str
        :param name: The name of the function. (required)
        :type name: str
        :param version: The version of the function. (required)
        :type version: str
        :param query: URL Query parameters.
        :type query: FindQuery | QueryParamTypes, optional
        :param raw_response: If true, return the http Response object instead of returning an api model object, or throwing an ApiError.
        :param select_path: Denotes the json path applied to the response object before returning it.
                Set it to the empty string `""` to receive the full response object.
        :param response_type: If specified, the response is parsed into an instance of the specified type.
        :param validate_request: If set to false, the request body and query parameters are NOT validated against the models in the service types package, even when available.
        :param headers: Header parameters for this request
        :type headers: dict, optional
        :param `**kwargs`: Additional parameters passed on to the http client.
            See below.
        :Keyword Arguments:
            * timeout: a single numeric timeout in seconds,
                or a tuple of _connect_, _read_, _write_ and _pool_ timeouts.
            * stream: if true, the response will be in streaming mode
            * cookies
            * extensions
            * auth
            * follow_redirects: bool

        :return: Returns the result object if the http request succeeded with status code '2XX'.
        :raises APIError: If the http request has a status code different from `2XX`. This
            object wraps both the http Response and any parsed data.
        """

        # path parameters
        path_params: Dict[str, str] = {
            "tagName": str(tag_name),
            "name": str(name),
            "version": str(version),
        }

        ## named body parameters
        body_args: Dict[str, Any] = {}

        # query parameters
        if query is not None and MODELS_AVAILABLE and validate_request:
            query = TypeAdapter(FindQuery).validate_python(query)

        response_types_map: Dict[str, Any] = (
            {"2XX": response_type}
            if response_type is not None
            else {
                "200": FunctionTagResponse if not select_path else Model,
            }
        )
        non_200_response_types_map: Dict[str, Any] = {
            "404": ErrorAndStatusResponse,
        }
        response_types_map.update(non_200_response_types_map)

        ## peform request
        return await self.api_client.request(
            method="GET",
            resource_path="/registry/v2/webscripts/{name}/versions/{version}/tags/{tagName}",
            path_params=path_params,
            params=query,
            **body_args,
            headers=headers,
            **kwargs,
            response_type=response_types_map,
            select_path=select_path,
            raw_response=raw_response,
        )

    @overload
    async def list_all(
        self,
        name: Annotated[StrictStr, Field(description="The name of the function.")],
        *,
        query: ListAllQuery | QueryParamTypes | None = None,
        raw_response: Literal[False] = False,
        select_path: Literal[""] = "",
        response_type: Literal[None] = None,
        validate_request: StrictBool = True,
        headers: HeaderTypes | None = None,
        **kwargs,
    ) -> FunctionTagsResponse: ...

    @overload
    async def list_all(
        self,
        name: Annotated[StrictStr, Field(description="The name of the function.")],
        *,
        query: ListAllQuery | QueryParamTypes | None = None,
        raw_response: Literal[False] = False,
        select_path: Literal[""] = "",
        response_type: T,
        validate_request: StrictBool = True,
        headers: HeaderTypes | None = None,
        **kwargs,
    ) -> T: ...

    @overload
    async def list_all(
        self,
        name: Annotated[StrictStr, Field(description="The name of the function.")],
        *,
        query: ListAllQuery | QueryParamTypes | None = None,
        raw_response: Literal[True],
        select_path: Literal["_not_used_"] = "_not_used_",
        response_type: Literal[None] = None,  # not used
        validate_request: StrictBool = True,
        headers: HeaderTypes | None = None,
        **kwargs,
    ) -> Response: ...

    @overload
    async def list_all(
        self,
        name: Annotated[StrictStr, Field(description="The name of the function.")],
        *,
        query: ListAllQuery | QueryParamTypes | None = None,
        raw_response: Literal[False] = False,
        select_path: str,
        response_type: Literal[None] = None,
        validate_request: StrictBool = True,
        headers: HeaderTypes | None = None,
        **kwargs,
    ) -> Model: ...

    @overload
    async def list_all(
        self,
        name: Annotated[StrictStr, Field(description="The name of the function.")],
        *,
        query: ListAllQuery | QueryParamTypes | None = None,
        raw_response: Literal[False] = False,
        select_path: str,
        response_type: T,
        validate_request: StrictBool = True,
        headers: HeaderTypes | None = None,
        **kwargs,
    ) -> T: ...

    async def list_all(
        self,
        name: Annotated[StrictStr, Field(description="The name of the function.")],
        *,
        query: ListAllQuery | QueryParamTypes | None = None,
        raw_response: StrictBool = False,
        select_path: str = "",
        response_type: T | None = None,
        validate_request: StrictBool = True,
        headers: HeaderTypes | None = None,
        **kwargs,
    ) -> FunctionTagsResponse | T | Response | Model:
        """List Tags On Any/All.

        List tags used on any or all versions of a named webscript.         With 'from=all', only the tags that are set to all versions are returned.
        :param name: The name of the function. (required)
        :type name: str
        :param query: URL Query parameters.
        :type query: ListAllQuery | QueryParamTypes, optional
        :param query['scope'] (dict) <br> query.scope (Query) : Tagging operations on a _named_ function can either operate on - `any` versions: operate on tags that are are associated on _any_ version (union) - `all` versions: operate on tags that are are associated with _all_ versions (intersection)
        :type query['scope']: TaggingScopeOption
        :param raw_response: If true, return the http Response object instead of returning an api model object, or throwing an ApiError.
        :param select_path: Denotes the json path applied to the response object before returning it.
                Set it to the empty string `""` to receive the full response object.
        :param response_type: If specified, the response is parsed into an instance of the specified type.
        :param validate_request: If set to false, the request body and query parameters are NOT validated against the models in the service types package, even when available.
        :param headers: Header parameters for this request
        :type headers: dict, optional
        :param `**kwargs`: Additional parameters passed on to the http client.
            See below.
        :Keyword Arguments:
            * timeout: a single numeric timeout in seconds,
                or a tuple of _connect_, _read_, _write_ and _pool_ timeouts.
            * stream: if true, the response will be in streaming mode
            * cookies
            * extensions
            * auth
            * follow_redirects: bool

        :return: Returns the result object if the http request succeeded with status code '2XX'.
        :raises APIError: If the http request has a status code different from `2XX`. This
            object wraps both the http Response and any parsed data.
        """

        # path parameters
        path_params: Dict[str, str] = {
            "name": str(name),
        }

        ## named body parameters
        body_args: Dict[str, Any] = {}

        # query parameters
        if query is not None and MODELS_AVAILABLE and validate_request:
            query = TypeAdapter(ListAllQuery).validate_python(query)

        response_types_map: Dict[str, Any] = (
            {"2XX": response_type}
            if response_type is not None
            else {
                "200": FunctionTagsResponse if not select_path else Model,
            }
        )
        non_200_response_types_map: Dict[str, Any] = {}
        response_types_map.update(non_200_response_types_map)

        ## peform request
        return await self.api_client.request(
            method="GET",
            resource_path="/registry/v2/webscripts/{name}/tags",
            path_params=path_params,
            params=query,
            **body_args,
            headers=headers,
            **kwargs,
            response_type=response_types_map,
            select_path=select_path,
            raw_response=raw_response,
        )

    @overload
    async def list(
        self,
        name: Annotated[StrictStr, Field(description="The name of the function.")],
        version: Annotated[
            str, Field(strict=True, description="The version of the function.")
        ],
        *,
        query: ListQuery | QueryParamTypes | None = None,
        raw_response: Literal[False] = False,
        select_path: Literal[""] = "",
        response_type: Literal[None] = None,
        validate_request: StrictBool = True,
        headers: HeaderTypes | None = None,
        **kwargs,
    ) -> FunctionTagsResponse: ...

    @overload
    async def list(
        self,
        name: Annotated[StrictStr, Field(description="The name of the function.")],
        version: Annotated[
            str, Field(strict=True, description="The version of the function.")
        ],
        *,
        query: ListQuery | QueryParamTypes | None = None,
        raw_response: Literal[False] = False,
        select_path: Literal[""] = "",
        response_type: T,
        validate_request: StrictBool = True,
        headers: HeaderTypes | None = None,
        **kwargs,
    ) -> T: ...

    @overload
    async def list(
        self,
        name: Annotated[StrictStr, Field(description="The name of the function.")],
        version: Annotated[
            str, Field(strict=True, description="The version of the function.")
        ],
        *,
        query: ListQuery | QueryParamTypes | None = None,
        raw_response: Literal[True],
        select_path: Literal["_not_used_"] = "_not_used_",
        response_type: Literal[None] = None,  # not used
        validate_request: StrictBool = True,
        headers: HeaderTypes | None = None,
        **kwargs,
    ) -> Response: ...

    @overload
    async def list(
        self,
        name: Annotated[StrictStr, Field(description="The name of the function.")],
        version: Annotated[
            str, Field(strict=True, description="The version of the function.")
        ],
        *,
        query: ListQuery | QueryParamTypes | None = None,
        raw_response: Literal[False] = False,
        select_path: str,
        response_type: Literal[None] = None,
        validate_request: StrictBool = True,
        headers: HeaderTypes | None = None,
        **kwargs,
    ) -> Model: ...

    @overload
    async def list(
        self,
        name: Annotated[StrictStr, Field(description="The name of the function.")],
        version: Annotated[
            str, Field(strict=True, description="The version of the function.")
        ],
        *,
        query: ListQuery | QueryParamTypes | None = None,
        raw_response: Literal[False] = False,
        select_path: str,
        response_type: T,
        validate_request: StrictBool = True,
        headers: HeaderTypes | None = None,
        **kwargs,
    ) -> T: ...

    async def list(
        self,
        name: Annotated[StrictStr, Field(description="The name of the function.")],
        version: Annotated[
            str, Field(strict=True, description="The version of the function.")
        ],
        *,
        query: ListQuery | QueryParamTypes | None = None,
        raw_response: StrictBool = False,
        select_path: str = "",
        response_type: T | None = None,
        validate_request: StrictBool = True,
        headers: HeaderTypes | None = None,
        **kwargs,
    ) -> FunctionTagsResponse | T | Response | Model:
        """List Tags.

        List tags used on a webscript version.
        :param name: The name of the function. (required)
        :type name: str
        :param version: The version of the function. (required)
        :type version: str
        :param query: URL Query parameters.
        :type query: ListQuery | QueryParamTypes, optional
        :param raw_response: If true, return the http Response object instead of returning an api model object, or throwing an ApiError.
        :param select_path: Denotes the json path applied to the response object before returning it.
                Set it to the empty string `""` to receive the full response object.
        :param response_type: If specified, the response is parsed into an instance of the specified type.
        :param validate_request: If set to false, the request body and query parameters are NOT validated against the models in the service types package, even when available.
        :param headers: Header parameters for this request
        :type headers: dict, optional
        :param `**kwargs`: Additional parameters passed on to the http client.
            See below.
        :Keyword Arguments:
            * timeout: a single numeric timeout in seconds,
                or a tuple of _connect_, _read_, _write_ and _pool_ timeouts.
            * stream: if true, the response will be in streaming mode
            * cookies
            * extensions
            * auth
            * follow_redirects: bool

        :return: Returns the result object if the http request succeeded with status code '2XX'.
        :raises APIError: If the http request has a status code different from `2XX`. This
            object wraps both the http Response and any parsed data.
        """

        # path parameters
        path_params: Dict[str, str] = {
            "name": str(name),
            "version": str(version),
        }

        ## named body parameters
        body_args: Dict[str, Any] = {}

        # query parameters
        if query is not None and MODELS_AVAILABLE and validate_request:
            query = TypeAdapter(ListQuery).validate_python(query)

        response_types_map: Dict[str, Any] = (
            {"2XX": response_type}
            if response_type is not None
            else {
                "200": FunctionTagsResponse if not select_path else Model,
            }
        )
        non_200_response_types_map: Dict[str, Any] = {}
        response_types_map.update(non_200_response_types_map)

        ## peform request
        return await self.api_client.request(
            method="GET",
            resource_path="/registry/v2/webscripts/{name}/versions/{version}/tags",
            path_params=path_params,
            params=query,
            **body_args,
            headers=headers,
            **kwargs,
            response_type=response_types_map,
            select_path=select_path,
            raw_response=raw_response,
        )

    @overload
    async def put_all(
        self,
        tag_name: Annotated[
            StrictStr,
            Field(
                description="The name of the tag that might be applied to a function."
            ),
        ],
        name: Annotated[StrictStr, Field(description="The name of the function.")],
        *,
        query: PutAllQuery | QueryParamTypes | None = None,
        raw_response: Literal[False] = False,
        select_path: Literal[""] = "",
        response_type: Literal[None] = None,
        validate_request: StrictBool = True,
        headers: HeaderTypes | None = None,
        **kwargs,
    ) -> FunctionTagResponse: ...

    @overload
    async def put_all(
        self,
        tag_name: Annotated[
            StrictStr,
            Field(
                description="The name of the tag that might be applied to a function."
            ),
        ],
        name: Annotated[StrictStr, Field(description="The name of the function.")],
        *,
        query: PutAllQuery | QueryParamTypes | None = None,
        raw_response: Literal[False] = False,
        select_path: Literal[""] = "",
        response_type: T,
        validate_request: StrictBool = True,
        headers: HeaderTypes | None = None,
        **kwargs,
    ) -> T: ...

    @overload
    async def put_all(
        self,
        tag_name: Annotated[
            StrictStr,
            Field(
                description="The name of the tag that might be applied to a function."
            ),
        ],
        name: Annotated[StrictStr, Field(description="The name of the function.")],
        *,
        query: PutAllQuery | QueryParamTypes | None = None,
        raw_response: Literal[True],
        select_path: Literal["_not_used_"] = "_not_used_",
        response_type: Literal[None] = None,  # not used
        validate_request: StrictBool = True,
        headers: HeaderTypes | None = None,
        **kwargs,
    ) -> Response: ...

    @overload
    async def put_all(
        self,
        tag_name: Annotated[
            StrictStr,
            Field(
                description="The name of the tag that might be applied to a function."
            ),
        ],
        name: Annotated[StrictStr, Field(description="The name of the function.")],
        *,
        query: PutAllQuery | QueryParamTypes | None = None,
        raw_response: Literal[False] = False,
        select_path: str,
        response_type: Literal[None] = None,
        validate_request: StrictBool = True,
        headers: HeaderTypes | None = None,
        **kwargs,
    ) -> Model: ...

    @overload
    async def put_all(
        self,
        tag_name: Annotated[
            StrictStr,
            Field(
                description="The name of the tag that might be applied to a function."
            ),
        ],
        name: Annotated[StrictStr, Field(description="The name of the function.")],
        *,
        query: PutAllQuery | QueryParamTypes | None = None,
        raw_response: Literal[False] = False,
        select_path: str,
        response_type: T,
        validate_request: StrictBool = True,
        headers: HeaderTypes | None = None,
        **kwargs,
    ) -> T: ...

    async def put_all(
        self,
        tag_name: Annotated[
            StrictStr,
            Field(
                description="The name of the tag that might be applied to a function."
            ),
        ],
        name: Annotated[StrictStr, Field(description="The name of the function.")],
        *,
        query: PutAllQuery | QueryParamTypes | None = None,
        raw_response: StrictBool = False,
        select_path: str = "",
        response_type: T | None = None,
        validate_request: StrictBool = True,
        headers: HeaderTypes | None = None,
        **kwargs,
    ) -> FunctionTagResponse | T | Response | Model:
        """Put Tag On All.

        Add a tag on on all versions of a webscript version.
        :param tag_name: The name of the tag that might be applied to a function. (required)
        :type tag_name: str
        :param name: The name of the function. (required)
        :type name: str
        :param query: URL Query parameters.
        :type query: PutAllQuery | QueryParamTypes, optional
        :param raw_response: If true, return the http Response object instead of returning an api model object, or throwing an ApiError.
        :param select_path: Denotes the json path applied to the response object before returning it.
                Set it to the empty string `""` to receive the full response object.
        :param response_type: If specified, the response is parsed into an instance of the specified type.
        :param validate_request: If set to false, the request body and query parameters are NOT validated against the models in the service types package, even when available.
        :param headers: Header parameters for this request
        :type headers: dict, optional
        :param `**kwargs`: Additional parameters passed on to the http client.
            See below.
        :Keyword Arguments:
            * timeout: a single numeric timeout in seconds,
                or a tuple of _connect_, _read_, _write_ and _pool_ timeouts.
            * stream: if true, the response will be in streaming mode
            * cookies
            * extensions
            * auth
            * follow_redirects: bool

        :return: Returns the result object if the http request succeeded with status code '2XX'.
        :raises APIError: If the http request has a status code different from `2XX`. This
            object wraps both the http Response and any parsed data.
        """

        # path parameters
        path_params: Dict[str, str] = {
            "tagName": str(tag_name),
            "name": str(name),
        }

        ## named body parameters
        body_args: Dict[str, Any] = {}

        # query parameters
        if query is not None and MODELS_AVAILABLE and validate_request:
            query = TypeAdapter(PutAllQuery).validate_python(query)

        response_types_map: Dict[str, Any] = (
            {"2XX": response_type}
            if response_type is not None
            else {
                "200": FunctionTagResponse if not select_path else Model,
            }
        )
        non_200_response_types_map: Dict[str, Any] = {}
        response_types_map.update(non_200_response_types_map)

        ## peform request
        return await self.api_client.request(
            method="PUT",
            resource_path="/registry/v2/webscripts/{name}/tags/{tagName}",
            path_params=path_params,
            params=query,
            **body_args,
            headers=headers,
            **kwargs,
            response_type=response_types_map,
            select_path=select_path,
            raw_response=raw_response,
        )

    @overload
    async def put(
        self,
        tag_name: Annotated[
            StrictStr,
            Field(
                description="The name of the tag that might be applied to a function."
            ),
        ],
        name: Annotated[StrictStr, Field(description="The name of the function.")],
        version: Annotated[
            str, Field(strict=True, description="The version of the function.")
        ],
        *,
        query: PutQuery | QueryParamTypes | None = None,
        raw_response: Literal[False] = False,
        select_path: Literal[""] = "",
        response_type: Literal[None] = None,
        validate_request: StrictBool = True,
        headers: HeaderTypes | None = None,
        **kwargs,
    ) -> FunctionTagResponse: ...

    @overload
    async def put(
        self,
        tag_name: Annotated[
            StrictStr,
            Field(
                description="The name of the tag that might be applied to a function."
            ),
        ],
        name: Annotated[StrictStr, Field(description="The name of the function.")],
        version: Annotated[
            str, Field(strict=True, description="The version of the function.")
        ],
        *,
        query: PutQuery | QueryParamTypes | None = None,
        raw_response: Literal[False] = False,
        select_path: Literal[""] = "",
        response_type: T,
        validate_request: StrictBool = True,
        headers: HeaderTypes | None = None,
        **kwargs,
    ) -> T: ...

    @overload
    async def put(
        self,
        tag_name: Annotated[
            StrictStr,
            Field(
                description="The name of the tag that might be applied to a function."
            ),
        ],
        name: Annotated[StrictStr, Field(description="The name of the function.")],
        version: Annotated[
            str, Field(strict=True, description="The version of the function.")
        ],
        *,
        query: PutQuery | QueryParamTypes | None = None,
        raw_response: Literal[True],
        select_path: Literal["_not_used_"] = "_not_used_",
        response_type: Literal[None] = None,  # not used
        validate_request: StrictBool = True,
        headers: HeaderTypes | None = None,
        **kwargs,
    ) -> Response: ...

    @overload
    async def put(
        self,
        tag_name: Annotated[
            StrictStr,
            Field(
                description="The name of the tag that might be applied to a function."
            ),
        ],
        name: Annotated[StrictStr, Field(description="The name of the function.")],
        version: Annotated[
            str, Field(strict=True, description="The version of the function.")
        ],
        *,
        query: PutQuery | QueryParamTypes | None = None,
        raw_response: Literal[False] = False,
        select_path: str,
        response_type: Literal[None] = None,
        validate_request: StrictBool = True,
        headers: HeaderTypes | None = None,
        **kwargs,
    ) -> Model: ...

    @overload
    async def put(
        self,
        tag_name: Annotated[
            StrictStr,
            Field(
                description="The name of the tag that might be applied to a function."
            ),
        ],
        name: Annotated[StrictStr, Field(description="The name of the function.")],
        version: Annotated[
            str, Field(strict=True, description="The version of the function.")
        ],
        *,
        query: PutQuery | QueryParamTypes | None = None,
        raw_response: Literal[False] = False,
        select_path: str,
        response_type: T,
        validate_request: StrictBool = True,
        headers: HeaderTypes | None = None,
        **kwargs,
    ) -> T: ...

    async def put(
        self,
        tag_name: Annotated[
            StrictStr,
            Field(
                description="The name of the tag that might be applied to a function."
            ),
        ],
        name: Annotated[StrictStr, Field(description="The name of the function.")],
        version: Annotated[
            str, Field(strict=True, description="The version of the function.")
        ],
        *,
        query: PutQuery | QueryParamTypes | None = None,
        raw_response: StrictBool = False,
        select_path: str = "",
        response_type: T | None = None,
        validate_request: StrictBool = True,
        headers: HeaderTypes | None = None,
        **kwargs,
    ) -> FunctionTagResponse | T | Response | Model:
        """Put Tag.

        Put a tag on a webscript version.
        :param tag_name: The name of the tag that might be applied to a function. (required)
        :type tag_name: str
        :param name: The name of the function. (required)
        :type name: str
        :param version: The version of the function. (required)
        :type version: str
        :param query: URL Query parameters.
        :type query: PutQuery | QueryParamTypes, optional
        :param raw_response: If true, return the http Response object instead of returning an api model object, or throwing an ApiError.
        :param select_path: Denotes the json path applied to the response object before returning it.
                Set it to the empty string `""` to receive the full response object.
        :param response_type: If specified, the response is parsed into an instance of the specified type.
        :param validate_request: If set to false, the request body and query parameters are NOT validated against the models in the service types package, even when available.
        :param headers: Header parameters for this request
        :type headers: dict, optional
        :param `**kwargs`: Additional parameters passed on to the http client.
            See below.
        :Keyword Arguments:
            * timeout: a single numeric timeout in seconds,
                or a tuple of _connect_, _read_, _write_ and _pool_ timeouts.
            * stream: if true, the response will be in streaming mode
            * cookies
            * extensions
            * auth
            * follow_redirects: bool

        :return: Returns the result object if the http request succeeded with status code '2XX'.
        :raises APIError: If the http request has a status code different from `2XX`. This
            object wraps both the http Response and any parsed data.
        """

        # path parameters
        path_params: Dict[str, str] = {
            "tagName": str(tag_name),
            "name": str(name),
            "version": str(version),
        }

        ## named body parameters
        body_args: Dict[str, Any] = {}

        # query parameters
        if query is not None and MODELS_AVAILABLE and validate_request:
            query = TypeAdapter(PutQuery).validate_python(query)

        response_types_map: Dict[str, Any] = (
            {"2XX": response_type}
            if response_type is not None
            else {
                "200": FunctionTagResponse if not select_path else Model,
            }
        )
        non_200_response_types_map: Dict[str, Any] = {}
        response_types_map.update(non_200_response_types_map)

        ## peform request
        return await self.api_client.request(
            method="PUT",
            resource_path="/registry/v2/webscripts/{name}/versions/{version}/tags/{tagName}",
            path_params=path_params,
            params=query,
            **body_args,
            headers=headers,
            **kwargs,
            response_type=response_types_map,
            select_path=select_path,
            raw_response=raw_response,
        )

    @overload
    async def remove_all(
        self,
        tag_name: Annotated[
            StrictStr,
            Field(
                description="The name of the tag that might be applied to a function."
            ),
        ],
        name: Annotated[StrictStr, Field(description="The name of the function.")],
        *,
        query: RemoveAllQuery | QueryParamTypes | None = None,
        raw_response: Literal[False] = False,
        select_path: Literal[""] = "",
        response_type: Literal[None] = None,
        validate_request: StrictBool = True,
        headers: HeaderTypes | None = None,
        **kwargs,
    ) -> FunctionTagResponse: ...

    @overload
    async def remove_all(
        self,
        tag_name: Annotated[
            StrictStr,
            Field(
                description="The name of the tag that might be applied to a function."
            ),
        ],
        name: Annotated[StrictStr, Field(description="The name of the function.")],
        *,
        query: RemoveAllQuery | QueryParamTypes | None = None,
        raw_response: Literal[False] = False,
        select_path: Literal[""] = "",
        response_type: T,
        validate_request: StrictBool = True,
        headers: HeaderTypes | None = None,
        **kwargs,
    ) -> T: ...

    @overload
    async def remove_all(
        self,
        tag_name: Annotated[
            StrictStr,
            Field(
                description="The name of the tag that might be applied to a function."
            ),
        ],
        name: Annotated[StrictStr, Field(description="The name of the function.")],
        *,
        query: RemoveAllQuery | QueryParamTypes | None = None,
        raw_response: Literal[True],
        select_path: Literal["_not_used_"] = "_not_used_",
        response_type: Literal[None] = None,  # not used
        validate_request: StrictBool = True,
        headers: HeaderTypes | None = None,
        **kwargs,
    ) -> Response: ...

    @overload
    async def remove_all(
        self,
        tag_name: Annotated[
            StrictStr,
            Field(
                description="The name of the tag that might be applied to a function."
            ),
        ],
        name: Annotated[StrictStr, Field(description="The name of the function.")],
        *,
        query: RemoveAllQuery | QueryParamTypes | None = None,
        raw_response: Literal[False] = False,
        select_path: str,
        response_type: Literal[None] = None,
        validate_request: StrictBool = True,
        headers: HeaderTypes | None = None,
        **kwargs,
    ) -> Model: ...

    @overload
    async def remove_all(
        self,
        tag_name: Annotated[
            StrictStr,
            Field(
                description="The name of the tag that might be applied to a function."
            ),
        ],
        name: Annotated[StrictStr, Field(description="The name of the function.")],
        *,
        query: RemoveAllQuery | QueryParamTypes | None = None,
        raw_response: Literal[False] = False,
        select_path: str,
        response_type: T,
        validate_request: StrictBool = True,
        headers: HeaderTypes | None = None,
        **kwargs,
    ) -> T: ...

    async def remove_all(
        self,
        tag_name: Annotated[
            StrictStr,
            Field(
                description="The name of the tag that might be applied to a function."
            ),
        ],
        name: Annotated[StrictStr, Field(description="The name of the function.")],
        *,
        query: RemoveAllQuery | QueryParamTypes | None = None,
        raw_response: StrictBool = False,
        select_path: str = "",
        response_type: T | None = None,
        validate_request: StrictBool = True,
        headers: HeaderTypes | None = None,
        **kwargs,
    ) -> FunctionTagResponse | T | Response | Model:
        """Remove Tag On Any/All.

        Remove a tag on any or all version from a webscript version.         With 'from=all', the tag is only removed when it exists on all versions.
        :param tag_name: The name of the tag that might be applied to a function. (required)
        :type tag_name: str
        :param name: The name of the function. (required)
        :type name: str
        :param query: URL Query parameters.
        :type query: RemoveAllQuery | QueryParamTypes, optional
        :param raw_response: If true, return the http Response object instead of returning an api model object, or throwing an ApiError.
        :param select_path: Denotes the json path applied to the response object before returning it.
                Set it to the empty string `""` to receive the full response object.
        :param response_type: If specified, the response is parsed into an instance of the specified type.
        :param validate_request: If set to false, the request body and query parameters are NOT validated against the models in the service types package, even when available.
        :param headers: Header parameters for this request
        :type headers: dict, optional
        :param `**kwargs`: Additional parameters passed on to the http client.
            See below.
        :Keyword Arguments:
            * timeout: a single numeric timeout in seconds,
                or a tuple of _connect_, _read_, _write_ and _pool_ timeouts.
            * stream: if true, the response will be in streaming mode
            * cookies
            * extensions
            * auth
            * follow_redirects: bool

        :return: Returns the result object if the http request succeeded with status code '2XX'.
        :raises APIError: If the http request has a status code different from `2XX`. This
            object wraps both the http Response and any parsed data.
        """

        # path parameters
        path_params: Dict[str, str] = {
            "tagName": str(tag_name),
            "name": str(name),
        }

        ## named body parameters
        body_args: Dict[str, Any] = {}

        # query parameters
        if query is not None and MODELS_AVAILABLE and validate_request:
            query = TypeAdapter(RemoveAllQuery).validate_python(query)

        response_types_map: Dict[str, Any] = (
            {"2XX": response_type}
            if response_type is not None
            else {
                "200": FunctionTagResponse if not select_path else Model,
            }
        )
        non_200_response_types_map: Dict[str, Any] = {
            "404": ErrorAndStatusResponse,
        }
        response_types_map.update(non_200_response_types_map)

        ## peform request
        return await self.api_client.request(
            method="DELETE",
            resource_path="/registry/v2/webscripts/{name}/tags/{tagName}",
            path_params=path_params,
            params=query,
            **body_args,
            headers=headers,
            **kwargs,
            response_type=response_types_map,
            select_path=select_path,
            raw_response=raw_response,
        )

    @overload
    async def remove(
        self,
        tag_name: Annotated[
            StrictStr,
            Field(
                description="The name of the tag that might be applied to a function."
            ),
        ],
        name: Annotated[StrictStr, Field(description="The name of the function.")],
        version: Annotated[
            str, Field(strict=True, description="The version of the function.")
        ],
        *,
        query: RemoveQuery | QueryParamTypes | None = None,
        raw_response: Literal[False] = False,
        select_path: Literal[""] = "",
        response_type: Literal[None] = None,
        validate_request: StrictBool = True,
        headers: HeaderTypes | None = None,
        **kwargs,
    ) -> FunctionTagResponse: ...

    @overload
    async def remove(
        self,
        tag_name: Annotated[
            StrictStr,
            Field(
                description="The name of the tag that might be applied to a function."
            ),
        ],
        name: Annotated[StrictStr, Field(description="The name of the function.")],
        version: Annotated[
            str, Field(strict=True, description="The version of the function.")
        ],
        *,
        query: RemoveQuery | QueryParamTypes | None = None,
        raw_response: Literal[False] = False,
        select_path: Literal[""] = "",
        response_type: T,
        validate_request: StrictBool = True,
        headers: HeaderTypes | None = None,
        **kwargs,
    ) -> T: ...

    @overload
    async def remove(
        self,
        tag_name: Annotated[
            StrictStr,
            Field(
                description="The name of the tag that might be applied to a function."
            ),
        ],
        name: Annotated[StrictStr, Field(description="The name of the function.")],
        version: Annotated[
            str, Field(strict=True, description="The version of the function.")
        ],
        *,
        query: RemoveQuery | QueryParamTypes | None = None,
        raw_response: Literal[True],
        select_path: Literal["_not_used_"] = "_not_used_",
        response_type: Literal[None] = None,  # not used
        validate_request: StrictBool = True,
        headers: HeaderTypes | None = None,
        **kwargs,
    ) -> Response: ...

    @overload
    async def remove(
        self,
        tag_name: Annotated[
            StrictStr,
            Field(
                description="The name of the tag that might be applied to a function."
            ),
        ],
        name: Annotated[StrictStr, Field(description="The name of the function.")],
        version: Annotated[
            str, Field(strict=True, description="The version of the function.")
        ],
        *,
        query: RemoveQuery | QueryParamTypes | None = None,
        raw_response: Literal[False] = False,
        select_path: str,
        response_type: Literal[None] = None,
        validate_request: StrictBool = True,
        headers: HeaderTypes | None = None,
        **kwargs,
    ) -> Model: ...

    @overload
    async def remove(
        self,
        tag_name: Annotated[
            StrictStr,
            Field(
                description="The name of the tag that might be applied to a function."
            ),
        ],
        name: Annotated[StrictStr, Field(description="The name of the function.")],
        version: Annotated[
            str, Field(strict=True, description="The version of the function.")
        ],
        *,
        query: RemoveQuery | QueryParamTypes | None = None,
        raw_response: Literal[False] = False,
        select_path: str,
        response_type: T,
        validate_request: StrictBool = True,
        headers: HeaderTypes | None = None,
        **kwargs,
    ) -> T: ...

    async def remove(
        self,
        tag_name: Annotated[
            StrictStr,
            Field(
                description="The name of the tag that might be applied to a function."
            ),
        ],
        name: Annotated[StrictStr, Field(description="The name of the function.")],
        version: Annotated[
            str, Field(strict=True, description="The version of the function.")
        ],
        *,
        query: RemoveQuery | QueryParamTypes | None = None,
        raw_response: StrictBool = False,
        select_path: str = "",
        response_type: T | None = None,
        validate_request: StrictBool = True,
        headers: HeaderTypes | None = None,
        **kwargs,
    ) -> FunctionTagResponse | T | Response | Model:
        """Remove Tag.

        Remove a tag from a webscript version.
        :param tag_name: The name of the tag that might be applied to a function. (required)
        :type tag_name: str
        :param name: The name of the function. (required)
        :type name: str
        :param version: The version of the function. (required)
        :type version: str
        :param query: URL Query parameters.
        :type query: RemoveQuery | QueryParamTypes, optional
        :param raw_response: If true, return the http Response object instead of returning an api model object, or throwing an ApiError.
        :param select_path: Denotes the json path applied to the response object before returning it.
                Set it to the empty string `""` to receive the full response object.
        :param response_type: If specified, the response is parsed into an instance of the specified type.
        :param validate_request: If set to false, the request body and query parameters are NOT validated against the models in the service types package, even when available.
        :param headers: Header parameters for this request
        :type headers: dict, optional
        :param `**kwargs`: Additional parameters passed on to the http client.
            See below.
        :Keyword Arguments:
            * timeout: a single numeric timeout in seconds,
                or a tuple of _connect_, _read_, _write_ and _pool_ timeouts.
            * stream: if true, the response will be in streaming mode
            * cookies
            * extensions
            * auth
            * follow_redirects: bool

        :return: Returns the result object if the http request succeeded with status code '2XX'.
        :raises APIError: If the http request has a status code different from `2XX`. This
            object wraps both the http Response and any parsed data.
        """

        # path parameters
        path_params: Dict[str, str] = {
            "tagName": str(tag_name),
            "name": str(name),
            "version": str(version),
        }

        ## named body parameters
        body_args: Dict[str, Any] = {}

        # query parameters
        if query is not None and MODELS_AVAILABLE and validate_request:
            query = TypeAdapter(RemoveQuery).validate_python(query)

        response_types_map: Dict[str, Any] = (
            {"2XX": response_type}
            if response_type is not None
            else {
                "200": FunctionTagResponse if not select_path else Model,
            }
        )
        non_200_response_types_map: Dict[str, Any] = {
            "404": ErrorAndStatusResponse,
        }
        response_types_map.update(non_200_response_types_map)

        ## peform request
        return await self.api_client.request(
            method="DELETE",
            resource_path="/registry/v2/webscripts/{name}/versions/{version}/tags/{tagName}",
            path_params=path_params,
            params=query,
            **body_args,
            headers=headers,
            **kwargs,
            response_type=response_types_map,
            select_path=select_path,
            raw_response=raw_response,
        )

    @overload
    async def replace_all(
        self,
        name: Annotated[StrictStr, Field(description="The name of the function.")],
        *,
        json: UpdateTagsRequestV2 | None = None,
        query: ReplaceAllQuery | QueryParamTypes | None = None,
        raw_response: Literal[False] = False,
        select_path: Literal[""] = "",
        response_type: Literal[None] = None,
        validate_request: StrictBool = True,
        headers: HeaderTypes | None = None,
        **kwargs,
    ) -> FunctionTagsResponse: ...

    @overload
    async def replace_all(
        self,
        name: Annotated[StrictStr, Field(description="The name of the function.")],
        *,
        json: UpdateTagsRequestV2 | None = None,
        query: ReplaceAllQuery | QueryParamTypes | None = None,
        raw_response: Literal[False] = False,
        select_path: Literal[""] = "",
        response_type: T,
        validate_request: StrictBool = True,
        headers: HeaderTypes | None = None,
        **kwargs,
    ) -> T: ...

    @overload
    async def replace_all(
        self,
        name: Annotated[StrictStr, Field(description="The name of the function.")],
        *,
        json: UpdateTagsRequestV2 | None = None,
        query: ReplaceAllQuery | QueryParamTypes | None = None,
        raw_response: Literal[True],
        select_path: Literal["_not_used_"] = "_not_used_",
        response_type: Literal[None] = None,  # not used
        validate_request: StrictBool = True,
        headers: HeaderTypes | None = None,
        **kwargs,
    ) -> Response: ...

    @overload
    async def replace_all(
        self,
        name: Annotated[StrictStr, Field(description="The name of the function.")],
        *,
        json: UpdateTagsRequestV2 | None = None,
        query: ReplaceAllQuery | QueryParamTypes | None = None,
        raw_response: Literal[False] = False,
        select_path: str,
        response_type: Literal[None] = None,
        validate_request: StrictBool = True,
        headers: HeaderTypes | None = None,
        **kwargs,
    ) -> Model: ...

    @overload
    async def replace_all(
        self,
        name: Annotated[StrictStr, Field(description="The name of the function.")],
        *,
        json: UpdateTagsRequestV2 | None = None,
        query: ReplaceAllQuery | QueryParamTypes | None = None,
        raw_response: Literal[False] = False,
        select_path: str,
        response_type: T,
        validate_request: StrictBool = True,
        headers: HeaderTypes | None = None,
        **kwargs,
    ) -> T: ...

    async def replace_all(
        self,
        name: Annotated[StrictStr, Field(description="The name of the function.")],
        *,
        json: UpdateTagsRequestV2 | None = None,
        query: ReplaceAllQuery | QueryParamTypes | None = None,
        raw_response: StrictBool = False,
        select_path: str = "",
        response_type: T | None = None,
        validate_request: StrictBool = True,
        headers: HeaderTypes | None = None,
        **kwargs,
    ) -> FunctionTagsResponse | T | Response | Model:
        """Replace Tags On Any/All.

        Replace tags used on any or all versions of a named webscript.         With 'from=all', only the tags that were set to all versions are replaced.
        :param name: The name of the function. (required)
        :type name: str
        :param json: The json request body.
        :type json: UpdateTagsRequestV2, optional
        :param query: URL Query parameters.
        :type query: ReplaceAllQuery | QueryParamTypes, optional
        :param query['scope'] (dict) <br> query.scope (Query) : Tagging operations on a _named_ function can either operate on - `any` versions: operate on tags that are are associated on _any_ version (union) - `all` versions: operate on tags that are are associated with _all_ versions (intersection)
        :type query['scope']: TaggingScopeOption
        :param raw_response: If true, return the http Response object instead of returning an api model object, or throwing an ApiError.
        :param select_path: Denotes the json path applied to the response object before returning it.
                Set it to the empty string `""` to receive the full response object.
        :param response_type: If specified, the response is parsed into an instance of the specified type.
        :param validate_request: If set to false, the request body and query parameters are NOT validated against the models in the service types package, even when available.
        :param headers: Header parameters for this request
        :type headers: dict, optional
        :param `**kwargs`: Additional parameters passed on to the http client.
            See below.
        :Keyword Arguments:
            * timeout: a single numeric timeout in seconds,
                or a tuple of _connect_, _read_, _write_ and _pool_ timeouts.
            * stream: if true, the response will be in streaming mode
            * cookies
            * extensions
            * auth
            * follow_redirects: bool

        :return: Returns the result object if the http request succeeded with status code '2XX'.
        :raises APIError: If the http request has a status code different from `2XX`. This
            object wraps both the http Response and any parsed data.
        """

        # path parameters
        path_params: Dict[str, str] = {
            "name": str(name),
        }

        ## named body parameters
        body_args: Dict[str, Any] = {}
        if json is not None and validate_request:
            body_adapter: Any = TypeAdapter(Optional[UpdateTagsRequestV2])
            json = body_adapter.validate_python(json)  # type: ignore # https://github.com/pydantic/pydantic/discussions/7094
        body_args["json"] = json

        # query parameters
        if query is not None and MODELS_AVAILABLE and validate_request:
            query = TypeAdapter(ReplaceAllQuery).validate_python(query)

        response_types_map: Dict[str, Any] = (
            {"2XX": response_type}
            if response_type is not None
            else {
                "200": FunctionTagsResponse if not select_path else Model,
            }
        )
        non_200_response_types_map: Dict[str, Any] = {}
        response_types_map.update(non_200_response_types_map)

        ## peform request
        return await self.api_client.request(
            method="PUT",
            resource_path="/registry/v2/webscripts/{name}/tags",
            path_params=path_params,
            params=query,
            **body_args,
            headers=headers,
            **kwargs,
            response_type=response_types_map,
            select_path=select_path,
            raw_response=raw_response,
        )

    @overload
    async def replace(
        self,
        name: Annotated[StrictStr, Field(description="The name of the function.")],
        version: Annotated[
            str, Field(strict=True, description="The version of the function.")
        ],
        *,
        json: UpdateTagsRequestV2 | None = None,
        query: ReplaceQuery | QueryParamTypes | None = None,
        raw_response: Literal[False] = False,
        select_path: Literal[""] = "",
        response_type: Literal[None] = None,
        validate_request: StrictBool = True,
        headers: HeaderTypes | None = None,
        **kwargs,
    ) -> FunctionTagsResponse: ...

    @overload
    async def replace(
        self,
        name: Annotated[StrictStr, Field(description="The name of the function.")],
        version: Annotated[
            str, Field(strict=True, description="The version of the function.")
        ],
        *,
        json: UpdateTagsRequestV2 | None = None,
        query: ReplaceQuery | QueryParamTypes | None = None,
        raw_response: Literal[False] = False,
        select_path: Literal[""] = "",
        response_type: T,
        validate_request: StrictBool = True,
        headers: HeaderTypes | None = None,
        **kwargs,
    ) -> T: ...

    @overload
    async def replace(
        self,
        name: Annotated[StrictStr, Field(description="The name of the function.")],
        version: Annotated[
            str, Field(strict=True, description="The version of the function.")
        ],
        *,
        json: UpdateTagsRequestV2 | None = None,
        query: ReplaceQuery | QueryParamTypes | None = None,
        raw_response: Literal[True],
        select_path: Literal["_not_used_"] = "_not_used_",
        response_type: Literal[None] = None,  # not used
        validate_request: StrictBool = True,
        headers: HeaderTypes | None = None,
        **kwargs,
    ) -> Response: ...

    @overload
    async def replace(
        self,
        name: Annotated[StrictStr, Field(description="The name of the function.")],
        version: Annotated[
            str, Field(strict=True, description="The version of the function.")
        ],
        *,
        json: UpdateTagsRequestV2 | None = None,
        query: ReplaceQuery | QueryParamTypes | None = None,
        raw_response: Literal[False] = False,
        select_path: str,
        response_type: Literal[None] = None,
        validate_request: StrictBool = True,
        headers: HeaderTypes | None = None,
        **kwargs,
    ) -> Model: ...

    @overload
    async def replace(
        self,
        name: Annotated[StrictStr, Field(description="The name of the function.")],
        version: Annotated[
            str, Field(strict=True, description="The version of the function.")
        ],
        *,
        json: UpdateTagsRequestV2 | None = None,
        query: ReplaceQuery | QueryParamTypes | None = None,
        raw_response: Literal[False] = False,
        select_path: str,
        response_type: T,
        validate_request: StrictBool = True,
        headers: HeaderTypes | None = None,
        **kwargs,
    ) -> T: ...

    async def replace(
        self,
        name: Annotated[StrictStr, Field(description="The name of the function.")],
        version: Annotated[
            str, Field(strict=True, description="The version of the function.")
        ],
        *,
        json: UpdateTagsRequestV2 | None = None,
        query: ReplaceQuery | QueryParamTypes | None = None,
        raw_response: StrictBool = False,
        select_path: str = "",
        response_type: T | None = None,
        validate_request: StrictBool = True,
        headers: HeaderTypes | None = None,
        **kwargs,
    ) -> FunctionTagsResponse | T | Response | Model:
        """Replace Tags.

        Replace tags used on a webscript version.
        :param name: The name of the function. (required)
        :type name: str
        :param version: The version of the function. (required)
        :type version: str
        :param json: The json request body.
        :type json: UpdateTagsRequestV2, optional
        :param query: URL Query parameters.
        :type query: ReplaceQuery | QueryParamTypes, optional
        :param raw_response: If true, return the http Response object instead of returning an api model object, or throwing an ApiError.
        :param select_path: Denotes the json path applied to the response object before returning it.
                Set it to the empty string `""` to receive the full response object.
        :param response_type: If specified, the response is parsed into an instance of the specified type.
        :param validate_request: If set to false, the request body and query parameters are NOT validated against the models in the service types package, even when available.
        :param headers: Header parameters for this request
        :type headers: dict, optional
        :param `**kwargs`: Additional parameters passed on to the http client.
            See below.
        :Keyword Arguments:
            * timeout: a single numeric timeout in seconds,
                or a tuple of _connect_, _read_, _write_ and _pool_ timeouts.
            * stream: if true, the response will be in streaming mode
            * cookies
            * extensions
            * auth
            * follow_redirects: bool

        :return: Returns the result object if the http request succeeded with status code '2XX'.
        :raises APIError: If the http request has a status code different from `2XX`. This
            object wraps both the http Response and any parsed data.
        """

        # path parameters
        path_params: Dict[str, str] = {
            "name": str(name),
            "version": str(version),
        }

        ## named body parameters
        body_args: Dict[str, Any] = {}
        if json is not None and validate_request:
            body_adapter: Any = TypeAdapter(Optional[UpdateTagsRequestV2])
            json = body_adapter.validate_python(json)  # type: ignore # https://github.com/pydantic/pydantic/discussions/7094
        body_args["json"] = json

        # query parameters
        if query is not None and MODELS_AVAILABLE and validate_request:
            query = TypeAdapter(ReplaceQuery).validate_python(query)

        response_types_map: Dict[str, Any] = (
            {"2XX": response_type}
            if response_type is not None
            else {
                "200": FunctionTagsResponse if not select_path else Model,
            }
        )
        non_200_response_types_map: Dict[str, Any] = {}
        response_types_map.update(non_200_response_types_map)

        ## peform request
        return await self.api_client.request(
            method="PUT",
            resource_path="/registry/v2/webscripts/{name}/versions/{version}/tags",
            path_params=path_params,
            params=query,
            **body_args,
            headers=headers,
            **kwargs,
            response_type=response_types_map,
            select_path=select_path,
            raw_response=raw_response,
        )
