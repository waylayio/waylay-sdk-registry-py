# coding: utf-8
"""Waylay Function Registry api.

This code was generated from the OpenAPI documentation of 'Waylay Function Registry'

Generated by OpenAPI Generator (https://openapi-generator.tech)

Do not edit the class manually.
"""

from __future__ import annotations  # for Python 3.7â€“3.9

from typing import (
    TYPE_CHECKING,
    Any,
    Dict,
    Literal,
    Optional,
    TypeVar,
    Union,
    overload,
)

from pydantic import (
    Field,
    StrictBool,
    StrictBytes,
    StrictStr,
    TypeAdapter,
)
from typing_extensions import (
    Annotated,  # >=3.9,
)
from waylay.sdk.api import (
    HeaderTypes,
    QueryParamTypes,
    RequestContent,
    RequestFiles,
    Response,
)
from waylay.sdk.api._models import Model
from waylay.sdk.plugin import WithApiClient

if TYPE_CHECKING:
    from waylay.services.registry.models import (
        Documentation,
        FileUpload,
        GetPlugResponseV2,
        JobsForPlugResponseV2,
        LatestPlugsResponseV2,
        PlugVersionsResponseV2,
        PostPlugJobAsyncResponseV2,
        PostPlugJobSyncResponseV2,
        RebuildPlugAsyncResponseV2,
        RebuildPlugSyncResponseV2,
        RegistryErrorResponse,
        UndeployedResponseV2,
        UndeploySubmittedResponseV2,
        UpdateMetadataRequestV2,
        VerifyPlugSyncResponseV2,
    )
    from waylay.services.registry.queries.plugs_api import (
        CreateQuery,
        DeleteAssetQuery,
        GetArchiveQuery,
        GetAssetQuery,
        GetLatestQuery,
        GetQuery,
        JobsQuery,
        ListQuery,
        ListVersionsQuery,
        PatchInterfaceQuery,
        PatchMetadataQuery,
        PublishQuery,
        RebuildQuery,
        RemoveVersionQuery,
        RemoveVersionsQuery,
        UpdateAssetQuery,
        UpdateAssetsQuery,
        VerifyQuery,
    )


try:
    from waylay.services.registry.models import (
        Documentation,
        FileUpload,
        GetPlugResponseV2,
        JobsForPlugResponseV2,
        LatestPlugsResponseV2,
        PlugVersionsResponseV2,
        PostPlugJobAsyncResponseV2,
        PostPlugJobSyncResponseV2,
        RebuildPlugAsyncResponseV2,
        RebuildPlugSyncResponseV2,
        RegistryErrorResponse,
        UndeployedResponseV2,
        UndeploySubmittedResponseV2,
        UpdateMetadataRequestV2,
        VerifyPlugSyncResponseV2,
    )
    from waylay.services.registry.queries.plugs_api import (
        CreateQuery,
        DeleteAssetQuery,
        GetArchiveQuery,
        GetAssetQuery,
        GetLatestQuery,
        GetQuery,
        JobsQuery,
        ListQuery,
        ListVersionsQuery,
        PatchInterfaceQuery,
        PatchMetadataQuery,
        PublishQuery,
        RebuildQuery,
        RemoveVersionQuery,
        RemoveVersionsQuery,
        UpdateAssetQuery,
        UpdateAssetsQuery,
        VerifyQuery,
    )

    MODELS_AVAILABLE = True
except ImportError:
    MODELS_AVAILABLE = False

    if not TYPE_CHECKING:
        CreateQuery = dict
        PostPlugJobSyncResponseV2 = Model

        PostPlugJobAsyncResponseV2 = Model

        DeleteAssetQuery = dict
        PostPlugJobSyncResponseV2 = Model

        PostPlugJobAsyncResponseV2 = Model

        RegistryErrorResponse = Model

        GetArchiveQuery = dict

        GetAssetQuery = dict

        GetLatestQuery = dict
        GetPlugResponseV2 = Model

        GetQuery = dict
        GetPlugResponseV2 = Model

        JobsQuery = dict
        JobsForPlugResponseV2 = Model

        ListQuery = dict
        LatestPlugsResponseV2 = Model

        ListVersionsQuery = dict
        PlugVersionsResponseV2 = Model

        Documentation = Model

        PatchInterfaceQuery = dict
        GetPlugResponseV2 = Model

        UpdateMetadataRequestV2 = Model

        PatchMetadataQuery = dict
        GetPlugResponseV2 = Model

        PublishQuery = dict
        PostPlugJobSyncResponseV2 = Model

        PostPlugJobAsyncResponseV2 = Model

        RebuildQuery = dict
        RebuildPlugSyncResponseV2 = Model

        RebuildPlugAsyncResponseV2 = Model

        RemoveVersionQuery = dict
        UndeployedResponseV2 = Model

        UndeploySubmittedResponseV2 = Model

        RemoveVersionsQuery = dict
        UndeployedResponseV2 = Model

        UndeploySubmittedResponseV2 = Model

        FileUpload = Model

        UpdateAssetQuery = dict
        PostPlugJobSyncResponseV2 = Model

        PostPlugJobAsyncResponseV2 = Model

        RegistryErrorResponse = Model

        UpdateAssetsQuery = dict
        PostPlugJobSyncResponseV2 = Model

        PostPlugJobAsyncResponseV2 = Model

        RegistryErrorResponse = Model

        VerifyQuery = dict
        VerifyPlugSyncResponseV2 = Model

        PostPlugJobAsyncResponseV2 = Model


T = TypeVar("T")


class PlugsApi(WithApiClient):
    """PlugsApi service methods.

    NOTE: This class is auto generated by OpenAPI Generator
    Ref: https://openapi-generator.tech

    Do not edit the class manually.
    """

    @overload
    async def create(
        self,
        *,
        json: Annotated[
            StrictBytes | StrictStr | None,
            Field(
                description="The assets for a <em>plug</em> function can be provided as   <ul>     <li>A single <em>tar</em> archive (optionally compressed), with one of the content types      <code>application/octet-stream</code>, <code>application/tar</code>, <code>application/tar+gzip</code>, <code>application/x-gzip</code>, <code>application/x-tar</code>, <code>application/gzip</code></li>     <li>Separate files in a <code>multipart/form-data</code> request</li>     <li>A reference to the assets of another <em>plug</em> in the <code>copy</code> argument</li>   </ul>    The required <code>plug.json</code> json file contains the function metadata,   and must have a <code>runtime</code> attribute that is one of the supported <em>runtime</em>s    (see <code>GET /registry/v2/runtimes?functionType=plugs</code>).    For each <em>runtime</em> other files will be required or supported. "
            ),
        ] = None,
        content: Annotated[
            RequestContent | None,
            Field(
                description="The assets for a <em>plug</em> function can be provided as   <ul>     <li>A single <em>tar</em> archive (optionally compressed), with one of the content types      <code>application/octet-stream</code>, <code>application/tar</code>, <code>application/tar+gzip</code>, <code>application/x-gzip</code>, <code>application/x-tar</code>, <code>application/gzip</code></li>     <li>Separate files in a <code>multipart/form-data</code> request</li>     <li>A reference to the assets of another <em>plug</em> in the <code>copy</code> argument</li>   </ul>    The required <code>plug.json</code> json file contains the function metadata,   and must have a <code>runtime</code> attribute that is one of the supported <em>runtime</em>s    (see <code>GET /registry/v2/runtimes?functionType=plugs</code>).    For each <em>runtime</em> other files will be required or supported. "
            ),
        ] = None,
        files: Annotated[
            RequestFiles | None, Field(description="Multipart file upload")
        ] = None,
        query: CreateQuery | QueryParamTypes | None = None,
        raw_response: Literal[False] = False,
        select_path: Literal[""] = "",
        response_type: Literal[None] = None,
        validate_request: StrictBool = True,
        headers: HeaderTypes | None = None,
        **kwargs,
    ) -> PostPlugJobSyncResponseV2 | PostPlugJobAsyncResponseV2: ...

    @overload
    async def create(
        self,
        *,
        json: Annotated[
            StrictBytes | StrictStr | None,
            Field(
                description="The assets for a <em>plug</em> function can be provided as   <ul>     <li>A single <em>tar</em> archive (optionally compressed), with one of the content types      <code>application/octet-stream</code>, <code>application/tar</code>, <code>application/tar+gzip</code>, <code>application/x-gzip</code>, <code>application/x-tar</code>, <code>application/gzip</code></li>     <li>Separate files in a <code>multipart/form-data</code> request</li>     <li>A reference to the assets of another <em>plug</em> in the <code>copy</code> argument</li>   </ul>    The required <code>plug.json</code> json file contains the function metadata,   and must have a <code>runtime</code> attribute that is one of the supported <em>runtime</em>s    (see <code>GET /registry/v2/runtimes?functionType=plugs</code>).    For each <em>runtime</em> other files will be required or supported. "
            ),
        ] = None,
        content: Annotated[
            RequestContent | None,
            Field(
                description="The assets for a <em>plug</em> function can be provided as   <ul>     <li>A single <em>tar</em> archive (optionally compressed), with one of the content types      <code>application/octet-stream</code>, <code>application/tar</code>, <code>application/tar+gzip</code>, <code>application/x-gzip</code>, <code>application/x-tar</code>, <code>application/gzip</code></li>     <li>Separate files in a <code>multipart/form-data</code> request</li>     <li>A reference to the assets of another <em>plug</em> in the <code>copy</code> argument</li>   </ul>    The required <code>plug.json</code> json file contains the function metadata,   and must have a <code>runtime</code> attribute that is one of the supported <em>runtime</em>s    (see <code>GET /registry/v2/runtimes?functionType=plugs</code>).    For each <em>runtime</em> other files will be required or supported. "
            ),
        ] = None,
        files: Annotated[
            RequestFiles | None, Field(description="Multipart file upload")
        ] = None,
        query: CreateQuery | QueryParamTypes | None = None,
        raw_response: Literal[False] = False,
        select_path: Literal[""] = "",
        response_type: T,
        validate_request: StrictBool = True,
        headers: HeaderTypes | None = None,
        **kwargs,
    ) -> T: ...

    @overload
    async def create(
        self,
        *,
        json: Annotated[
            StrictBytes | StrictStr | None,
            Field(
                description="The assets for a <em>plug</em> function can be provided as   <ul>     <li>A single <em>tar</em> archive (optionally compressed), with one of the content types      <code>application/octet-stream</code>, <code>application/tar</code>, <code>application/tar+gzip</code>, <code>application/x-gzip</code>, <code>application/x-tar</code>, <code>application/gzip</code></li>     <li>Separate files in a <code>multipart/form-data</code> request</li>     <li>A reference to the assets of another <em>plug</em> in the <code>copy</code> argument</li>   </ul>    The required <code>plug.json</code> json file contains the function metadata,   and must have a <code>runtime</code> attribute that is one of the supported <em>runtime</em>s    (see <code>GET /registry/v2/runtimes?functionType=plugs</code>).    For each <em>runtime</em> other files will be required or supported. "
            ),
        ] = None,
        content: Annotated[
            RequestContent | None,
            Field(
                description="The assets for a <em>plug</em> function can be provided as   <ul>     <li>A single <em>tar</em> archive (optionally compressed), with one of the content types      <code>application/octet-stream</code>, <code>application/tar</code>, <code>application/tar+gzip</code>, <code>application/x-gzip</code>, <code>application/x-tar</code>, <code>application/gzip</code></li>     <li>Separate files in a <code>multipart/form-data</code> request</li>     <li>A reference to the assets of another <em>plug</em> in the <code>copy</code> argument</li>   </ul>    The required <code>plug.json</code> json file contains the function metadata,   and must have a <code>runtime</code> attribute that is one of the supported <em>runtime</em>s    (see <code>GET /registry/v2/runtimes?functionType=plugs</code>).    For each <em>runtime</em> other files will be required or supported. "
            ),
        ] = None,
        files: Annotated[
            RequestFiles | None, Field(description="Multipart file upload")
        ] = None,
        query: CreateQuery | QueryParamTypes | None = None,
        raw_response: Literal[True],
        select_path: Literal["_not_used_"] = "_not_used_",
        response_type: Literal[None] = None,  # not used
        validate_request: StrictBool = True,
        headers: HeaderTypes | None = None,
        **kwargs,
    ) -> Response: ...

    @overload
    async def create(
        self,
        *,
        json: Annotated[
            StrictBytes | StrictStr | None,
            Field(
                description="The assets for a <em>plug</em> function can be provided as   <ul>     <li>A single <em>tar</em> archive (optionally compressed), with one of the content types      <code>application/octet-stream</code>, <code>application/tar</code>, <code>application/tar+gzip</code>, <code>application/x-gzip</code>, <code>application/x-tar</code>, <code>application/gzip</code></li>     <li>Separate files in a <code>multipart/form-data</code> request</li>     <li>A reference to the assets of another <em>plug</em> in the <code>copy</code> argument</li>   </ul>    The required <code>plug.json</code> json file contains the function metadata,   and must have a <code>runtime</code> attribute that is one of the supported <em>runtime</em>s    (see <code>GET /registry/v2/runtimes?functionType=plugs</code>).    For each <em>runtime</em> other files will be required or supported. "
            ),
        ] = None,
        content: Annotated[
            RequestContent | None,
            Field(
                description="The assets for a <em>plug</em> function can be provided as   <ul>     <li>A single <em>tar</em> archive (optionally compressed), with one of the content types      <code>application/octet-stream</code>, <code>application/tar</code>, <code>application/tar+gzip</code>, <code>application/x-gzip</code>, <code>application/x-tar</code>, <code>application/gzip</code></li>     <li>Separate files in a <code>multipart/form-data</code> request</li>     <li>A reference to the assets of another <em>plug</em> in the <code>copy</code> argument</li>   </ul>    The required <code>plug.json</code> json file contains the function metadata,   and must have a <code>runtime</code> attribute that is one of the supported <em>runtime</em>s    (see <code>GET /registry/v2/runtimes?functionType=plugs</code>).    For each <em>runtime</em> other files will be required or supported. "
            ),
        ] = None,
        files: Annotated[
            RequestFiles | None, Field(description="Multipart file upload")
        ] = None,
        query: CreateQuery | QueryParamTypes | None = None,
        raw_response: Literal[False] = False,
        select_path: str,
        response_type: Literal[None] = None,
        validate_request: StrictBool = True,
        headers: HeaderTypes | None = None,
        **kwargs,
    ) -> Model: ...

    @overload
    async def create(
        self,
        *,
        json: Annotated[
            StrictBytes | StrictStr | None,
            Field(
                description="The assets for a <em>plug</em> function can be provided as   <ul>     <li>A single <em>tar</em> archive (optionally compressed), with one of the content types      <code>application/octet-stream</code>, <code>application/tar</code>, <code>application/tar+gzip</code>, <code>application/x-gzip</code>, <code>application/x-tar</code>, <code>application/gzip</code></li>     <li>Separate files in a <code>multipart/form-data</code> request</li>     <li>A reference to the assets of another <em>plug</em> in the <code>copy</code> argument</li>   </ul>    The required <code>plug.json</code> json file contains the function metadata,   and must have a <code>runtime</code> attribute that is one of the supported <em>runtime</em>s    (see <code>GET /registry/v2/runtimes?functionType=plugs</code>).    For each <em>runtime</em> other files will be required or supported. "
            ),
        ] = None,
        content: Annotated[
            RequestContent | None,
            Field(
                description="The assets for a <em>plug</em> function can be provided as   <ul>     <li>A single <em>tar</em> archive (optionally compressed), with one of the content types      <code>application/octet-stream</code>, <code>application/tar</code>, <code>application/tar+gzip</code>, <code>application/x-gzip</code>, <code>application/x-tar</code>, <code>application/gzip</code></li>     <li>Separate files in a <code>multipart/form-data</code> request</li>     <li>A reference to the assets of another <em>plug</em> in the <code>copy</code> argument</li>   </ul>    The required <code>plug.json</code> json file contains the function metadata,   and must have a <code>runtime</code> attribute that is one of the supported <em>runtime</em>s    (see <code>GET /registry/v2/runtimes?functionType=plugs</code>).    For each <em>runtime</em> other files will be required or supported. "
            ),
        ] = None,
        files: Annotated[
            RequestFiles | None, Field(description="Multipart file upload")
        ] = None,
        query: CreateQuery | QueryParamTypes | None = None,
        raw_response: Literal[False] = False,
        select_path: str,
        response_type: T,
        validate_request: StrictBool = True,
        headers: HeaderTypes | None = None,
        **kwargs,
    ) -> T: ...

    async def create(
        self,
        *,
        json: Annotated[
            StrictBytes | StrictStr | None,
            Field(
                description="The assets for a <em>plug</em> function can be provided as   <ul>     <li>A single <em>tar</em> archive (optionally compressed), with one of the content types      <code>application/octet-stream</code>, <code>application/tar</code>, <code>application/tar+gzip</code>, <code>application/x-gzip</code>, <code>application/x-tar</code>, <code>application/gzip</code></li>     <li>Separate files in a <code>multipart/form-data</code> request</li>     <li>A reference to the assets of another <em>plug</em> in the <code>copy</code> argument</li>   </ul>    The required <code>plug.json</code> json file contains the function metadata,   and must have a <code>runtime</code> attribute that is one of the supported <em>runtime</em>s    (see <code>GET /registry/v2/runtimes?functionType=plugs</code>).    For each <em>runtime</em> other files will be required or supported. "
            ),
        ] = None,
        content: Annotated[
            RequestContent | None,
            Field(
                description="The assets for a <em>plug</em> function can be provided as   <ul>     <li>A single <em>tar</em> archive (optionally compressed), with one of the content types      <code>application/octet-stream</code>, <code>application/tar</code>, <code>application/tar+gzip</code>, <code>application/x-gzip</code>, <code>application/x-tar</code>, <code>application/gzip</code></li>     <li>Separate files in a <code>multipart/form-data</code> request</li>     <li>A reference to the assets of another <em>plug</em> in the <code>copy</code> argument</li>   </ul>    The required <code>plug.json</code> json file contains the function metadata,   and must have a <code>runtime</code> attribute that is one of the supported <em>runtime</em>s    (see <code>GET /registry/v2/runtimes?functionType=plugs</code>).    For each <em>runtime</em> other files will be required or supported. "
            ),
        ] = None,
        files: Annotated[
            RequestFiles | None, Field(description="Multipart file upload")
        ] = None,
        query: CreateQuery | QueryParamTypes | None = None,
        raw_response: StrictBool = False,
        select_path: str = "",
        response_type: T | None = None,
        validate_request: StrictBool = True,
        headers: HeaderTypes | None = None,
        **kwargs,
    ) -> PostPlugJobSyncResponseV2 | PostPlugJobAsyncResponseV2 | T | Response | Model:
        """Create Plug.

        Creates a new <em>plug</em> function by uploading its assets.      The assets for a <em>plug</em> function can be provided as   <ul>     <li>A single <em>tar</em> archive (optionally compressed), with one of the content types      <code>application/octet-stream</code>, <code>application/tar</code>, <code>application/tar+gzip</code>, <code>application/x-gzip</code>, <code>application/x-tar</code>, <code>application/gzip</code></li>     <li>Separate files in a <code>multipart/form-data</code> request</li>     <li>A reference to the assets of another <em>plug</em> in the <code>copy</code> argument</li>   </ul>    The required <code>plug.json</code> json file contains the function metadata,   and must have a <code>runtime</code> attribute that is one of the supported <em>runtime</em>s    (see <code>GET /registry/v2/runtimes?functionType=plugs</code>).    For each <em>runtime</em> other files will be required or supported.
        :param json: The assets for a <em>plug</em> function can be provided as   <ul>     <li>A single <em>tar</em> archive (optionally compressed), with one of the content types      <code>application/octet-stream</code>, <code>application/tar</code>, <code>application/tar+gzip</code>, <code>application/x-gzip</code>, <code>application/x-tar</code>, <code>application/gzip</code></li>     <li>Separate files in a <code>multipart/form-data</code> request</li>     <li>A reference to the assets of another <em>plug</em> in the <code>copy</code> argument</li>   </ul>    The required <code>plug.json</code> json file contains the function metadata,   and must have a <code>runtime</code> attribute that is one of the supported <em>runtime</em>s    (see <code>GET /registry/v2/runtimes?functionType=plugs</code>).    For each <em>runtime</em> other files will be required or supported.
        :type json: bytearray, optional
        :param content: The assets for a <em>plug</em> function can be provided as   <ul>     <li>A single <em>tar</em> archive (optionally compressed), with one of the content types      <code>application/octet-stream</code>, <code>application/tar</code>, <code>application/tar+gzip</code>, <code>application/x-gzip</code>, <code>application/x-tar</code>, <code>application/gzip</code></li>     <li>Separate files in a <code>multipart/form-data</code> request</li>     <li>A reference to the assets of another <em>plug</em> in the <code>copy</code> argument</li>   </ul>    The required <code>plug.json</code> json file contains the function metadata,   and must have a <code>runtime</code> attribute that is one of the supported <em>runtime</em>s    (see <code>GET /registry/v2/runtimes?functionType=plugs</code>).    For each <em>runtime</em> other files will be required or supported.
        :type content: ContentRequest, optional
        :param files: The files of a `content-type: multipart/form-data` request.
        :type files: FilesRequest, optional
        :param query: URL Query parameters.
        :type query: CreateQuery | QueryParamTypes, optional
        :param query['deploy'] (dict) <br> query.deploy (Query) : Indicates that a function should be _deployed_ when its assets are valid.  * If `true` (default), jobs to build and deploy the function will be initiated after it is checked that the assets are valid. Invalid assets lead to a validation error, and the function and its assets are not created or updated. * If `false`, the uploaded assets are stored and the function is created/updated in `registered` state. Asset validation errors are only returned as warning, and stored as `failureReason` on the function entity. Use an _asset update_ or _rebuild_ to initiate a build and deploy at a later stage.
        :type query['deploy']: bool
        :param query['author'] (dict) <br> query.author (Query) : Optionally changes the author metadata when updating a function.
        :type query['author']: str
        :param query['comment'] (dict) <br> query.comment (Query) : An optional user-specified comment corresponding to the operation.
        :type query['comment']: str
        :param query['scaleToZero'] (dict) <br> query.scale_to_zero (Query) : If set to <code>true</code>, after successful deployment, the deployed function will be scaled to zero. This saves computing resources when the function is not to be used immediately.
        :type query['scaleToZero']: bool
        :param query['deprecatePrevious'] (dict) <br> query.deprecate_previous (Query) : Set the cleanup policy used to automatically deprecate/delete previous versions.
        :type query['deprecatePrevious']: DeprecatePreviousPolicy
        :param query['dryRun'] (dict) <br> query.dry_run (Query) : If set to <code>true</code>, validates the deployment conditions, but does not change anything.
        :type query['dryRun']: bool
        :param query['async'] (dict) <br> query.var_async (Query) : Unless this is set to <code>false</code>, the server will start the required job actions asynchronously and return a <code>202</code> <em>Accepted</em> response. If <code>false</code> the request will block until the job actions are completed, or a timeout occurs.
        :type query['async']: bool
        :param query['version'] (dict) <br> query.version (Query) : If set, the function version will be an increment of the latest existing version that satisfies the `version` range. Note that this increment always takes precedence over an explicit `version` in the function manifest.
        :type query['version']: SemanticVersionRange
        :param query['name'] (dict) <br> query.name (Query) : If set, the value will be used as the function name instead of the one specified in the manifest.
        :type query['name']: str
        :param query['draft'] (dict) <br> query.draft (Query) : If set, the created function will be a draft function and its assets are still mutable. A build and deploy is initiated only in the case when all necessary assets are present and valid.
        :type query['draft']: bool
        :param query['runtime'] (dict) <br> query.runtime (Query) : If set, the created function will use the indicated runtime (latest version within specified range).  This takes precedence over the runtime specified in a function manifest (copied or from request body).
        :type query['runtime']: str
        :param query['copy'] (dict) <br> query.copy_from (Query) : Indicates the _source_ of initial assets for a _new function_.  When using this query parameter, the request body does not need to contain assets, but any assets in the request body will overwrite the copied assets.  #### Selection of _assets_ source  * If set as `<sourceName>[@<sourceVersionRange>]`, the _new function_ will be created with copied assets of the selected _source function_. * If set as `!example`, a `runtime` query parameter is required, and the _new function_ will be initialized with assets of the _runtime example_.  #### Selection of the _source function_  When `<sourceVersionRange>` is a range (or is not given), the latest _published_ version (in that range) is used.  If no _published_ version exists, the latest _draft_ is selected.  If no versions in the range exist, a `404` _Not Found_ error is returned.  #### The `name` of the _new function_  If a `name` is NOT specified (either as query parameter, or in an optional manifest asset in the request body), the `name` of the _new function_ will be that of the _source function_.  #### The `version` of the _new function_  When the _target_ and _source_ name are equal, the `version` query parameters is defaulted to `<sourceVersionRange>` (`~<sourceVersionRange>` when it's an exact version)  The version of the _new function_ will be: * If a `version` is NOT specified (either as query parameter, in an optional manifest asset, or as `<sourceVersionRange>` _default_)    * a **patch increment** (`<major>.<minor>.<patch>+1`) of the latest **existing version** with the target `name`    * **`1.0.0`** otherwise  * If a `version` is specified:    * the **lowest version** in that range **if no existing version** is in that range.    * an **increment** of the latest existing version, **at the highest level** (_major_,_minor_,_patch_) allowed by that range.    * otherwise, if all allowed versions already exist, a **`409` _Duplicate_ error** is raised.  #### Deployment overrides  The new function will use the deployment overrides of the copied function, unless a _manifest_ was specified in the request body.
        :type query['copy']: CreateWebscriptsCopyParameter
        :param raw_response: If true, return the http Response object instead of returning an api model object, or throwing an ApiError.
        :param select_path: Denotes the json path applied to the response object before returning it.
                Set it to the empty string `""` to receive the full response object.
        :param response_type: If specified, the response is parsed into an instance of the specified type.
        :param validate_request: If set to false, the request body and query parameters are NOT validated against the models in the service types package, even when available.
        :param headers: Header parameters for this request
        :type headers: dict, optional
        :param `**kwargs`: Additional parameters passed on to the http client.
            See below.
        :Keyword Arguments:
            * timeout: a single numeric timeout in seconds,
                or a tuple of _connect_, _read_, _write_ and _pool_ timeouts.
            * stream: if true, the response will be in streaming mode
            * cookies
            * extensions
            * auth
            * follow_redirects: bool

        :return: Returns the result object if the http request succeeded with status code '2XX'.
        :raises APIError: If the http request has a status code different from `2XX`. This
            object wraps both the http Response and any parsed data.
        """

        # path parameters
        path_params: Dict[str, str] = {}

        ## named body parameters
        body_args: Dict[str, Any] = {}
        if json is not None and validate_request:
            body_adapter = TypeAdapter(
                Annotated[
                    Optional[Union[StrictBytes, StrictStr]],
                    Field(
                        description="The assets for a <em>plug</em> function can be provided as   <ul>     <li>A single <em>tar</em> archive (optionally compressed), with one of the content types      <code>application/octet-stream</code>, <code>application/tar</code>, <code>application/tar+gzip</code>, <code>application/x-gzip</code>, <code>application/x-tar</code>, <code>application/gzip</code></li>     <li>Separate files in a <code>multipart/form-data</code> request</li>     <li>A reference to the assets of another <em>plug</em> in the <code>copy</code> argument</li>   </ul>    The required <code>plug.json</code> json file contains the function metadata,   and must have a <code>runtime</code> attribute that is one of the supported <em>runtime</em>s    (see <code>GET /registry/v2/runtimes?functionType=plugs</code>).    For each <em>runtime</em> other files will be required or supported. "
                    ),
                ]
            )
            json = body_adapter.validate_python(json)  # type: ignore # https://github.com/pydantic/pydantic/discussions/7094
        body_args["json"] = json
        body_args["content"] = content
        body_args["files"] = files

        # query parameters
        if query is not None and MODELS_AVAILABLE and validate_request:
            query = TypeAdapter(CreateQuery).validate_python(query)

        response_types_map: Dict[str, Any] = (
            {"2XX": response_type}
            if response_type is not None
            else {
                "201": PostPlugJobSyncResponseV2 if not select_path else Model,
                "202": PostPlugJobAsyncResponseV2 if not select_path else Model,
            }
        )
        non_200_response_types_map: Dict[str, Any] = {}
        response_types_map.update(non_200_response_types_map)

        ## peform request
        return await self.api_client.request(
            method="POST",
            resource_path="/registry/v2/plugs/",
            path_params=path_params,
            params=query,
            **body_args,
            headers=headers,
            **kwargs,
            response_type=response_types_map,
            select_path=select_path,
            raw_response=raw_response,
        )

    @overload
    async def delete_asset(
        self,
        name: Annotated[StrictStr, Field(description="The name of the function.")],
        version: Annotated[
            str, Field(strict=True, description="The version of the function.")
        ],
        wildcard: Annotated[
            StrictStr,
            Field(
                description="Full path or path prefix of the asset within the archive"
            ),
        ],
        *,
        query: DeleteAssetQuery | QueryParamTypes | None = None,
        raw_response: Literal[False] = False,
        select_path: Literal[""] = "",
        response_type: Literal[None] = None,
        validate_request: StrictBool = True,
        headers: HeaderTypes | None = None,
        **kwargs,
    ) -> PostPlugJobSyncResponseV2 | PostPlugJobAsyncResponseV2: ...

    @overload
    async def delete_asset(
        self,
        name: Annotated[StrictStr, Field(description="The name of the function.")],
        version: Annotated[
            str, Field(strict=True, description="The version of the function.")
        ],
        wildcard: Annotated[
            StrictStr,
            Field(
                description="Full path or path prefix of the asset within the archive"
            ),
        ],
        *,
        query: DeleteAssetQuery | QueryParamTypes | None = None,
        raw_response: Literal[False] = False,
        select_path: Literal[""] = "",
        response_type: T,
        validate_request: StrictBool = True,
        headers: HeaderTypes | None = None,
        **kwargs,
    ) -> T: ...

    @overload
    async def delete_asset(
        self,
        name: Annotated[StrictStr, Field(description="The name of the function.")],
        version: Annotated[
            str, Field(strict=True, description="The version of the function.")
        ],
        wildcard: Annotated[
            StrictStr,
            Field(
                description="Full path or path prefix of the asset within the archive"
            ),
        ],
        *,
        query: DeleteAssetQuery | QueryParamTypes | None = None,
        raw_response: Literal[True],
        select_path: Literal["_not_used_"] = "_not_used_",
        response_type: Literal[None] = None,  # not used
        validate_request: StrictBool = True,
        headers: HeaderTypes | None = None,
        **kwargs,
    ) -> Response: ...

    @overload
    async def delete_asset(
        self,
        name: Annotated[StrictStr, Field(description="The name of the function.")],
        version: Annotated[
            str, Field(strict=True, description="The version of the function.")
        ],
        wildcard: Annotated[
            StrictStr,
            Field(
                description="Full path or path prefix of the asset within the archive"
            ),
        ],
        *,
        query: DeleteAssetQuery | QueryParamTypes | None = None,
        raw_response: Literal[False] = False,
        select_path: str,
        response_type: Literal[None] = None,
        validate_request: StrictBool = True,
        headers: HeaderTypes | None = None,
        **kwargs,
    ) -> Model: ...

    @overload
    async def delete_asset(
        self,
        name: Annotated[StrictStr, Field(description="The name of the function.")],
        version: Annotated[
            str, Field(strict=True, description="The version of the function.")
        ],
        wildcard: Annotated[
            StrictStr,
            Field(
                description="Full path or path prefix of the asset within the archive"
            ),
        ],
        *,
        query: DeleteAssetQuery | QueryParamTypes | None = None,
        raw_response: Literal[False] = False,
        select_path: str,
        response_type: T,
        validate_request: StrictBool = True,
        headers: HeaderTypes | None = None,
        **kwargs,
    ) -> T: ...

    async def delete_asset(
        self,
        name: Annotated[StrictStr, Field(description="The name of the function.")],
        version: Annotated[
            str, Field(strict=True, description="The version of the function.")
        ],
        wildcard: Annotated[
            StrictStr,
            Field(
                description="Full path or path prefix of the asset within the archive"
            ),
        ],
        *,
        query: DeleteAssetQuery | QueryParamTypes | None = None,
        raw_response: StrictBool = False,
        select_path: str = "",
        response_type: T | None = None,
        validate_request: StrictBool = True,
        headers: HeaderTypes | None = None,
        **kwargs,
    ) -> PostPlugJobSyncResponseV2 | PostPlugJobAsyncResponseV2 | T | Response | Model:
        """Delete Plug Asset.

        Delete an asset from the plug's collection of existing assets.
        :param name: The name of the function. (required)
        :type name: str
        :param version: The version of the function. (required)
        :type version: str
        :param wildcard: Full path or path prefix of the asset within the archive (required)
        :type wildcard: str
        :param query: URL Query parameters.
        :type query: DeleteAssetQuery | QueryParamTypes, optional
        :param query['scaleToZero'] (dict) <br> query.scale_to_zero (Query) : If set to <code>true</code>, after successful deployment, the deployed function will be scaled to zero. This saves computing resources when the function is not to be used immediately.
        :type query['scaleToZero']: bool
        :param query['deploy'] (dict) <br> query.deploy (Query) : Indicates that a function should be _deployed_ when its assets are valid.  * If `true` (default), jobs to build and deploy the function will be initiated after it is checked that the assets are valid. Invalid assets lead to a validation error, and the function and its assets are not created or updated. * If `false`, the uploaded assets are stored and the function is created/updated in `registered` state. Asset validation errors are only returned as warning, and stored as `failureReason` on the function entity. Use an _asset update_ or _rebuild_ to initiate a build and deploy at a later stage.
        :type query['deploy']: bool
        :param query['chown'] (dict) <br> query.chown (Query) : If set, ownership of the draft function is transferred to the current user.
        :type query['chown']: bool
        :param query['comment'] (dict) <br> query.comment (Query) : An optional user-specified comment corresponding to the operation.
        :type query['comment']: str
        :param query['author'] (dict) <br> query.author (Query) : Optionally changes the author metadata when updating a function.
        :type query['author']: str
        :param query['async'] (dict) <br> query.var_async (Query) : Unless this is set to <code>false</code>, the server will start the required job actions asynchronously and return a <code>202</code> <em>Accepted</em> response. If <code>false</code> the request will block until the job actions are completed, or a timeout occurs.
        :type query['async']: bool
        :param raw_response: If true, return the http Response object instead of returning an api model object, or throwing an ApiError.
        :param select_path: Denotes the json path applied to the response object before returning it.
                Set it to the empty string `""` to receive the full response object.
        :param response_type: If specified, the response is parsed into an instance of the specified type.
        :param validate_request: If set to false, the request body and query parameters are NOT validated against the models in the service types package, even when available.
        :param headers: Header parameters for this request
        :type headers: dict, optional
        :param `**kwargs`: Additional parameters passed on to the http client.
            See below.
        :Keyword Arguments:
            * timeout: a single numeric timeout in seconds,
                or a tuple of _connect_, _read_, _write_ and _pool_ timeouts.
            * stream: if true, the response will be in streaming mode
            * cookies
            * extensions
            * auth
            * follow_redirects: bool

        :return: Returns the result object if the http request succeeded with status code '2XX'.
        :raises APIError: If the http request has a status code different from `2XX`. This
            object wraps both the http Response and any parsed data.
        """

        # path parameters
        path_params: Dict[str, str] = {
            "name": str(name),
            "version": str(version),
            "wildcard": str(wildcard),
        }

        ## named body parameters
        body_args: Dict[str, Any] = {}

        # query parameters
        if query is not None and MODELS_AVAILABLE and validate_request:
            query = TypeAdapter(DeleteAssetQuery).validate_python(query)

        response_types_map: Dict[str, Any] = (
            {"2XX": response_type}
            if response_type is not None
            else {
                "201": PostPlugJobSyncResponseV2 if not select_path else Model,
                "202": PostPlugJobAsyncResponseV2 if not select_path else Model,
            }
        )
        non_200_response_types_map: Dict[str, Any] = {
            "403": RegistryErrorResponse,
        }
        response_types_map.update(non_200_response_types_map)

        ## peform request
        return await self.api_client.request(
            method="DELETE",
            resource_path="/registry/v2/plugs/{name}/versions/{version}/content/{wildcard}",
            path_params=path_params,
            params=query,
            **body_args,
            headers=headers,
            **kwargs,
            response_type=response_types_map,
            select_path=select_path,
            raw_response=raw_response,
        )

    @overload
    async def get_archive(
        self,
        name: Annotated[StrictStr, Field(description="The name of the function.")],
        version: Annotated[
            str, Field(strict=True, description="The version of the function.")
        ],
        *,
        query: GetArchiveQuery | QueryParamTypes | None = None,
        raw_response: Literal[False] = False,
        select_path: Literal[""] = "",
        response_type: Literal[None] = None,
        validate_request: StrictBool = True,
        headers: HeaderTypes | None = None,
        **kwargs,
    ) -> bytearray: ...

    @overload
    async def get_archive(
        self,
        name: Annotated[StrictStr, Field(description="The name of the function.")],
        version: Annotated[
            str, Field(strict=True, description="The version of the function.")
        ],
        *,
        query: GetArchiveQuery | QueryParamTypes | None = None,
        raw_response: Literal[False] = False,
        select_path: Literal[""] = "",
        response_type: T,
        validate_request: StrictBool = True,
        headers: HeaderTypes | None = None,
        **kwargs,
    ) -> T: ...

    @overload
    async def get_archive(
        self,
        name: Annotated[StrictStr, Field(description="The name of the function.")],
        version: Annotated[
            str, Field(strict=True, description="The version of the function.")
        ],
        *,
        query: GetArchiveQuery | QueryParamTypes | None = None,
        raw_response: Literal[True],
        select_path: Literal["_not_used_"] = "_not_used_",
        response_type: Literal[None] = None,  # not used
        validate_request: StrictBool = True,
        headers: HeaderTypes | None = None,
        **kwargs,
    ) -> Response: ...

    @overload
    async def get_archive(
        self,
        name: Annotated[StrictStr, Field(description="The name of the function.")],
        version: Annotated[
            str, Field(strict=True, description="The version of the function.")
        ],
        *,
        query: GetArchiveQuery | QueryParamTypes | None = None,
        raw_response: Literal[False] = False,
        select_path: str,
        response_type: Literal[None] = None,
        validate_request: StrictBool = True,
        headers: HeaderTypes | None = None,
        **kwargs,
    ) -> Model: ...

    @overload
    async def get_archive(
        self,
        name: Annotated[StrictStr, Field(description="The name of the function.")],
        version: Annotated[
            str, Field(strict=True, description="The version of the function.")
        ],
        *,
        query: GetArchiveQuery | QueryParamTypes | None = None,
        raw_response: Literal[False] = False,
        select_path: str,
        response_type: T,
        validate_request: StrictBool = True,
        headers: HeaderTypes | None = None,
        **kwargs,
    ) -> T: ...

    async def get_archive(
        self,
        name: Annotated[StrictStr, Field(description="The name of the function.")],
        version: Annotated[
            str, Field(strict=True, description="The version of the function.")
        ],
        *,
        query: GetArchiveQuery | QueryParamTypes | None = None,
        raw_response: StrictBool = False,
        select_path: str = "",
        response_type: T | None = None,
        validate_request: StrictBool = True,
        headers: HeaderTypes | None = None,
        **kwargs,
    ) -> bytearray | T | Response | Model:
        """Get Plug Archive.

        Get the specification archive of a plug.
        :param name: The name of the function. (required)
        :type name: str
        :param version: The version of the function. (required)
        :type version: str
        :param query: URL Query parameters.
        :type query: GetArchiveQuery | QueryParamTypes, optional
        :param query['ls'] (dict) <br> query.ls (Query) : If set to `true`, the result will be a listing of the files in the asset, annotated with metadata and validation report from the asset conditions of the functions runtime.
        :type query['ls']: bool
        :param raw_response: If true, return the http Response object instead of returning an api model object, or throwing an ApiError.
        :param select_path: Denotes the json path applied to the response object before returning it.
                Set it to the empty string `""` to receive the full response object.
        :param response_type: If specified, the response is parsed into an instance of the specified type.
        :param validate_request: If set to false, the request body and query parameters are NOT validated against the models in the service types package, even when available.
        :param headers: Header parameters for this request
        :type headers: dict, optional
        :param `**kwargs`: Additional parameters passed on to the http client.
            See below.
        :Keyword Arguments:
            * timeout: a single numeric timeout in seconds,
                or a tuple of _connect_, _read_, _write_ and _pool_ timeouts.
            * stream: if true, the response will be in streaming mode
            * cookies
            * extensions
            * auth
            * follow_redirects: bool

        :return: Returns the result object if the http request succeeded with status code '2XX'.
        :raises APIError: If the http request has a status code different from `2XX`. This
            object wraps both the http Response and any parsed data.
        """

        # path parameters
        path_params: Dict[str, str] = {
            "name": str(name),
            "version": str(version),
        }

        ## named body parameters
        body_args: Dict[str, Any] = {}

        # query parameters
        if query is not None and MODELS_AVAILABLE and validate_request:
            query = TypeAdapter(GetArchiveQuery).validate_python(query)

        response_types_map: Dict[str, Any] = (
            {"2XX": response_type}
            if response_type is not None
            else {
                "200": bytearray if not select_path else Model,
            }
        )
        non_200_response_types_map: Dict[str, Any] = {}
        response_types_map.update(non_200_response_types_map)

        ## peform request
        return await self.api_client.request(
            method="GET",
            resource_path="/registry/v2/plugs/{name}/versions/{version}/content",
            path_params=path_params,
            params=query,
            **body_args,
            headers=headers,
            **kwargs,
            response_type=response_types_map,
            select_path=select_path,
            raw_response=raw_response,
        )

    @overload
    async def get_asset(
        self,
        name: Annotated[StrictStr, Field(description="The name of the function.")],
        version: Annotated[
            str, Field(strict=True, description="The version of the function.")
        ],
        wildcard: Annotated[
            StrictStr,
            Field(
                description="Full path or path prefix of the asset within the archive"
            ),
        ],
        *,
        query: GetAssetQuery | QueryParamTypes | None = None,
        raw_response: Literal[False] = False,
        select_path: Literal[""] = "",
        response_type: Literal[None] = None,
        validate_request: StrictBool = True,
        headers: HeaderTypes | None = None,
        **kwargs,
    ) -> bytearray: ...

    @overload
    async def get_asset(
        self,
        name: Annotated[StrictStr, Field(description="The name of the function.")],
        version: Annotated[
            str, Field(strict=True, description="The version of the function.")
        ],
        wildcard: Annotated[
            StrictStr,
            Field(
                description="Full path or path prefix of the asset within the archive"
            ),
        ],
        *,
        query: GetAssetQuery | QueryParamTypes | None = None,
        raw_response: Literal[False] = False,
        select_path: Literal[""] = "",
        response_type: T,
        validate_request: StrictBool = True,
        headers: HeaderTypes | None = None,
        **kwargs,
    ) -> T: ...

    @overload
    async def get_asset(
        self,
        name: Annotated[StrictStr, Field(description="The name of the function.")],
        version: Annotated[
            str, Field(strict=True, description="The version of the function.")
        ],
        wildcard: Annotated[
            StrictStr,
            Field(
                description="Full path or path prefix of the asset within the archive"
            ),
        ],
        *,
        query: GetAssetQuery | QueryParamTypes | None = None,
        raw_response: Literal[True],
        select_path: Literal["_not_used_"] = "_not_used_",
        response_type: Literal[None] = None,  # not used
        validate_request: StrictBool = True,
        headers: HeaderTypes | None = None,
        **kwargs,
    ) -> Response: ...

    @overload
    async def get_asset(
        self,
        name: Annotated[StrictStr, Field(description="The name of the function.")],
        version: Annotated[
            str, Field(strict=True, description="The version of the function.")
        ],
        wildcard: Annotated[
            StrictStr,
            Field(
                description="Full path or path prefix of the asset within the archive"
            ),
        ],
        *,
        query: GetAssetQuery | QueryParamTypes | None = None,
        raw_response: Literal[False] = False,
        select_path: str,
        response_type: Literal[None] = None,
        validate_request: StrictBool = True,
        headers: HeaderTypes | None = None,
        **kwargs,
    ) -> Model: ...

    @overload
    async def get_asset(
        self,
        name: Annotated[StrictStr, Field(description="The name of the function.")],
        version: Annotated[
            str, Field(strict=True, description="The version of the function.")
        ],
        wildcard: Annotated[
            StrictStr,
            Field(
                description="Full path or path prefix of the asset within the archive"
            ),
        ],
        *,
        query: GetAssetQuery | QueryParamTypes | None = None,
        raw_response: Literal[False] = False,
        select_path: str,
        response_type: T,
        validate_request: StrictBool = True,
        headers: HeaderTypes | None = None,
        **kwargs,
    ) -> T: ...

    async def get_asset(
        self,
        name: Annotated[StrictStr, Field(description="The name of the function.")],
        version: Annotated[
            str, Field(strict=True, description="The version of the function.")
        ],
        wildcard: Annotated[
            StrictStr,
            Field(
                description="Full path or path prefix of the asset within the archive"
            ),
        ],
        *,
        query: GetAssetQuery | QueryParamTypes | None = None,
        raw_response: StrictBool = False,
        select_path: str = "",
        response_type: T | None = None,
        validate_request: StrictBool = True,
        headers: HeaderTypes | None = None,
        **kwargs,
    ) -> bytearray | T | Response | Model:
        """Get File From Plug Archive.

        Get a file from the specification archive of a plug.
        :param name: The name of the function. (required)
        :type name: str
        :param version: The version of the function. (required)
        :type version: str
        :param wildcard: Full path or path prefix of the asset within the archive (required)
        :type wildcard: str
        :param query: URL Query parameters.
        :type query: GetAssetQuery | QueryParamTypes, optional
        :param query['ls'] (dict) <br> query.ls (Query) : If set to `true`, the result will be a listing of the files in the asset, annotated with metadata and validation report from the asset conditions of the functions runtime.
        :type query['ls']: bool
        :param raw_response: If true, return the http Response object instead of returning an api model object, or throwing an ApiError.
        :param select_path: Denotes the json path applied to the response object before returning it.
                Set it to the empty string `""` to receive the full response object.
        :param response_type: If specified, the response is parsed into an instance of the specified type.
        :param validate_request: If set to false, the request body and query parameters are NOT validated against the models in the service types package, even when available.
        :param headers: Header parameters for this request
        :type headers: dict, optional
        :param `**kwargs`: Additional parameters passed on to the http client.
            See below.
        :Keyword Arguments:
            * timeout: a single numeric timeout in seconds,
                or a tuple of _connect_, _read_, _write_ and _pool_ timeouts.
            * stream: if true, the response will be in streaming mode
            * cookies
            * extensions
            * auth
            * follow_redirects: bool

        :return: Returns the result object if the http request succeeded with status code '2XX'.
        :raises APIError: If the http request has a status code different from `2XX`. This
            object wraps both the http Response and any parsed data.
        """

        # path parameters
        path_params: Dict[str, str] = {
            "name": str(name),
            "version": str(version),
            "wildcard": str(wildcard),
        }

        ## named body parameters
        body_args: Dict[str, Any] = {}

        # query parameters
        if query is not None and MODELS_AVAILABLE and validate_request:
            query = TypeAdapter(GetAssetQuery).validate_python(query)

        response_types_map: Dict[str, Any] = (
            {"2XX": response_type}
            if response_type is not None
            else {
                "200": bytearray if not select_path else Model,
            }
        )
        non_200_response_types_map: Dict[str, Any] = {}
        response_types_map.update(non_200_response_types_map)

        ## peform request
        return await self.api_client.request(
            method="GET",
            resource_path="/registry/v2/plugs/{name}/versions/{version}/content/{wildcard}",
            path_params=path_params,
            params=query,
            **body_args,
            headers=headers,
            **kwargs,
            response_type=response_types_map,
            select_path=select_path,
            raw_response=raw_response,
        )

    @overload
    async def get_latest(
        self,
        name: Annotated[StrictStr, Field(description="The name of the function.")],
        *,
        query: GetLatestQuery | QueryParamTypes | None = None,
        raw_response: Literal[False] = False,
        select_path: Literal[""] = "",
        response_type: Literal[None] = None,
        validate_request: StrictBool = True,
        headers: HeaderTypes | None = None,
        **kwargs,
    ) -> GetPlugResponseV2: ...

    @overload
    async def get_latest(
        self,
        name: Annotated[StrictStr, Field(description="The name of the function.")],
        *,
        query: GetLatestQuery | QueryParamTypes | None = None,
        raw_response: Literal[False] = False,
        select_path: Literal[""] = "",
        response_type: T,
        validate_request: StrictBool = True,
        headers: HeaderTypes | None = None,
        **kwargs,
    ) -> T: ...

    @overload
    async def get_latest(
        self,
        name: Annotated[StrictStr, Field(description="The name of the function.")],
        *,
        query: GetLatestQuery | QueryParamTypes | None = None,
        raw_response: Literal[True],
        select_path: Literal["_not_used_"] = "_not_used_",
        response_type: Literal[None] = None,  # not used
        validate_request: StrictBool = True,
        headers: HeaderTypes | None = None,
        **kwargs,
    ) -> Response: ...

    @overload
    async def get_latest(
        self,
        name: Annotated[StrictStr, Field(description="The name of the function.")],
        *,
        query: GetLatestQuery | QueryParamTypes | None = None,
        raw_response: Literal[False] = False,
        select_path: str,
        response_type: Literal[None] = None,
        validate_request: StrictBool = True,
        headers: HeaderTypes | None = None,
        **kwargs,
    ) -> Model: ...

    @overload
    async def get_latest(
        self,
        name: Annotated[StrictStr, Field(description="The name of the function.")],
        *,
        query: GetLatestQuery | QueryParamTypes | None = None,
        raw_response: Literal[False] = False,
        select_path: str,
        response_type: T,
        validate_request: StrictBool = True,
        headers: HeaderTypes | None = None,
        **kwargs,
    ) -> T: ...

    async def get_latest(
        self,
        name: Annotated[StrictStr, Field(description="The name of the function.")],
        *,
        query: GetLatestQuery | QueryParamTypes | None = None,
        raw_response: StrictBool = False,
        select_path: str = "",
        response_type: T | None = None,
        validate_request: StrictBool = True,
        headers: HeaderTypes | None = None,
        **kwargs,
    ) -> GetPlugResponseV2 | T | Response | Model:
        """Get Latest Plug Version.

        Fetch the latest version of a <em>plug</em>.    By default, the result shows the latest non-deprecated, non-draft version.   If there is no such version, the latest deprecated or the latest draft version is returned, with the former taking precedence.       Use the boolean query parameters <code>includeDeprecated</code> or <code>includeDraft</code> to change this behaviour:   <ul>   <li><code>includeDeprecated=true</code>: do not prefer non-deprecated versions as a latest version: if the latest version is a deprecated one, it will be shown, even if there are older non-deprecated versions.</li>   <li><code>includeDraft=true</code>: do not prefer non-draft versions as a latest version: if the latest version is a draft, it will be shown, even if there are older non-draft versions.</li>   </ul>     The returned <em>plug version</em> will contain a link to its   latest _draft_ or latest _published_ version (if existing and different).
        :param name: The name of the function. (required)
        :type name: str
        :param query: URL Query parameters.
        :type query: GetLatestQuery | QueryParamTypes, optional
        :param query['type'] (dict) <br> query.type (Query) : If set, filters on the type of plug.
        :type query['type']: PlugType
        :param query['includeDraft'] (dict) <br> query.include_draft (Query) : Configures the inclusion of _draft_ versions when selecting latest versions per name. By default, draft versions are only considered when no other versions are available. If set to `true`, draft versions are **included**. If set to `false`, draft versions are **excluded**.
        :type query['includeDraft']: bool
        :param query['includeDeprecated'] (dict) <br> query.include_deprecated (Query) : Configures the inclusion of _deprecated_ versions when selecting latest versions per name. By default, deprecated versions are only considered when no other versions are available. If set to `true`, deprecated versions are **included**. If set to `false`, deprecated versions are **excluded**.
        :type query['includeDeprecated']: bool
        :param raw_response: If true, return the http Response object instead of returning an api model object, or throwing an ApiError.
        :param select_path: Denotes the json path applied to the response object before returning it.
                Set it to the empty string `""` to receive the full response object.
        :param response_type: If specified, the response is parsed into an instance of the specified type.
        :param validate_request: If set to false, the request body and query parameters are NOT validated against the models in the service types package, even when available.
        :param headers: Header parameters for this request
        :type headers: dict, optional
        :param `**kwargs`: Additional parameters passed on to the http client.
            See below.
        :Keyword Arguments:
            * timeout: a single numeric timeout in seconds,
                or a tuple of _connect_, _read_, _write_ and _pool_ timeouts.
            * stream: if true, the response will be in streaming mode
            * cookies
            * extensions
            * auth
            * follow_redirects: bool

        :return: Returns the result object if the http request succeeded with status code '2XX'.
        :raises APIError: If the http request has a status code different from `2XX`. This
            object wraps both the http Response and any parsed data.
        """

        # path parameters
        path_params: Dict[str, str] = {
            "name": str(name),
        }

        ## named body parameters
        body_args: Dict[str, Any] = {}

        # query parameters
        if query is not None and MODELS_AVAILABLE and validate_request:
            query = TypeAdapter(GetLatestQuery).validate_python(query)

        response_types_map: Dict[str, Any] = (
            {"2XX": response_type}
            if response_type is not None
            else {
                "200": GetPlugResponseV2 if not select_path else Model,
            }
        )
        non_200_response_types_map: Dict[str, Any] = {}
        response_types_map.update(non_200_response_types_map)

        ## peform request
        return await self.api_client.request(
            method="GET",
            resource_path="/registry/v2/plugs/{name}",
            path_params=path_params,
            params=query,
            **body_args,
            headers=headers,
            **kwargs,
            response_type=response_types_map,
            select_path=select_path,
            raw_response=raw_response,
        )

    @overload
    async def get(
        self,
        name: Annotated[StrictStr, Field(description="The name of the function.")],
        version: Annotated[
            str, Field(strict=True, description="The version of the function.")
        ],
        *,
        query: GetQuery | QueryParamTypes | None = None,
        raw_response: Literal[False] = False,
        select_path: Literal[""] = "",
        response_type: Literal[None] = None,
        validate_request: StrictBool = True,
        headers: HeaderTypes | None = None,
        **kwargs,
    ) -> GetPlugResponseV2: ...

    @overload
    async def get(
        self,
        name: Annotated[StrictStr, Field(description="The name of the function.")],
        version: Annotated[
            str, Field(strict=True, description="The version of the function.")
        ],
        *,
        query: GetQuery | QueryParamTypes | None = None,
        raw_response: Literal[False] = False,
        select_path: Literal[""] = "",
        response_type: T,
        validate_request: StrictBool = True,
        headers: HeaderTypes | None = None,
        **kwargs,
    ) -> T: ...

    @overload
    async def get(
        self,
        name: Annotated[StrictStr, Field(description="The name of the function.")],
        version: Annotated[
            str, Field(strict=True, description="The version of the function.")
        ],
        *,
        query: GetQuery | QueryParamTypes | None = None,
        raw_response: Literal[True],
        select_path: Literal["_not_used_"] = "_not_used_",
        response_type: Literal[None] = None,  # not used
        validate_request: StrictBool = True,
        headers: HeaderTypes | None = None,
        **kwargs,
    ) -> Response: ...

    @overload
    async def get(
        self,
        name: Annotated[StrictStr, Field(description="The name of the function.")],
        version: Annotated[
            str, Field(strict=True, description="The version of the function.")
        ],
        *,
        query: GetQuery | QueryParamTypes | None = None,
        raw_response: Literal[False] = False,
        select_path: str,
        response_type: Literal[None] = None,
        validate_request: StrictBool = True,
        headers: HeaderTypes | None = None,
        **kwargs,
    ) -> Model: ...

    @overload
    async def get(
        self,
        name: Annotated[StrictStr, Field(description="The name of the function.")],
        version: Annotated[
            str, Field(strict=True, description="The version of the function.")
        ],
        *,
        query: GetQuery | QueryParamTypes | None = None,
        raw_response: Literal[False] = False,
        select_path: str,
        response_type: T,
        validate_request: StrictBool = True,
        headers: HeaderTypes | None = None,
        **kwargs,
    ) -> T: ...

    async def get(
        self,
        name: Annotated[StrictStr, Field(description="The name of the function.")],
        version: Annotated[
            str, Field(strict=True, description="The version of the function.")
        ],
        *,
        query: GetQuery | QueryParamTypes | None = None,
        raw_response: StrictBool = False,
        select_path: str = "",
        response_type: T | None = None,
        validate_request: StrictBool = True,
        headers: HeaderTypes | None = None,
        **kwargs,
    ) -> GetPlugResponseV2 | T | Response | Model:
        """Get Plug Version.

        Get a specific version of a plug.
        :param name: The name of the function. (required)
        :type name: str
        :param version: The version of the function. (required)
        :type version: str
        :param query: URL Query parameters.
        :type query: GetQuery | QueryParamTypes, optional
        :param raw_response: If true, return the http Response object instead of returning an api model object, or throwing an ApiError.
        :param select_path: Denotes the json path applied to the response object before returning it.
                Set it to the empty string `""` to receive the full response object.
        :param response_type: If specified, the response is parsed into an instance of the specified type.
        :param validate_request: If set to false, the request body and query parameters are NOT validated against the models in the service types package, even when available.
        :param headers: Header parameters for this request
        :type headers: dict, optional
        :param `**kwargs`: Additional parameters passed on to the http client.
            See below.
        :Keyword Arguments:
            * timeout: a single numeric timeout in seconds,
                or a tuple of _connect_, _read_, _write_ and _pool_ timeouts.
            * stream: if true, the response will be in streaming mode
            * cookies
            * extensions
            * auth
            * follow_redirects: bool

        :return: Returns the result object if the http request succeeded with status code '2XX'.
        :raises APIError: If the http request has a status code different from `2XX`. This
            object wraps both the http Response and any parsed data.
        """

        # path parameters
        path_params: Dict[str, str] = {
            "name": str(name),
            "version": str(version),
        }

        ## named body parameters
        body_args: Dict[str, Any] = {}

        # query parameters
        if query is not None and MODELS_AVAILABLE and validate_request:
            query = TypeAdapter(GetQuery).validate_python(query)

        response_types_map: Dict[str, Any] = (
            {"2XX": response_type}
            if response_type is not None
            else {
                "200": GetPlugResponseV2 if not select_path else Model,
            }
        )
        non_200_response_types_map: Dict[str, Any] = {}
        response_types_map.update(non_200_response_types_map)

        ## peform request
        return await self.api_client.request(
            method="GET",
            resource_path="/registry/v2/plugs/{name}/versions/{version}",
            path_params=path_params,
            params=query,
            **body_args,
            headers=headers,
            **kwargs,
            response_type=response_types_map,
            select_path=select_path,
            raw_response=raw_response,
        )

    @overload
    async def jobs(
        self,
        name: Annotated[StrictStr, Field(description="The name of the function.")],
        version: Annotated[
            str, Field(strict=True, description="The version of the function.")
        ],
        *,
        query: JobsQuery | QueryParamTypes | None = None,
        raw_response: Literal[False] = False,
        select_path: Literal[""] = "",
        response_type: Literal[None] = None,
        validate_request: StrictBool = True,
        headers: HeaderTypes | None = None,
        **kwargs,
    ) -> JobsForPlugResponseV2: ...

    @overload
    async def jobs(
        self,
        name: Annotated[StrictStr, Field(description="The name of the function.")],
        version: Annotated[
            str, Field(strict=True, description="The version of the function.")
        ],
        *,
        query: JobsQuery | QueryParamTypes | None = None,
        raw_response: Literal[False] = False,
        select_path: Literal[""] = "",
        response_type: T,
        validate_request: StrictBool = True,
        headers: HeaderTypes | None = None,
        **kwargs,
    ) -> T: ...

    @overload
    async def jobs(
        self,
        name: Annotated[StrictStr, Field(description="The name of the function.")],
        version: Annotated[
            str, Field(strict=True, description="The version of the function.")
        ],
        *,
        query: JobsQuery | QueryParamTypes | None = None,
        raw_response: Literal[True],
        select_path: Literal["_not_used_"] = "_not_used_",
        response_type: Literal[None] = None,  # not used
        validate_request: StrictBool = True,
        headers: HeaderTypes | None = None,
        **kwargs,
    ) -> Response: ...

    @overload
    async def jobs(
        self,
        name: Annotated[StrictStr, Field(description="The name of the function.")],
        version: Annotated[
            str, Field(strict=True, description="The version of the function.")
        ],
        *,
        query: JobsQuery | QueryParamTypes | None = None,
        raw_response: Literal[False] = False,
        select_path: str,
        response_type: Literal[None] = None,
        validate_request: StrictBool = True,
        headers: HeaderTypes | None = None,
        **kwargs,
    ) -> Model: ...

    @overload
    async def jobs(
        self,
        name: Annotated[StrictStr, Field(description="The name of the function.")],
        version: Annotated[
            str, Field(strict=True, description="The version of the function.")
        ],
        *,
        query: JobsQuery | QueryParamTypes | None = None,
        raw_response: Literal[False] = False,
        select_path: str,
        response_type: T,
        validate_request: StrictBool = True,
        headers: HeaderTypes | None = None,
        **kwargs,
    ) -> T: ...

    async def jobs(
        self,
        name: Annotated[StrictStr, Field(description="The name of the function.")],
        version: Annotated[
            str, Field(strict=True, description="The version of the function.")
        ],
        *,
        query: JobsQuery | QueryParamTypes | None = None,
        raw_response: StrictBool = False,
        select_path: str = "",
        response_type: T | None = None,
        validate_request: StrictBool = True,
        headers: HeaderTypes | None = None,
        **kwargs,
    ) -> JobsForPlugResponseV2 | T | Response | Model:
        """List Plug Jobs.

        List the ongoing and completed operations on a specific plug.
        :param name: The name of the function. (required)
        :type name: str
        :param version: The version of the function. (required)
        :type version: str
        :param query: URL Query parameters.
        :type query: JobsQuery | QueryParamTypes, optional
        :param query['limit'] (dict) <br> query.limit (Query) : The maximum number of items to be return from this query. Has a deployment-defined default and maximum value.
        :type query['limit']: float
        :param query['type'] (dict) <br> query.type (Query) : Filter on job type
        :type query['type']: List[JobTypeSchema]
        :param query['state'] (dict) <br> query.state (Query) : Filter on job state
        :type query['state']: List[JobStateResult]
        :param query['functionType'] (dict) <br> query.function_type (Query) : Filter on function type
        :type query['functionType']: List[FunctionType]
        :param query['createdBefore'] (dict) <br> query.created_before (Query) : Filter on jobs that created before the given timestamp or age
        :type query['createdBefore']: TimestampSpec
        :param query['createdAfter'] (dict) <br> query.created_after (Query) : Filter on jobs that created after the given timestamp or age
        :type query['createdAfter']: TimestampSpec
        :param raw_response: If true, return the http Response object instead of returning an api model object, or throwing an ApiError.
        :param select_path: Denotes the json path applied to the response object before returning it.
                Set it to the empty string `""` to receive the full response object.
        :param response_type: If specified, the response is parsed into an instance of the specified type.
        :param validate_request: If set to false, the request body and query parameters are NOT validated against the models in the service types package, even when available.
        :param headers: Header parameters for this request
        :type headers: dict, optional
        :param `**kwargs`: Additional parameters passed on to the http client.
            See below.
        :Keyword Arguments:
            * timeout: a single numeric timeout in seconds,
                or a tuple of _connect_, _read_, _write_ and _pool_ timeouts.
            * stream: if true, the response will be in streaming mode
            * cookies
            * extensions
            * auth
            * follow_redirects: bool

        :return: Returns the result object if the http request succeeded with status code '2XX'.
        :raises APIError: If the http request has a status code different from `2XX`. This
            object wraps both the http Response and any parsed data.
        """

        # path parameters
        path_params: Dict[str, str] = {
            "name": str(name),
            "version": str(version),
        }

        ## named body parameters
        body_args: Dict[str, Any] = {}

        # query parameters
        if query is not None and MODELS_AVAILABLE and validate_request:
            query = TypeAdapter(JobsQuery).validate_python(query)

        response_types_map: Dict[str, Any] = (
            {"2XX": response_type}
            if response_type is not None
            else {
                "200": JobsForPlugResponseV2 if not select_path else Model,
            }
        )
        non_200_response_types_map: Dict[str, Any] = {}
        response_types_map.update(non_200_response_types_map)

        ## peform request
        return await self.api_client.request(
            method="GET",
            resource_path="/registry/v2/plugs/{name}/versions/{version}/jobs",
            path_params=path_params,
            params=query,
            **body_args,
            headers=headers,
            **kwargs,
            response_type=response_types_map,
            select_path=select_path,
            raw_response=raw_response,
        )

    @overload
    async def list(
        self,
        *,
        query: ListQuery | QueryParamTypes | None = None,
        raw_response: Literal[False] = False,
        select_path: Literal[""] = "",
        response_type: Literal[None] = None,
        validate_request: StrictBool = True,
        headers: HeaderTypes | None = None,
        **kwargs,
    ) -> LatestPlugsResponseV2: ...

    @overload
    async def list(
        self,
        *,
        query: ListQuery | QueryParamTypes | None = None,
        raw_response: Literal[False] = False,
        select_path: Literal[""] = "",
        response_type: T,
        validate_request: StrictBool = True,
        headers: HeaderTypes | None = None,
        **kwargs,
    ) -> T: ...

    @overload
    async def list(
        self,
        *,
        query: ListQuery | QueryParamTypes | None = None,
        raw_response: Literal[True],
        select_path: Literal["_not_used_"] = "_not_used_",
        response_type: Literal[None] = None,  # not used
        validate_request: StrictBool = True,
        headers: HeaderTypes | None = None,
        **kwargs,
    ) -> Response: ...

    @overload
    async def list(
        self,
        *,
        query: ListQuery | QueryParamTypes | None = None,
        raw_response: Literal[False] = False,
        select_path: str,
        response_type: Literal[None] = None,
        validate_request: StrictBool = True,
        headers: HeaderTypes | None = None,
        **kwargs,
    ) -> Model: ...

    @overload
    async def list(
        self,
        *,
        query: ListQuery | QueryParamTypes | None = None,
        raw_response: Literal[False] = False,
        select_path: str,
        response_type: T,
        validate_request: StrictBool = True,
        headers: HeaderTypes | None = None,
        **kwargs,
    ) -> T: ...

    async def list(
        self,
        *,
        query: ListQuery | QueryParamTypes | None = None,
        raw_response: StrictBool = False,
        select_path: str = "",
        response_type: T | None = None,
        validate_request: StrictBool = True,
        headers: HeaderTypes | None = None,
        **kwargs,
    ) -> LatestPlugsResponseV2 | T | Response | Model:
        """List Plugs.

        List the (latest) versions of available <em>plugs</em>.  ### List Latest Plug Versions By default, the result includes the latest non-deprecated, non-draft version for each <em>plug</em> name. If there is no such version, the latest _deprecated_ or the latest _draft_ version is included, with the former taking precedence.     Use the boolean query parameters <code>includeDeprecated</code> or <code>includeDraft</code> to change this behaviour:   <ul>   <li><code>includeDeprecated=true</code>: do not prefer non-deprecated versions as a latest version: if the latest version is a deprecated one, it will be shown, even if there are older non-deprecated versions.</li>   <li><code>includeDraft=true</code>: do not prefer non-draft versions as a latest version: if the latest version is a draft, it will be shown, even if there are older non-draft versions.</li>   </ul>   As long as no version filters are used, each listed <em>plug version</em> contains representations of the latest draft (`entities[]._links.draft`)  or latest published (`entities[]._links.published`) version (if existing and different).   Use the query parameter `showRelated` to include only a link (default `showRelated=link`) or a full representation (`showRelated=embed`).  ### List Latest Plug Versions (with filter) When any of the _version filter_ query parameters are used, the response contains the _latest_ version per named <em>plug</em> that satisfy the filters, but **without links**.  ### List All Plug Versions When using `latest=false` (default when using the `namedVersion` filter), the listing contains _all_  <em>plugs</em> versions that satisfy the query, possibly multiple versions per named <em>plugs</em>. No HAL links are provided.  #### Filter on _status_ By default <em>plug versions</em> with status  `undeployed` are **excluded** in all cases. Use the _version filter_ `status` to include/exclude a status from the results. By example,  > `?status=any&includeDeprecated=true&includeDraft=true&latest=false`  will list _ALL_ versions known to the function registry.  #### Version filter parameters The following query parameters are _version filters_ for the <em>plug</em> listing: > `version`, `status`, `runtimeVersion`, `createdBy`, `createdBefore`, `createdAfter`, `updatedBy`, `updatedBefore`, `updatedAfter`, `nameVersion`, `deprecated`, `draft`, `tags`
        :param query: URL Query parameters.
        :type query: ListQuery | QueryParamTypes, optional
        :param query['tags'] (dict) <br> query.tags (Query) : Filter on the tags of the item. Can be a single tag, or a list of tags. When multiple tags are specified, an item must have all of the tags to be selected.
        :type query['tags']: TagsFilter
        :param query['type'] (dict) <br> query.type (Query) : If set, filters on the type of plug.
        :type query['type']: PlugType
        :param query['limit'] (dict) <br> query.limit (Query) : The maximum number of items to be return from this query. Has a deployment-defined default and maximum value.
        :type query['limit']: float
        :param query['page'] (dict) <br> query.page (Query) : The number of pages to skip when returning result to this query.
        :type query['page']: float
        :param query['includeDraft'] (dict) <br> query.include_draft (Query) : Configures the inclusion of _draft_ versions when selecting latest versions per name. By default, draft versions are only considered when no other versions are available. If set to `true`, draft versions are **included**. If set to `false`, draft versions are **excluded**.
        :type query['includeDraft']: bool
        :param query['includeDeprecated'] (dict) <br> query.include_deprecated (Query) : Configures the inclusion of _deprecated_ versions when selecting latest versions per name. By default, deprecated versions are only considered when no other versions are available. If set to `true`, deprecated versions are **included**. If set to `false`, deprecated versions are **excluded**.
        :type query['includeDeprecated']: bool
        :param query['deprecated'] (dict) <br> query.deprecated (Query) : Filter on the deprecation status of the function.
        :type query['deprecated']: bool
        :param query['draft'] (dict) <br> query.draft (Query) : Filter on the draft status of the function.
        :type query['draft']: bool
        :param query['nameVersion'] (dict) <br> query.name_version (Query) : Filter on exact `{name}@{version}` functions. Using this filter implies a `latest=false` default, returning multiple versions of the same named versions if they are filtered.
        :type query['nameVersion']: List[str]
        :param query['version'] (dict) <br> query.version (Query) : Filter on the version of the function (case-sensitive, supports wildcards).
        :type query['version']: str
        :param query['status'] (dict) <br> query.status (Query) : Filter on the status of the plug. Filter values with a `-` postfix exclude the status. Use the `any` filter value to include all states. When not specified, a default `undeployed-` filter excludes _undeployed_ functions.
        :type query['status']: List[StatusFilter]
        :param query['runtimeVersion'] (dict) <br> query.runtime_version (Query) : Filter on the runtime version.
        :type query['runtimeVersion']: SemanticVersionRange
        :param query['createdBy'] (dict) <br> query.created_by (Query) : Filter on the user that create the plug. You can use the `@me` token to indicate your own plugs.
        :type query['createdBy']: str
        :param query['updatedBy'] (dict) <br> query.updated_by (Query) : Filter on the user that last updated the plug. You can use the `@me` token to indicate your own plugs.
        :type query['updatedBy']: str
        :param query['createdBefore'] (dict) <br> query.created_before (Query) : Filter on funtions that were created before the given timestamp or age.
        :type query['createdBefore']: TimestampSpec
        :param query['createdAfter'] (dict) <br> query.created_after (Query) : Filter on funtions that were created after the given timestamp or age.
        :type query['createdAfter']: TimestampSpec
        :param query['updatedBefore'] (dict) <br> query.updated_before (Query) : Filter on funtions that were updated before the given timestamp or age.
        :type query['updatedBefore']: TimestampSpec
        :param query['updatedAfter'] (dict) <br> query.updated_after (Query) : Filter on funtions that were updated after the given timestamp or age.
        :type query['updatedAfter']: TimestampSpec
        :param query['name'] (dict) <br> query.name (Query) : Filter on the name of the function. This is case-insensitive and supports wild-cards `?` (any one character) and `*` (any sequence of characters).
        :type query['name']: str
        :param query['archiveFormat'] (dict) <br> query.archive_format (Query) : Filter on the archive format of the function.
        :type query['archiveFormat']: List[ArchiveFormat]
        :param query['runtime'] (dict) <br> query.runtime (Query) : Filter on the runtime of the function.
        :type query['runtime']: List[str]
        :param query['latest'] (dict) <br> query.latest (Query) : When `true`, only the latest version per function name is returned. If set to `false`, multiple versions per named function can be returned. Defaults to `true`, except when specific versions are selected with the `nameVersion` filter.
        :type query['latest']: bool
        :param query['showRelated'] (dict) <br> query.show_related (Query) : Sets the representation of related function versions (like the _latest_ draft and/or published) in the response. - `embed`: as full summary representation (in `_embedded`). - `link`: as HAL link in (in `_links`). - `none`: omitted.
        :type query['showRelated']: ShowRelatedType
        :param raw_response: If true, return the http Response object instead of returning an api model object, or throwing an ApiError.
        :param select_path: Denotes the json path applied to the response object before returning it.
                Set it to the empty string `""` to receive the full response object.
        :param response_type: If specified, the response is parsed into an instance of the specified type.
        :param validate_request: If set to false, the request body and query parameters are NOT validated against the models in the service types package, even when available.
        :param headers: Header parameters for this request
        :type headers: dict, optional
        :param `**kwargs`: Additional parameters passed on to the http client.
            See below.
        :Keyword Arguments:
            * timeout: a single numeric timeout in seconds,
                or a tuple of _connect_, _read_, _write_ and _pool_ timeouts.
            * stream: if true, the response will be in streaming mode
            * cookies
            * extensions
            * auth
            * follow_redirects: bool

        :return: Returns the result object if the http request succeeded with status code '2XX'.
        :raises APIError: If the http request has a status code different from `2XX`. This
            object wraps both the http Response and any parsed data.
        """

        # path parameters
        path_params: Dict[str, str] = {}

        ## named body parameters
        body_args: Dict[str, Any] = {}

        # query parameters
        if query is not None and MODELS_AVAILABLE and validate_request:
            query = TypeAdapter(ListQuery).validate_python(query)

        response_types_map: Dict[str, Any] = (
            {"2XX": response_type}
            if response_type is not None
            else {
                "200": LatestPlugsResponseV2 if not select_path else Model,
            }
        )
        non_200_response_types_map: Dict[str, Any] = {}
        response_types_map.update(non_200_response_types_map)

        ## peform request
        return await self.api_client.request(
            method="GET",
            resource_path="/registry/v2/plugs/",
            path_params=path_params,
            params=query,
            **body_args,
            headers=headers,
            **kwargs,
            response_type=response_types_map,
            select_path=select_path,
            raw_response=raw_response,
        )

    @overload
    async def list_versions(
        self,
        name: Annotated[StrictStr, Field(description="The name of the function.")],
        *,
        query: ListVersionsQuery | QueryParamTypes | None = None,
        raw_response: Literal[False] = False,
        select_path: Literal[""] = "",
        response_type: Literal[None] = None,
        validate_request: StrictBool = True,
        headers: HeaderTypes | None = None,
        **kwargs,
    ) -> PlugVersionsResponseV2: ...

    @overload
    async def list_versions(
        self,
        name: Annotated[StrictStr, Field(description="The name of the function.")],
        *,
        query: ListVersionsQuery | QueryParamTypes | None = None,
        raw_response: Literal[False] = False,
        select_path: Literal[""] = "",
        response_type: T,
        validate_request: StrictBool = True,
        headers: HeaderTypes | None = None,
        **kwargs,
    ) -> T: ...

    @overload
    async def list_versions(
        self,
        name: Annotated[StrictStr, Field(description="The name of the function.")],
        *,
        query: ListVersionsQuery | QueryParamTypes | None = None,
        raw_response: Literal[True],
        select_path: Literal["_not_used_"] = "_not_used_",
        response_type: Literal[None] = None,  # not used
        validate_request: StrictBool = True,
        headers: HeaderTypes | None = None,
        **kwargs,
    ) -> Response: ...

    @overload
    async def list_versions(
        self,
        name: Annotated[StrictStr, Field(description="The name of the function.")],
        *,
        query: ListVersionsQuery | QueryParamTypes | None = None,
        raw_response: Literal[False] = False,
        select_path: str,
        response_type: Literal[None] = None,
        validate_request: StrictBool = True,
        headers: HeaderTypes | None = None,
        **kwargs,
    ) -> Model: ...

    @overload
    async def list_versions(
        self,
        name: Annotated[StrictStr, Field(description="The name of the function.")],
        *,
        query: ListVersionsQuery | QueryParamTypes | None = None,
        raw_response: Literal[False] = False,
        select_path: str,
        response_type: T,
        validate_request: StrictBool = True,
        headers: HeaderTypes | None = None,
        **kwargs,
    ) -> T: ...

    async def list_versions(
        self,
        name: Annotated[StrictStr, Field(description="The name of the function.")],
        *,
        query: ListVersionsQuery | QueryParamTypes | None = None,
        raw_response: StrictBool = False,
        select_path: str = "",
        response_type: T | None = None,
        validate_request: StrictBool = True,
        headers: HeaderTypes | None = None,
        **kwargs,
    ) -> PlugVersionsResponseV2 | T | Response | Model:
        """List Plug Versions.

        List all versions of a plug, including deprecated versions or not.
        :param name: The name of the function. (required)
        :type name: str
        :param query: URL Query parameters.
        :type query: ListVersionsQuery | QueryParamTypes, optional
        :param query['tags'] (dict) <br> query.tags (Query) : Filter on the tags of the item. Can be a single tag, or a list of tags. When multiple tags are specified, an item must have all of the tags to be selected.
        :type query['tags']: TagsFilter
        :param query['limit'] (dict) <br> query.limit (Query) : The maximum number of items to be return from this query. Has a deployment-defined default and maximum value.
        :type query['limit']: float
        :param query['page'] (dict) <br> query.page (Query) : The number of pages to skip when returning result to this query.
        :type query['page']: float
        :param query['deprecated'] (dict) <br> query.deprecated (Query) : Filter on the deprecation status of the function.
        :type query['deprecated']: bool
        :param query['draft'] (dict) <br> query.draft (Query) : Filter on the draft status of the function.
        :type query['draft']: bool
        :param query['version'] (dict) <br> query.version (Query) : Filter on the version of the function (case-sensitive, supports wildcards).
        :type query['version']: str
        :param query['status'] (dict) <br> query.status (Query) : Filter on the status of the plug. Filter values with a `-` postfix exclude the status. Use the `any` filter value to include all states. When not specified, a default `undeployed-` filter excludes _undeployed_ functions.
        :type query['status']: List[StatusFilter]
        :param query['runtimeVersion'] (dict) <br> query.runtime_version (Query) : Filter on the runtime version.
        :type query['runtimeVersion']: SemanticVersionRange
        :param query['createdBy'] (dict) <br> query.created_by (Query) : Filter on the user that create the plug. You can use the `@me` token to indicate your own plugs.
        :type query['createdBy']: str
        :param query['updatedBy'] (dict) <br> query.updated_by (Query) : Filter on the user that last updated the plug. You can use the `@me` token to indicate your own plugs.
        :type query['updatedBy']: str
        :param query['createdBefore'] (dict) <br> query.created_before (Query) : Filter on funtions that were created before the given timestamp or age.
        :type query['createdBefore']: TimestampSpec
        :param query['createdAfter'] (dict) <br> query.created_after (Query) : Filter on funtions that were created after the given timestamp or age.
        :type query['createdAfter']: TimestampSpec
        :param query['updatedBefore'] (dict) <br> query.updated_before (Query) : Filter on funtions that were updated before the given timestamp or age.
        :type query['updatedBefore']: TimestampSpec
        :param query['updatedAfter'] (dict) <br> query.updated_after (Query) : Filter on funtions that were updated after the given timestamp or age.
        :type query['updatedAfter']: TimestampSpec
        :param query['archiveFormat'] (dict) <br> query.archive_format (Query) : Filter on the archive format of the function.
        :type query['archiveFormat']: List[ArchiveFormat]
        :param query['runtime'] (dict) <br> query.runtime (Query) : Filter on the runtime of the function.
        :type query['runtime']: List[str]
        :param raw_response: If true, return the http Response object instead of returning an api model object, or throwing an ApiError.
        :param select_path: Denotes the json path applied to the response object before returning it.
                Set it to the empty string `""` to receive the full response object.
        :param response_type: If specified, the response is parsed into an instance of the specified type.
        :param validate_request: If set to false, the request body and query parameters are NOT validated against the models in the service types package, even when available.
        :param headers: Header parameters for this request
        :type headers: dict, optional
        :param `**kwargs`: Additional parameters passed on to the http client.
            See below.
        :Keyword Arguments:
            * timeout: a single numeric timeout in seconds,
                or a tuple of _connect_, _read_, _write_ and _pool_ timeouts.
            * stream: if true, the response will be in streaming mode
            * cookies
            * extensions
            * auth
            * follow_redirects: bool

        :return: Returns the result object if the http request succeeded with status code '2XX'.
        :raises APIError: If the http request has a status code different from `2XX`. This
            object wraps both the http Response and any parsed data.
        """

        # path parameters
        path_params: Dict[str, str] = {
            "name": str(name),
        }

        ## named body parameters
        body_args: Dict[str, Any] = {}

        # query parameters
        if query is not None and MODELS_AVAILABLE and validate_request:
            query = TypeAdapter(ListVersionsQuery).validate_python(query)

        response_types_map: Dict[str, Any] = (
            {"2XX": response_type}
            if response_type is not None
            else {
                "200": PlugVersionsResponseV2 if not select_path else Model,
            }
        )
        non_200_response_types_map: Dict[str, Any] = {}
        response_types_map.update(non_200_response_types_map)

        ## peform request
        return await self.api_client.request(
            method="GET",
            resource_path="/registry/v2/plugs/{name}/versions",
            path_params=path_params,
            params=query,
            **body_args,
            headers=headers,
            **kwargs,
            response_type=response_types_map,
            select_path=select_path,
            raw_response=raw_response,
        )

    @overload
    async def patch_interface(
        self,
        name: Annotated[StrictStr, Field(description="The name of the function.")],
        version: Annotated[
            str, Field(strict=True, description="The version of the function.")
        ],
        *,
        json: Documentation | None = None,
        query: PatchInterfaceQuery | QueryParamTypes | None = None,
        raw_response: Literal[False] = False,
        select_path: Literal[""] = "",
        response_type: Literal[None] = None,
        validate_request: StrictBool = True,
        headers: HeaderTypes | None = None,
        **kwargs,
    ) -> GetPlugResponseV2: ...

    @overload
    async def patch_interface(
        self,
        name: Annotated[StrictStr, Field(description="The name of the function.")],
        version: Annotated[
            str, Field(strict=True, description="The version of the function.")
        ],
        *,
        json: Documentation | None = None,
        query: PatchInterfaceQuery | QueryParamTypes | None = None,
        raw_response: Literal[False] = False,
        select_path: Literal[""] = "",
        response_type: T,
        validate_request: StrictBool = True,
        headers: HeaderTypes | None = None,
        **kwargs,
    ) -> T: ...

    @overload
    async def patch_interface(
        self,
        name: Annotated[StrictStr, Field(description="The name of the function.")],
        version: Annotated[
            str, Field(strict=True, description="The version of the function.")
        ],
        *,
        json: Documentation | None = None,
        query: PatchInterfaceQuery | QueryParamTypes | None = None,
        raw_response: Literal[True],
        select_path: Literal["_not_used_"] = "_not_used_",
        response_type: Literal[None] = None,  # not used
        validate_request: StrictBool = True,
        headers: HeaderTypes | None = None,
        **kwargs,
    ) -> Response: ...

    @overload
    async def patch_interface(
        self,
        name: Annotated[StrictStr, Field(description="The name of the function.")],
        version: Annotated[
            str, Field(strict=True, description="The version of the function.")
        ],
        *,
        json: Documentation | None = None,
        query: PatchInterfaceQuery | QueryParamTypes | None = None,
        raw_response: Literal[False] = False,
        select_path: str,
        response_type: Literal[None] = None,
        validate_request: StrictBool = True,
        headers: HeaderTypes | None = None,
        **kwargs,
    ) -> Model: ...

    @overload
    async def patch_interface(
        self,
        name: Annotated[StrictStr, Field(description="The name of the function.")],
        version: Annotated[
            str, Field(strict=True, description="The version of the function.")
        ],
        *,
        json: Documentation | None = None,
        query: PatchInterfaceQuery | QueryParamTypes | None = None,
        raw_response: Literal[False] = False,
        select_path: str,
        response_type: T,
        validate_request: StrictBool = True,
        headers: HeaderTypes | None = None,
        **kwargs,
    ) -> T: ...

    async def patch_interface(
        self,
        name: Annotated[StrictStr, Field(description="The name of the function.")],
        version: Annotated[
            str, Field(strict=True, description="The version of the function.")
        ],
        *,
        json: Documentation | None = None,
        query: PatchInterfaceQuery | QueryParamTypes | None = None,
        raw_response: StrictBool = False,
        select_path: str = "",
        response_type: T | None = None,
        validate_request: StrictBool = True,
        headers: HeaderTypes | None = None,
        **kwargs,
    ) -> GetPlugResponseV2 | T | Response | Model:
        """Patch Plug Interface.

        Patch the interface documentation of a plug version.
        :param name: The name of the function. (required)
        :type name: str
        :param version: The version of the function. (required)
        :type version: str
        :param json: The json request body.
        :type json: Documentation, optional
        :param query: URL Query parameters.
        :type query: PatchInterfaceQuery | QueryParamTypes, optional
        :param query['comment'] (dict) <br> query.comment (Query) : An optional user-specified comment corresponding to the operation.
        :type query['comment']: str
        :param raw_response: If true, return the http Response object instead of returning an api model object, or throwing an ApiError.
        :param select_path: Denotes the json path applied to the response object before returning it.
                Set it to the empty string `""` to receive the full response object.
        :param response_type: If specified, the response is parsed into an instance of the specified type.
        :param validate_request: If set to false, the request body and query parameters are NOT validated against the models in the service types package, even when available.
        :param headers: Header parameters for this request
        :type headers: dict, optional
        :param `**kwargs`: Additional parameters passed on to the http client.
            See below.
        :Keyword Arguments:
            * timeout: a single numeric timeout in seconds,
                or a tuple of _connect_, _read_, _write_ and _pool_ timeouts.
            * stream: if true, the response will be in streaming mode
            * cookies
            * extensions
            * auth
            * follow_redirects: bool

        :return: Returns the result object if the http request succeeded with status code '2XX'.
        :raises APIError: If the http request has a status code different from `2XX`. This
            object wraps both the http Response and any parsed data.
        """

        # path parameters
        path_params: Dict[str, str] = {
            "name": str(name),
            "version": str(version),
        }

        ## named body parameters
        body_args: Dict[str, Any] = {}
        if json is not None and validate_request:
            body_adapter = TypeAdapter(Optional[Documentation])
            json = body_adapter.validate_python(json)  # type: ignore # https://github.com/pydantic/pydantic/discussions/7094
        body_args["json"] = json

        # query parameters
        if query is not None and MODELS_AVAILABLE and validate_request:
            query = TypeAdapter(PatchInterfaceQuery).validate_python(query)

        response_types_map: Dict[str, Any] = (
            {"2XX": response_type}
            if response_type is not None
            else {
                "200": GetPlugResponseV2 if not select_path else Model,
            }
        )
        non_200_response_types_map: Dict[str, Any] = {}
        response_types_map.update(non_200_response_types_map)

        ## peform request
        return await self.api_client.request(
            method="PATCH",
            resource_path="/registry/v2/plugs/{name}/versions/{version}/interface",
            path_params=path_params,
            params=query,
            **body_args,
            headers=headers,
            **kwargs,
            response_type=response_types_map,
            select_path=select_path,
            raw_response=raw_response,
        )

    @overload
    async def patch_metadata(
        self,
        name: Annotated[StrictStr, Field(description="The name of the function.")],
        version: Annotated[
            str, Field(strict=True, description="The version of the function.")
        ],
        *,
        json: UpdateMetadataRequestV2 | None = None,
        query: PatchMetadataQuery | QueryParamTypes | None = None,
        raw_response: Literal[False] = False,
        select_path: Literal[""] = "",
        response_type: Literal[None] = None,
        validate_request: StrictBool = True,
        headers: HeaderTypes | None = None,
        **kwargs,
    ) -> GetPlugResponseV2: ...

    @overload
    async def patch_metadata(
        self,
        name: Annotated[StrictStr, Field(description="The name of the function.")],
        version: Annotated[
            str, Field(strict=True, description="The version of the function.")
        ],
        *,
        json: UpdateMetadataRequestV2 | None = None,
        query: PatchMetadataQuery | QueryParamTypes | None = None,
        raw_response: Literal[False] = False,
        select_path: Literal[""] = "",
        response_type: T,
        validate_request: StrictBool = True,
        headers: HeaderTypes | None = None,
        **kwargs,
    ) -> T: ...

    @overload
    async def patch_metadata(
        self,
        name: Annotated[StrictStr, Field(description="The name of the function.")],
        version: Annotated[
            str, Field(strict=True, description="The version of the function.")
        ],
        *,
        json: UpdateMetadataRequestV2 | None = None,
        query: PatchMetadataQuery | QueryParamTypes | None = None,
        raw_response: Literal[True],
        select_path: Literal["_not_used_"] = "_not_used_",
        response_type: Literal[None] = None,  # not used
        validate_request: StrictBool = True,
        headers: HeaderTypes | None = None,
        **kwargs,
    ) -> Response: ...

    @overload
    async def patch_metadata(
        self,
        name: Annotated[StrictStr, Field(description="The name of the function.")],
        version: Annotated[
            str, Field(strict=True, description="The version of the function.")
        ],
        *,
        json: UpdateMetadataRequestV2 | None = None,
        query: PatchMetadataQuery | QueryParamTypes | None = None,
        raw_response: Literal[False] = False,
        select_path: str,
        response_type: Literal[None] = None,
        validate_request: StrictBool = True,
        headers: HeaderTypes | None = None,
        **kwargs,
    ) -> Model: ...

    @overload
    async def patch_metadata(
        self,
        name: Annotated[StrictStr, Field(description="The name of the function.")],
        version: Annotated[
            str, Field(strict=True, description="The version of the function.")
        ],
        *,
        json: UpdateMetadataRequestV2 | None = None,
        query: PatchMetadataQuery | QueryParamTypes | None = None,
        raw_response: Literal[False] = False,
        select_path: str,
        response_type: T,
        validate_request: StrictBool = True,
        headers: HeaderTypes | None = None,
        **kwargs,
    ) -> T: ...

    async def patch_metadata(
        self,
        name: Annotated[StrictStr, Field(description="The name of the function.")],
        version: Annotated[
            str, Field(strict=True, description="The version of the function.")
        ],
        *,
        json: UpdateMetadataRequestV2 | None = None,
        query: PatchMetadataQuery | QueryParamTypes | None = None,
        raw_response: StrictBool = False,
        select_path: str = "",
        response_type: T | None = None,
        validate_request: StrictBool = True,
        headers: HeaderTypes | None = None,
        **kwargs,
    ) -> GetPlugResponseV2 | T | Response | Model:
        """Patch Plug Metadata.

        Patch the metadata of a plug version.
        :param name: The name of the function. (required)
        :type name: str
        :param version: The version of the function. (required)
        :type version: str
        :param json: The json request body.
        :type json: UpdateMetadataRequestV2, optional
        :param query: URL Query parameters.
        :type query: PatchMetadataQuery | QueryParamTypes, optional
        :param query['comment'] (dict) <br> query.comment (Query) : An optional user-specified comment corresponding to the operation.
        :type query['comment']: str
        :param raw_response: If true, return the http Response object instead of returning an api model object, or throwing an ApiError.
        :param select_path: Denotes the json path applied to the response object before returning it.
                Set it to the empty string `""` to receive the full response object.
        :param response_type: If specified, the response is parsed into an instance of the specified type.
        :param validate_request: If set to false, the request body and query parameters are NOT validated against the models in the service types package, even when available.
        :param headers: Header parameters for this request
        :type headers: dict, optional
        :param `**kwargs`: Additional parameters passed on to the http client.
            See below.
        :Keyword Arguments:
            * timeout: a single numeric timeout in seconds,
                or a tuple of _connect_, _read_, _write_ and _pool_ timeouts.
            * stream: if true, the response will be in streaming mode
            * cookies
            * extensions
            * auth
            * follow_redirects: bool

        :return: Returns the result object if the http request succeeded with status code '2XX'.
        :raises APIError: If the http request has a status code different from `2XX`. This
            object wraps both the http Response and any parsed data.
        """

        # path parameters
        path_params: Dict[str, str] = {
            "name": str(name),
            "version": str(version),
        }

        ## named body parameters
        body_args: Dict[str, Any] = {}
        if json is not None and validate_request:
            body_adapter = TypeAdapter(Optional[UpdateMetadataRequestV2])
            json = body_adapter.validate_python(json)  # type: ignore # https://github.com/pydantic/pydantic/discussions/7094
        body_args["json"] = json

        # query parameters
        if query is not None and MODELS_AVAILABLE and validate_request:
            query = TypeAdapter(PatchMetadataQuery).validate_python(query)

        response_types_map: Dict[str, Any] = (
            {"2XX": response_type}
            if response_type is not None
            else {
                "200": GetPlugResponseV2 if not select_path else Model,
            }
        )
        non_200_response_types_map: Dict[str, Any] = {}
        response_types_map.update(non_200_response_types_map)

        ## peform request
        return await self.api_client.request(
            method="PATCH",
            resource_path="/registry/v2/plugs/{name}/versions/{version}/metadata",
            path_params=path_params,
            params=query,
            **body_args,
            headers=headers,
            **kwargs,
            response_type=response_types_map,
            select_path=select_path,
            raw_response=raw_response,
        )

    @overload
    async def publish(
        self,
        name: Annotated[StrictStr, Field(description="The name of the function.")],
        version: Annotated[
            str, Field(strict=True, description="The version of the function.")
        ],
        *,
        query: PublishQuery | QueryParamTypes | None = None,
        raw_response: Literal[False] = False,
        select_path: Literal[""] = "",
        response_type: Literal[None] = None,
        validate_request: StrictBool = True,
        headers: HeaderTypes | None = None,
        **kwargs,
    ) -> PostPlugJobSyncResponseV2 | PostPlugJobAsyncResponseV2: ...

    @overload
    async def publish(
        self,
        name: Annotated[StrictStr, Field(description="The name of the function.")],
        version: Annotated[
            str, Field(strict=True, description="The version of the function.")
        ],
        *,
        query: PublishQuery | QueryParamTypes | None = None,
        raw_response: Literal[False] = False,
        select_path: Literal[""] = "",
        response_type: T,
        validate_request: StrictBool = True,
        headers: HeaderTypes | None = None,
        **kwargs,
    ) -> T: ...

    @overload
    async def publish(
        self,
        name: Annotated[StrictStr, Field(description="The name of the function.")],
        version: Annotated[
            str, Field(strict=True, description="The version of the function.")
        ],
        *,
        query: PublishQuery | QueryParamTypes | None = None,
        raw_response: Literal[True],
        select_path: Literal["_not_used_"] = "_not_used_",
        response_type: Literal[None] = None,  # not used
        validate_request: StrictBool = True,
        headers: HeaderTypes | None = None,
        **kwargs,
    ) -> Response: ...

    @overload
    async def publish(
        self,
        name: Annotated[StrictStr, Field(description="The name of the function.")],
        version: Annotated[
            str, Field(strict=True, description="The version of the function.")
        ],
        *,
        query: PublishQuery | QueryParamTypes | None = None,
        raw_response: Literal[False] = False,
        select_path: str,
        response_type: Literal[None] = None,
        validate_request: StrictBool = True,
        headers: HeaderTypes | None = None,
        **kwargs,
    ) -> Model: ...

    @overload
    async def publish(
        self,
        name: Annotated[StrictStr, Field(description="The name of the function.")],
        version: Annotated[
            str, Field(strict=True, description="The version of the function.")
        ],
        *,
        query: PublishQuery | QueryParamTypes | None = None,
        raw_response: Literal[False] = False,
        select_path: str,
        response_type: T,
        validate_request: StrictBool = True,
        headers: HeaderTypes | None = None,
        **kwargs,
    ) -> T: ...

    async def publish(
        self,
        name: Annotated[StrictStr, Field(description="The name of the function.")],
        version: Annotated[
            str, Field(strict=True, description="The version of the function.")
        ],
        *,
        query: PublishQuery | QueryParamTypes | None = None,
        raw_response: StrictBool = False,
        select_path: str = "",
        response_type: T | None = None,
        validate_request: StrictBool = True,
        headers: HeaderTypes | None = None,
        **kwargs,
    ) -> PostPlugJobSyncResponseV2 | PostPlugJobAsyncResponseV2 | T | Response | Model:
        """Publish Draft Plug.

        Mark the <em>plug</em> to be ready and stable, taking it out of draft mode.,    Typically, the <em>plug</em> should be in the <code>running</code> status,    such that publishing becomes a simple operation where the existing deployment can be re-used.   In other statuses, plug-registry may need to initiate a new build and deployment procedure.
        :param name: The name of the function. (required)
        :type name: str
        :param version: The version of the function. (required)
        :type version: str
        :param query: URL Query parameters.
        :type query: PublishQuery | QueryParamTypes, optional
        :param query['chown'] (dict) <br> query.chown (Query) : If set, ownership of the draft function is transferred to the current user.
        :type query['chown']: bool
        :param query['comment'] (dict) <br> query.comment (Query) : An optional user-specified comment corresponding to the operation.
        :type query['comment']: str
        :param query['author'] (dict) <br> query.author (Query) : Optionally changes the author metadata when updating a function.
        :type query['author']: str
        :param query['deprecatePrevious'] (dict) <br> query.deprecate_previous (Query) : Set the cleanup policy used to automatically deprecate/delete previous versions.
        :type query['deprecatePrevious']: DeprecatePreviousPolicy
        :param query['async'] (dict) <br> query.var_async (Query) : Unless this is set to <code>false</code>, the server will start the required job actions asynchronously and return a <code>202</code> <em>Accepted</em> response. If <code>false</code> the request will block until the job actions are completed, or a timeout occurs.
        :type query['async']: bool
        :param raw_response: If true, return the http Response object instead of returning an api model object, or throwing an ApiError.
        :param select_path: Denotes the json path applied to the response object before returning it.
                Set it to the empty string `""` to receive the full response object.
        :param response_type: If specified, the response is parsed into an instance of the specified type.
        :param validate_request: If set to false, the request body and query parameters are NOT validated against the models in the service types package, even when available.
        :param headers: Header parameters for this request
        :type headers: dict, optional
        :param `**kwargs`: Additional parameters passed on to the http client.
            See below.
        :Keyword Arguments:
            * timeout: a single numeric timeout in seconds,
                or a tuple of _connect_, _read_, _write_ and _pool_ timeouts.
            * stream: if true, the response will be in streaming mode
            * cookies
            * extensions
            * auth
            * follow_redirects: bool

        :return: Returns the result object if the http request succeeded with status code '2XX'.
        :raises APIError: If the http request has a status code different from `2XX`. This
            object wraps both the http Response and any parsed data.
        """

        # path parameters
        path_params: Dict[str, str] = {
            "name": str(name),
            "version": str(version),
        }

        ## named body parameters
        body_args: Dict[str, Any] = {}

        # query parameters
        if query is not None and MODELS_AVAILABLE and validate_request:
            query = TypeAdapter(PublishQuery).validate_python(query)

        response_types_map: Dict[str, Any] = (
            {"2XX": response_type}
            if response_type is not None
            else {
                "201": PostPlugJobSyncResponseV2 if not select_path else Model,
                "202": PostPlugJobAsyncResponseV2 if not select_path else Model,
            }
        )
        non_200_response_types_map: Dict[str, Any] = {}
        response_types_map.update(non_200_response_types_map)

        ## peform request
        return await self.api_client.request(
            method="POST",
            resource_path="/registry/v2/plugs/{name}/versions/{version}/publish",
            path_params=path_params,
            params=query,
            **body_args,
            headers=headers,
            **kwargs,
            response_type=response_types_map,
            select_path=select_path,
            raw_response=raw_response,
        )

    @overload
    async def rebuild(
        self,
        name: Annotated[StrictStr, Field(description="The name of the function.")],
        version: Annotated[
            str, Field(strict=True, description="The version of the function.")
        ],
        *,
        query: RebuildQuery | QueryParamTypes | None = None,
        raw_response: Literal[False] = False,
        select_path: Literal[""] = "",
        response_type: Literal[None] = None,
        validate_request: StrictBool = True,
        headers: HeaderTypes | None = None,
        **kwargs,
    ) -> RebuildPlugSyncResponseV2 | RebuildPlugAsyncResponseV2: ...

    @overload
    async def rebuild(
        self,
        name: Annotated[StrictStr, Field(description="The name of the function.")],
        version: Annotated[
            str, Field(strict=True, description="The version of the function.")
        ],
        *,
        query: RebuildQuery | QueryParamTypes | None = None,
        raw_response: Literal[False] = False,
        select_path: Literal[""] = "",
        response_type: T,
        validate_request: StrictBool = True,
        headers: HeaderTypes | None = None,
        **kwargs,
    ) -> T: ...

    @overload
    async def rebuild(
        self,
        name: Annotated[StrictStr, Field(description="The name of the function.")],
        version: Annotated[
            str, Field(strict=True, description="The version of the function.")
        ],
        *,
        query: RebuildQuery | QueryParamTypes | None = None,
        raw_response: Literal[True],
        select_path: Literal["_not_used_"] = "_not_used_",
        response_type: Literal[None] = None,  # not used
        validate_request: StrictBool = True,
        headers: HeaderTypes | None = None,
        **kwargs,
    ) -> Response: ...

    @overload
    async def rebuild(
        self,
        name: Annotated[StrictStr, Field(description="The name of the function.")],
        version: Annotated[
            str, Field(strict=True, description="The version of the function.")
        ],
        *,
        query: RebuildQuery | QueryParamTypes | None = None,
        raw_response: Literal[False] = False,
        select_path: str,
        response_type: Literal[None] = None,
        validate_request: StrictBool = True,
        headers: HeaderTypes | None = None,
        **kwargs,
    ) -> Model: ...

    @overload
    async def rebuild(
        self,
        name: Annotated[StrictStr, Field(description="The name of the function.")],
        version: Annotated[
            str, Field(strict=True, description="The version of the function.")
        ],
        *,
        query: RebuildQuery | QueryParamTypes | None = None,
        raw_response: Literal[False] = False,
        select_path: str,
        response_type: T,
        validate_request: StrictBool = True,
        headers: HeaderTypes | None = None,
        **kwargs,
    ) -> T: ...

    async def rebuild(
        self,
        name: Annotated[StrictStr, Field(description="The name of the function.")],
        version: Annotated[
            str, Field(strict=True, description="The version of the function.")
        ],
        *,
        query: RebuildQuery | QueryParamTypes | None = None,
        raw_response: StrictBool = False,
        select_path: str = "",
        response_type: T | None = None,
        validate_request: StrictBool = True,
        headers: HeaderTypes | None = None,
        **kwargs,
    ) -> RebuildPlugSyncResponseV2 | RebuildPlugAsyncResponseV2 | T | Response | Model:
        """Rebuild Plug.

        Rebuild and deploy a plug with the original or updated base image.
        :param name: The name of the function. (required)
        :type name: str
        :param version: The version of the function. (required)
        :type version: str
        :param query: URL Query parameters.
        :type query: RebuildQuery | QueryParamTypes, optional
        :param query['scaleToZero'] (dict) <br> query.scale_to_zero (Query) : Indicates whether the function needs to be scaled down after successful verification. If not set, the function is scaled to zero only if it was not active before this command.
        :type query['scaleToZero']: bool
        :param query['comment'] (dict) <br> query.comment (Query) : An optional user-specified comment corresponding to the operation.
        :type query['comment']: str
        :param query['dryRun'] (dict) <br> query.dry_run (Query) : If set to <code>true</code>, checks whether rebuild jobs are needed, but do not start any jobs.
        :type query['dryRun']: bool
        :param query['async'] (dict) <br> query.var_async (Query) : Unless this is set to <code>false</code>, the server will start the required job actions asynchronously and return a <code>202</code> <em>Accepted</em> response. If <code>false</code> the request will block until the job actions are completed, or a timeout occurs.
        :type query['async']: bool
        :param query['upgrade'] (dict) <br> query.upgrade (Query) : If set, force a rebuild with the given <em>runtime</em> version selection policy. <ul>  <li><code>same</code> <b>patch</b> version.   This should only include backward compatible upgrades.  </li>  <li><code>minor</code> <b>major</b> version.   This might include an upgrade of e.g. the language runtime and/or provided   dependencies that could break compatiblity with the function. .</li> </ul>
        :type query['upgrade']: RebuildPolicy
        :param query['forceVersion'] (dict) <br> query.force_version (Query) : If set, force a rebuild with the given runtime version (including downgrades). This parameter is mutually exclusive to the `upgrade` parameter.
        :type query['forceVersion']: str
        :param query['ignoreChecks'] (dict) <br> query.ignore_checks (Query) : If set to true, checks that normally prevent a rebuild are overriden. These checks include: * function state in `pending`, `running`, `failed` or `undeployed` * backoff period due to recent failures * usage of deprecated dependencies * running jobs on entity * the `dryRun` option
        :type query['ignoreChecks']: bool
        :param query['skipRebuild'] (dict) <br> query.skip_rebuild (Query) : If set, the function will not be rebuild. Always uses the current runtime version when re-deploying/re-verifying the function.
        :type query['skipRebuild']: bool
        :param raw_response: If true, return the http Response object instead of returning an api model object, or throwing an ApiError.
        :param select_path: Denotes the json path applied to the response object before returning it.
                Set it to the empty string `""` to receive the full response object.
        :param response_type: If specified, the response is parsed into an instance of the specified type.
        :param validate_request: If set to false, the request body and query parameters are NOT validated against the models in the service types package, even when available.
        :param headers: Header parameters for this request
        :type headers: dict, optional
        :param `**kwargs`: Additional parameters passed on to the http client.
            See below.
        :Keyword Arguments:
            * timeout: a single numeric timeout in seconds,
                or a tuple of _connect_, _read_, _write_ and _pool_ timeouts.
            * stream: if true, the response will be in streaming mode
            * cookies
            * extensions
            * auth
            * follow_redirects: bool

        :return: Returns the result object if the http request succeeded with status code '2XX'.
        :raises APIError: If the http request has a status code different from `2XX`. This
            object wraps both the http Response and any parsed data.
        """

        # path parameters
        path_params: Dict[str, str] = {
            "name": str(name),
            "version": str(version),
        }

        ## named body parameters
        body_args: Dict[str, Any] = {}

        # query parameters
        if query is not None and MODELS_AVAILABLE and validate_request:
            query = TypeAdapter(RebuildQuery).validate_python(query)

        response_types_map: Dict[str, Any] = (
            {"2XX": response_type}
            if response_type is not None
            else {
                "200": RebuildPlugSyncResponseV2 if not select_path else Model,
                "202": RebuildPlugAsyncResponseV2 if not select_path else Model,
            }
        )
        non_200_response_types_map: Dict[str, Any] = {}
        response_types_map.update(non_200_response_types_map)

        ## peform request
        return await self.api_client.request(
            method="POST",
            resource_path="/registry/v2/plugs/{name}/versions/{version}/rebuild",
            path_params=path_params,
            params=query,
            **body_args,
            headers=headers,
            **kwargs,
            response_type=response_types_map,
            select_path=select_path,
            raw_response=raw_response,
        )

    @overload
    async def remove_version(
        self,
        name: Annotated[StrictStr, Field(description="The name of the function.")],
        version: Annotated[
            str, Field(strict=True, description="The version of the function.")
        ],
        *,
        query: RemoveVersionQuery | QueryParamTypes | None = None,
        raw_response: Literal[False] = False,
        select_path: Literal[""] = "",
        response_type: Literal[None] = None,
        validate_request: StrictBool = True,
        headers: HeaderTypes | None = None,
        **kwargs,
    ) -> UndeployedResponseV2 | UndeploySubmittedResponseV2: ...

    @overload
    async def remove_version(
        self,
        name: Annotated[StrictStr, Field(description="The name of the function.")],
        version: Annotated[
            str, Field(strict=True, description="The version of the function.")
        ],
        *,
        query: RemoveVersionQuery | QueryParamTypes | None = None,
        raw_response: Literal[False] = False,
        select_path: Literal[""] = "",
        response_type: T,
        validate_request: StrictBool = True,
        headers: HeaderTypes | None = None,
        **kwargs,
    ) -> T: ...

    @overload
    async def remove_version(
        self,
        name: Annotated[StrictStr, Field(description="The name of the function.")],
        version: Annotated[
            str, Field(strict=True, description="The version of the function.")
        ],
        *,
        query: RemoveVersionQuery | QueryParamTypes | None = None,
        raw_response: Literal[True],
        select_path: Literal["_not_used_"] = "_not_used_",
        response_type: Literal[None] = None,  # not used
        validate_request: StrictBool = True,
        headers: HeaderTypes | None = None,
        **kwargs,
    ) -> Response: ...

    @overload
    async def remove_version(
        self,
        name: Annotated[StrictStr, Field(description="The name of the function.")],
        version: Annotated[
            str, Field(strict=True, description="The version of the function.")
        ],
        *,
        query: RemoveVersionQuery | QueryParamTypes | None = None,
        raw_response: Literal[False] = False,
        select_path: str,
        response_type: Literal[None] = None,
        validate_request: StrictBool = True,
        headers: HeaderTypes | None = None,
        **kwargs,
    ) -> Model: ...

    @overload
    async def remove_version(
        self,
        name: Annotated[StrictStr, Field(description="The name of the function.")],
        version: Annotated[
            str, Field(strict=True, description="The version of the function.")
        ],
        *,
        query: RemoveVersionQuery | QueryParamTypes | None = None,
        raw_response: Literal[False] = False,
        select_path: str,
        response_type: T,
        validate_request: StrictBool = True,
        headers: HeaderTypes | None = None,
        **kwargs,
    ) -> T: ...

    async def remove_version(
        self,
        name: Annotated[StrictStr, Field(description="The name of the function.")],
        version: Annotated[
            str, Field(strict=True, description="The version of the function.")
        ],
        *,
        query: RemoveVersionQuery | QueryParamTypes | None = None,
        raw_response: StrictBool = False,
        select_path: str = "",
        response_type: T | None = None,
        validate_request: StrictBool = True,
        headers: HeaderTypes | None = None,
        **kwargs,
    ) -> UndeployedResponseV2 | UndeploySubmittedResponseV2 | T | Response | Model:
        """Remove Plug Version.

        Deprecate, undeploy and/or remove a <em>plug</em> version.  By default, a `DELETE`  * marks _published_ version(s) _deprecated_: they remain active, but are no longer included in listings by default. * completely removes any _draft_ version(s) (_deprecate_, _undeploy_ and _remove_)  A _deprecated_ plug version will eventually be _undeployed_ (but not _removed_) by an external background task,  once proven that no waylay rule template or task references it.  Use `?force=true` to skip the deprecation and immediately remove the version(s).  Use `?undeploy=true` to undeploy the plug version(s), but keep it registered in a `undeployed` state. An `undeployed` version can later be restored by a _rebuild_ action.
        :param name: The name of the function. (required)
        :type name: str
        :param version: The version of the function. (required)
        :type version: str
        :param query: URL Query parameters.
        :type query: RemoveVersionQuery | QueryParamTypes, optional
        :param query['comment'] (dict) <br> query.comment (Query) : An optional user-specified comment corresponding to the operation.
        :type query['comment']: str
        :param query['async'] (dict) <br> query.var_async (Query) : Unless this is set to <code>false</code>, the server will start the required job actions asynchronously and return a <code>202</code> <em>Accepted</em> response. If <code>false</code> the request will block until the job actions are completed, or a timeout occurs.
        :type query['async']: bool
        :param query['force'] (dict) <br> query.force (Query) : If <code>true</code>, the plug version(s) will be undeployed and removed. Otherwise, the plug version(s) will only be <code>deprecated</code>, i.e removed from regular listings.
        :type query['force']: bool
        :param query['undeploy'] (dict) <br> query.undeploy (Query) : If `true`, the `DELETE` operation * undeploys the (openfaas) function for the plug: it becomes no longer available for invocation. * does NOT remove the plug from registry: it stays in an `undeployed` status.  All assets and definitions are retained, so the plug can be restored later with a  _rebuild_ action.  If `false`, the `DELETE` operation * _only_ marks the plug version(s) as _deprecated_: the plug remains active but is removed from the default listings.   This also applies to _draft_ versions.  This parameter is incompatible with `force=true`.  If not set the default behaviour applies: * _draft_ versions are _undeployed_ and _removed_ from registry. * non-_draft_ versions are marked _deprecated_ only.
        :type query['undeploy']: bool
        :param raw_response: If true, return the http Response object instead of returning an api model object, or throwing an ApiError.
        :param select_path: Denotes the json path applied to the response object before returning it.
                Set it to the empty string `""` to receive the full response object.
        :param response_type: If specified, the response is parsed into an instance of the specified type.
        :param validate_request: If set to false, the request body and query parameters are NOT validated against the models in the service types package, even when available.
        :param headers: Header parameters for this request
        :type headers: dict, optional
        :param `**kwargs`: Additional parameters passed on to the http client.
            See below.
        :Keyword Arguments:
            * timeout: a single numeric timeout in seconds,
                or a tuple of _connect_, _read_, _write_ and _pool_ timeouts.
            * stream: if true, the response will be in streaming mode
            * cookies
            * extensions
            * auth
            * follow_redirects: bool

        :return: Returns the result object if the http request succeeded with status code '2XX'.
        :raises APIError: If the http request has a status code different from `2XX`. This
            object wraps both the http Response and any parsed data.
        """

        # path parameters
        path_params: Dict[str, str] = {
            "name": str(name),
            "version": str(version),
        }

        ## named body parameters
        body_args: Dict[str, Any] = {}

        # query parameters
        if query is not None and MODELS_AVAILABLE and validate_request:
            query = TypeAdapter(RemoveVersionQuery).validate_python(query)

        response_types_map: Dict[str, Any] = (
            {"2XX": response_type}
            if response_type is not None
            else {
                "200": UndeployedResponseV2 if not select_path else Model,
                "202": UndeploySubmittedResponseV2 if not select_path else Model,
            }
        )
        non_200_response_types_map: Dict[str, Any] = {}
        response_types_map.update(non_200_response_types_map)

        ## peform request
        return await self.api_client.request(
            method="DELETE",
            resource_path="/registry/v2/plugs/{name}/versions/{version}",
            path_params=path_params,
            params=query,
            **body_args,
            headers=headers,
            **kwargs,
            response_type=response_types_map,
            select_path=select_path,
            raw_response=raw_response,
        )

    @overload
    async def remove_versions(
        self,
        name: Annotated[StrictStr, Field(description="The name of the function.")],
        *,
        query: RemoveVersionsQuery | QueryParamTypes | None = None,
        raw_response: Literal[False] = False,
        select_path: Literal[""] = "",
        response_type: Literal[None] = None,
        validate_request: StrictBool = True,
        headers: HeaderTypes | None = None,
        **kwargs,
    ) -> UndeployedResponseV2 | UndeploySubmittedResponseV2: ...

    @overload
    async def remove_versions(
        self,
        name: Annotated[StrictStr, Field(description="The name of the function.")],
        *,
        query: RemoveVersionsQuery | QueryParamTypes | None = None,
        raw_response: Literal[False] = False,
        select_path: Literal[""] = "",
        response_type: T,
        validate_request: StrictBool = True,
        headers: HeaderTypes | None = None,
        **kwargs,
    ) -> T: ...

    @overload
    async def remove_versions(
        self,
        name: Annotated[StrictStr, Field(description="The name of the function.")],
        *,
        query: RemoveVersionsQuery | QueryParamTypes | None = None,
        raw_response: Literal[True],
        select_path: Literal["_not_used_"] = "_not_used_",
        response_type: Literal[None] = None,  # not used
        validate_request: StrictBool = True,
        headers: HeaderTypes | None = None,
        **kwargs,
    ) -> Response: ...

    @overload
    async def remove_versions(
        self,
        name: Annotated[StrictStr, Field(description="The name of the function.")],
        *,
        query: RemoveVersionsQuery | QueryParamTypes | None = None,
        raw_response: Literal[False] = False,
        select_path: str,
        response_type: Literal[None] = None,
        validate_request: StrictBool = True,
        headers: HeaderTypes | None = None,
        **kwargs,
    ) -> Model: ...

    @overload
    async def remove_versions(
        self,
        name: Annotated[StrictStr, Field(description="The name of the function.")],
        *,
        query: RemoveVersionsQuery | QueryParamTypes | None = None,
        raw_response: Literal[False] = False,
        select_path: str,
        response_type: T,
        validate_request: StrictBool = True,
        headers: HeaderTypes | None = None,
        **kwargs,
    ) -> T: ...

    async def remove_versions(
        self,
        name: Annotated[StrictStr, Field(description="The name of the function.")],
        *,
        query: RemoveVersionsQuery | QueryParamTypes | None = None,
        raw_response: StrictBool = False,
        select_path: str = "",
        response_type: T | None = None,
        validate_request: StrictBool = True,
        headers: HeaderTypes | None = None,
        **kwargs,
    ) -> UndeployedResponseV2 | UndeploySubmittedResponseV2 | T | Response | Model:
        """Remove Plug.

        Deprecate, undeploy and/or remove all versions of this named <em>plug</em>.  By default, a `DELETE`  * marks _published_ version(s) _deprecated_: they remain active, but are no longer included in listings by default. * completely removes any _draft_ version(s) (_deprecate_, _undeploy_ and _remove_)  A _deprecated_ plug version will eventually be _undeployed_ (but not _removed_) by an external background task,  once proven that no waylay rule template or task references it.  Use `?force=true` to skip the deprecation and immediately remove the version(s).  Use `?undeploy=true` to undeploy the plug version(s), but keep it registered in a `undeployed` state. An `undeployed` version can later be restored by a _rebuild_ action.
        :param name: The name of the function. (required)
        :type name: str
        :param query: URL Query parameters.
        :type query: RemoveVersionsQuery | QueryParamTypes, optional
        :param query['comment'] (dict) <br> query.comment (Query) : An optional user-specified comment corresponding to the operation.
        :type query['comment']: str
        :param query['async'] (dict) <br> query.var_async (Query) : Unless this is set to <code>false</code>, the server will start the required job actions asynchronously and return a <code>202</code> <em>Accepted</em> response. If <code>false</code> the request will block until the job actions are completed, or a timeout occurs.
        :type query['async']: bool
        :param query['force'] (dict) <br> query.force (Query) : If <code>true</code>, the plug version(s) will be undeployed and removed. Otherwise, the plug version(s) will only be <code>deprecated</code>, i.e removed from regular listings.
        :type query['force']: bool
        :param query['undeploy'] (dict) <br> query.undeploy (Query) : If `true`, the `DELETE` operation * undeploys the (openfaas) function for the plug: it becomes no longer available for invocation. * does NOT remove the plug from registry: it stays in an `undeployed` status.  All assets and definitions are retained, so the plug can be restored later with a  _rebuild_ action.  If `false`, the `DELETE` operation * _only_ marks the plug version(s) as _deprecated_: the plug remains active but is removed from the default listings.   This also applies to _draft_ versions.  This parameter is incompatible with `force=true`.  If not set the default behaviour applies: * _draft_ versions are _undeployed_ and _removed_ from registry. * non-_draft_ versions are marked _deprecated_ only.
        :type query['undeploy']: bool
        :param raw_response: If true, return the http Response object instead of returning an api model object, or throwing an ApiError.
        :param select_path: Denotes the json path applied to the response object before returning it.
                Set it to the empty string `""` to receive the full response object.
        :param response_type: If specified, the response is parsed into an instance of the specified type.
        :param validate_request: If set to false, the request body and query parameters are NOT validated against the models in the service types package, even when available.
        :param headers: Header parameters for this request
        :type headers: dict, optional
        :param `**kwargs`: Additional parameters passed on to the http client.
            See below.
        :Keyword Arguments:
            * timeout: a single numeric timeout in seconds,
                or a tuple of _connect_, _read_, _write_ and _pool_ timeouts.
            * stream: if true, the response will be in streaming mode
            * cookies
            * extensions
            * auth
            * follow_redirects: bool

        :return: Returns the result object if the http request succeeded with status code '2XX'.
        :raises APIError: If the http request has a status code different from `2XX`. This
            object wraps both the http Response and any parsed data.
        """

        # path parameters
        path_params: Dict[str, str] = {
            "name": str(name),
        }

        ## named body parameters
        body_args: Dict[str, Any] = {}

        # query parameters
        if query is not None and MODELS_AVAILABLE and validate_request:
            query = TypeAdapter(RemoveVersionsQuery).validate_python(query)

        response_types_map: Dict[str, Any] = (
            {"2XX": response_type}
            if response_type is not None
            else {
                "200": UndeployedResponseV2 if not select_path else Model,
                "202": UndeploySubmittedResponseV2 if not select_path else Model,
            }
        )
        non_200_response_types_map: Dict[str, Any] = {}
        response_types_map.update(non_200_response_types_map)

        ## peform request
        return await self.api_client.request(
            method="DELETE",
            resource_path="/registry/v2/plugs/{name}",
            path_params=path_params,
            params=query,
            **body_args,
            headers=headers,
            **kwargs,
            response_type=response_types_map,
            select_path=select_path,
            raw_response=raw_response,
        )

    @overload
    async def update_asset(
        self,
        name: Annotated[StrictStr, Field(description="The name of the function.")],
        version: Annotated[
            str, Field(strict=True, description="The version of the function.")
        ],
        wildcard: Annotated[
            StrictStr,
            Field(
                description="Full path or path prefix of the asset within the archive"
            ),
        ],
        *,
        content: Annotated[
            RequestContent | None, Field(description="A single asset file.")
        ] = None,
        query: UpdateAssetQuery | QueryParamTypes | None = None,
        raw_response: Literal[False] = False,
        select_path: Literal[""] = "",
        response_type: Literal[None] = None,
        validate_request: StrictBool = True,
        headers: HeaderTypes | None = None,
        **kwargs,
    ) -> PostPlugJobSyncResponseV2 | PostPlugJobAsyncResponseV2: ...

    @overload
    async def update_asset(
        self,
        name: Annotated[StrictStr, Field(description="The name of the function.")],
        version: Annotated[
            str, Field(strict=True, description="The version of the function.")
        ],
        wildcard: Annotated[
            StrictStr,
            Field(
                description="Full path or path prefix of the asset within the archive"
            ),
        ],
        *,
        content: Annotated[
            RequestContent | None, Field(description="A single asset file.")
        ] = None,
        query: UpdateAssetQuery | QueryParamTypes | None = None,
        raw_response: Literal[False] = False,
        select_path: Literal[""] = "",
        response_type: T,
        validate_request: StrictBool = True,
        headers: HeaderTypes | None = None,
        **kwargs,
    ) -> T: ...

    @overload
    async def update_asset(
        self,
        name: Annotated[StrictStr, Field(description="The name of the function.")],
        version: Annotated[
            str, Field(strict=True, description="The version of the function.")
        ],
        wildcard: Annotated[
            StrictStr,
            Field(
                description="Full path or path prefix of the asset within the archive"
            ),
        ],
        *,
        content: Annotated[
            RequestContent | None, Field(description="A single asset file.")
        ] = None,
        query: UpdateAssetQuery | QueryParamTypes | None = None,
        raw_response: Literal[True],
        select_path: Literal["_not_used_"] = "_not_used_",
        response_type: Literal[None] = None,  # not used
        validate_request: StrictBool = True,
        headers: HeaderTypes | None = None,
        **kwargs,
    ) -> Response: ...

    @overload
    async def update_asset(
        self,
        name: Annotated[StrictStr, Field(description="The name of the function.")],
        version: Annotated[
            str, Field(strict=True, description="The version of the function.")
        ],
        wildcard: Annotated[
            StrictStr,
            Field(
                description="Full path or path prefix of the asset within the archive"
            ),
        ],
        *,
        content: Annotated[
            RequestContent | None, Field(description="A single asset file.")
        ] = None,
        query: UpdateAssetQuery | QueryParamTypes | None = None,
        raw_response: Literal[False] = False,
        select_path: str,
        response_type: Literal[None] = None,
        validate_request: StrictBool = True,
        headers: HeaderTypes | None = None,
        **kwargs,
    ) -> Model: ...

    @overload
    async def update_asset(
        self,
        name: Annotated[StrictStr, Field(description="The name of the function.")],
        version: Annotated[
            str, Field(strict=True, description="The version of the function.")
        ],
        wildcard: Annotated[
            StrictStr,
            Field(
                description="Full path or path prefix of the asset within the archive"
            ),
        ],
        *,
        content: Annotated[
            RequestContent | None, Field(description="A single asset file.")
        ] = None,
        query: UpdateAssetQuery | QueryParamTypes | None = None,
        raw_response: Literal[False] = False,
        select_path: str,
        response_type: T,
        validate_request: StrictBool = True,
        headers: HeaderTypes | None = None,
        **kwargs,
    ) -> T: ...

    async def update_asset(
        self,
        name: Annotated[StrictStr, Field(description="The name of the function.")],
        version: Annotated[
            str, Field(strict=True, description="The version of the function.")
        ],
        wildcard: Annotated[
            StrictStr,
            Field(
                description="Full path or path prefix of the asset within the archive"
            ),
        ],
        *,
        content: Annotated[
            RequestContent | None, Field(description="A single asset file.")
        ] = None,
        query: UpdateAssetQuery | QueryParamTypes | None = None,
        raw_response: StrictBool = False,
        select_path: str = "",
        response_type: T | None = None,
        validate_request: StrictBool = True,
        headers: HeaderTypes | None = None,
        **kwargs,
    ) -> PostPlugJobSyncResponseV2 | PostPlugJobAsyncResponseV2 | T | Response | Model:
        """Update Plug Asset.

        The provided asset will be added to the <em>plug</em> function's collection of existing assets,   replacing any existing asset with the same name.    Please note that it is not allowed to update the plug.json json file with a changed value for any of the     <code>name</code>, <code>version</code> and/or <code>runtime</code> attributes.    For each <em>runtime</em> other files are supported.
        :param name: The name of the function. (required)
        :type name: str
        :param version: The version of the function. (required)
        :type version: str
        :param wildcard: Full path or path prefix of the asset within the archive (required)
        :type wildcard: str
        :param content: A single asset file.
        :type content: ContentRequest, optional
        :param query: URL Query parameters.
        :type query: UpdateAssetQuery | QueryParamTypes, optional
        :param query['scaleToZero'] (dict) <br> query.scale_to_zero (Query) : If set to <code>true</code>, after successful deployment, the deployed function will be scaled to zero. This saves computing resources when the function is not to be used immediately.
        :type query['scaleToZero']: bool
        :param query['deploy'] (dict) <br> query.deploy (Query) : Indicates that a function should be _deployed_ when its assets are valid.  * If `true` (default), jobs to build and deploy the function will be initiated after it is checked that the assets are valid. Invalid assets lead to a validation error, and the function and its assets are not created or updated. * If `false`, the uploaded assets are stored and the function is created/updated in `registered` state. Asset validation errors are only returned as warning, and stored as `failureReason` on the function entity. Use an _asset update_ or _rebuild_ to initiate a build and deploy at a later stage.
        :type query['deploy']: bool
        :param query['chown'] (dict) <br> query.chown (Query) : If set, ownership of the draft function is transferred to the current user.
        :type query['chown']: bool
        :param query['comment'] (dict) <br> query.comment (Query) : An optional user-specified comment corresponding to the operation.
        :type query['comment']: str
        :param query['author'] (dict) <br> query.author (Query) : Optionally changes the author metadata when updating a function.
        :type query['author']: str
        :param query['async'] (dict) <br> query.var_async (Query) : Unless this is set to <code>false</code>, the server will start the required job actions asynchronously and return a <code>202</code> <em>Accepted</em> response. If <code>false</code> the request will block until the job actions are completed, or a timeout occurs.
        :type query['async']: bool
        :param raw_response: If true, return the http Response object instead of returning an api model object, or throwing an ApiError.
        :param select_path: Denotes the json path applied to the response object before returning it.
                Set it to the empty string `""` to receive the full response object.
        :param response_type: If specified, the response is parsed into an instance of the specified type.
        :param validate_request: If set to false, the request body and query parameters are NOT validated against the models in the service types package, even when available.
        :param headers: Header parameters for this request
        :type headers: dict, optional
        :param `**kwargs`: Additional parameters passed on to the http client.
            See below.
        :Keyword Arguments:
            * timeout: a single numeric timeout in seconds,
                or a tuple of _connect_, _read_, _write_ and _pool_ timeouts.
            * stream: if true, the response will be in streaming mode
            * cookies
            * extensions
            * auth
            * follow_redirects: bool

        :return: Returns the result object if the http request succeeded with status code '2XX'.
        :raises APIError: If the http request has a status code different from `2XX`. This
            object wraps both the http Response and any parsed data.
        """

        # path parameters
        path_params: Dict[str, str] = {
            "name": str(name),
            "version": str(version),
            "wildcard": str(wildcard),
        }

        ## named body parameters
        body_args: Dict[str, Any] = {}
        body_args["content"] = content

        # query parameters
        if query is not None and MODELS_AVAILABLE and validate_request:
            query = TypeAdapter(UpdateAssetQuery).validate_python(query)

        response_types_map: Dict[str, Any] = (
            {"2XX": response_type}
            if response_type is not None
            else {
                "201": PostPlugJobSyncResponseV2 if not select_path else Model,
                "202": PostPlugJobAsyncResponseV2 if not select_path else Model,
            }
        )
        non_200_response_types_map: Dict[str, Any] = {
            "403": RegistryErrorResponse,
        }
        response_types_map.update(non_200_response_types_map)

        ## peform request
        return await self.api_client.request(
            method="PUT",
            resource_path="/registry/v2/plugs/{name}/versions/{version}/content/{wildcard}",
            path_params=path_params,
            params=query,
            **body_args,
            headers=headers,
            **kwargs,
            response_type=response_types_map,
            select_path=select_path,
            raw_response=raw_response,
        )

    @overload
    async def update_assets(
        self,
        name: Annotated[StrictStr, Field(description="The name of the function.")],
        version: Annotated[
            str, Field(strict=True, description="The version of the function.")
        ],
        *,
        content: Annotated[
            RequestContent | None,
            Field(
                description="The assets for a <em>plug</em> function can be provided as either   <ul>     <li>a single <em>tar</em> archive (optionally compressed), with one of the content types      <code>application/octet-stream</code>, <code>application/tar</code>, <code>application/tar+gzip</code>, <code>application/x-gzip</code>, <code>application/x-tar</code>, <code>application/gzip</code></li>     <li>separate files in a <code>multipart/form-data</code> request</li>   </ul>    The provided assets will be added to the <em>plug</em> function's collection of existing assets,   replacing any existing assets with the same name.    Please note that it is not allowed to update the plug.json</code> json file with a changed value for any of the    <code>name</code>, <code>version</code> and/or <code>runtime</code> attributes.    For each <em>runtime</em> other files are supported. "
            ),
        ] = None,
        files: Annotated[
            RequestFiles | None, Field(description="Multipart file upload")
        ] = None,
        query: UpdateAssetsQuery | QueryParamTypes | None = None,
        raw_response: Literal[False] = False,
        select_path: Literal[""] = "",
        response_type: Literal[None] = None,
        validate_request: StrictBool = True,
        headers: HeaderTypes | None = None,
        **kwargs,
    ) -> PostPlugJobSyncResponseV2 | PostPlugJobAsyncResponseV2: ...

    @overload
    async def update_assets(
        self,
        name: Annotated[StrictStr, Field(description="The name of the function.")],
        version: Annotated[
            str, Field(strict=True, description="The version of the function.")
        ],
        *,
        content: Annotated[
            RequestContent | None,
            Field(
                description="The assets for a <em>plug</em> function can be provided as either   <ul>     <li>a single <em>tar</em> archive (optionally compressed), with one of the content types      <code>application/octet-stream</code>, <code>application/tar</code>, <code>application/tar+gzip</code>, <code>application/x-gzip</code>, <code>application/x-tar</code>, <code>application/gzip</code></li>     <li>separate files in a <code>multipart/form-data</code> request</li>   </ul>    The provided assets will be added to the <em>plug</em> function's collection of existing assets,   replacing any existing assets with the same name.    Please note that it is not allowed to update the plug.json</code> json file with a changed value for any of the    <code>name</code>, <code>version</code> and/or <code>runtime</code> attributes.    For each <em>runtime</em> other files are supported. "
            ),
        ] = None,
        files: Annotated[
            RequestFiles | None, Field(description="Multipart file upload")
        ] = None,
        query: UpdateAssetsQuery | QueryParamTypes | None = None,
        raw_response: Literal[False] = False,
        select_path: Literal[""] = "",
        response_type: T,
        validate_request: StrictBool = True,
        headers: HeaderTypes | None = None,
        **kwargs,
    ) -> T: ...

    @overload
    async def update_assets(
        self,
        name: Annotated[StrictStr, Field(description="The name of the function.")],
        version: Annotated[
            str, Field(strict=True, description="The version of the function.")
        ],
        *,
        content: Annotated[
            RequestContent | None,
            Field(
                description="The assets for a <em>plug</em> function can be provided as either   <ul>     <li>a single <em>tar</em> archive (optionally compressed), with one of the content types      <code>application/octet-stream</code>, <code>application/tar</code>, <code>application/tar+gzip</code>, <code>application/x-gzip</code>, <code>application/x-tar</code>, <code>application/gzip</code></li>     <li>separate files in a <code>multipart/form-data</code> request</li>   </ul>    The provided assets will be added to the <em>plug</em> function's collection of existing assets,   replacing any existing assets with the same name.    Please note that it is not allowed to update the plug.json</code> json file with a changed value for any of the    <code>name</code>, <code>version</code> and/or <code>runtime</code> attributes.    For each <em>runtime</em> other files are supported. "
            ),
        ] = None,
        files: Annotated[
            RequestFiles | None, Field(description="Multipart file upload")
        ] = None,
        query: UpdateAssetsQuery | QueryParamTypes | None = None,
        raw_response: Literal[True],
        select_path: Literal["_not_used_"] = "_not_used_",
        response_type: Literal[None] = None,  # not used
        validate_request: StrictBool = True,
        headers: HeaderTypes | None = None,
        **kwargs,
    ) -> Response: ...

    @overload
    async def update_assets(
        self,
        name: Annotated[StrictStr, Field(description="The name of the function.")],
        version: Annotated[
            str, Field(strict=True, description="The version of the function.")
        ],
        *,
        content: Annotated[
            RequestContent | None,
            Field(
                description="The assets for a <em>plug</em> function can be provided as either   <ul>     <li>a single <em>tar</em> archive (optionally compressed), with one of the content types      <code>application/octet-stream</code>, <code>application/tar</code>, <code>application/tar+gzip</code>, <code>application/x-gzip</code>, <code>application/x-tar</code>, <code>application/gzip</code></li>     <li>separate files in a <code>multipart/form-data</code> request</li>   </ul>    The provided assets will be added to the <em>plug</em> function's collection of existing assets,   replacing any existing assets with the same name.    Please note that it is not allowed to update the plug.json</code> json file with a changed value for any of the    <code>name</code>, <code>version</code> and/or <code>runtime</code> attributes.    For each <em>runtime</em> other files are supported. "
            ),
        ] = None,
        files: Annotated[
            RequestFiles | None, Field(description="Multipart file upload")
        ] = None,
        query: UpdateAssetsQuery | QueryParamTypes | None = None,
        raw_response: Literal[False] = False,
        select_path: str,
        response_type: Literal[None] = None,
        validate_request: StrictBool = True,
        headers: HeaderTypes | None = None,
        **kwargs,
    ) -> Model: ...

    @overload
    async def update_assets(
        self,
        name: Annotated[StrictStr, Field(description="The name of the function.")],
        version: Annotated[
            str, Field(strict=True, description="The version of the function.")
        ],
        *,
        content: Annotated[
            RequestContent | None,
            Field(
                description="The assets for a <em>plug</em> function can be provided as either   <ul>     <li>a single <em>tar</em> archive (optionally compressed), with one of the content types      <code>application/octet-stream</code>, <code>application/tar</code>, <code>application/tar+gzip</code>, <code>application/x-gzip</code>, <code>application/x-tar</code>, <code>application/gzip</code></li>     <li>separate files in a <code>multipart/form-data</code> request</li>   </ul>    The provided assets will be added to the <em>plug</em> function's collection of existing assets,   replacing any existing assets with the same name.    Please note that it is not allowed to update the plug.json</code> json file with a changed value for any of the    <code>name</code>, <code>version</code> and/or <code>runtime</code> attributes.    For each <em>runtime</em> other files are supported. "
            ),
        ] = None,
        files: Annotated[
            RequestFiles | None, Field(description="Multipart file upload")
        ] = None,
        query: UpdateAssetsQuery | QueryParamTypes | None = None,
        raw_response: Literal[False] = False,
        select_path: str,
        response_type: T,
        validate_request: StrictBool = True,
        headers: HeaderTypes | None = None,
        **kwargs,
    ) -> T: ...

    async def update_assets(
        self,
        name: Annotated[StrictStr, Field(description="The name of the function.")],
        version: Annotated[
            str, Field(strict=True, description="The version of the function.")
        ],
        *,
        content: Annotated[
            RequestContent | None,
            Field(
                description="The assets for a <em>plug</em> function can be provided as either   <ul>     <li>a single <em>tar</em> archive (optionally compressed), with one of the content types      <code>application/octet-stream</code>, <code>application/tar</code>, <code>application/tar+gzip</code>, <code>application/x-gzip</code>, <code>application/x-tar</code>, <code>application/gzip</code></li>     <li>separate files in a <code>multipart/form-data</code> request</li>   </ul>    The provided assets will be added to the <em>plug</em> function's collection of existing assets,   replacing any existing assets with the same name.    Please note that it is not allowed to update the plug.json</code> json file with a changed value for any of the    <code>name</code>, <code>version</code> and/or <code>runtime</code> attributes.    For each <em>runtime</em> other files are supported. "
            ),
        ] = None,
        files: Annotated[
            RequestFiles | None, Field(description="Multipart file upload")
        ] = None,
        query: UpdateAssetsQuery | QueryParamTypes | None = None,
        raw_response: StrictBool = False,
        select_path: str = "",
        response_type: T | None = None,
        validate_request: StrictBool = True,
        headers: HeaderTypes | None = None,
        **kwargs,
    ) -> PostPlugJobSyncResponseV2 | PostPlugJobAsyncResponseV2 | T | Response | Model:
        """Update Plug Assets.

        Update a draft <em>plug</em> function by updating its assets.      The assets for a <em>plug</em> function can be provided as either   <ul>     <li>a single <em>tar</em> archive (optionally compressed), with one of the content types      <code>application/octet-stream</code>, <code>application/tar</code>, <code>application/tar+gzip</code>, <code>application/x-gzip</code>, <code>application/x-tar</code>, <code>application/gzip</code></li>     <li>separate files in a <code>multipart/form-data</code> request</li>   </ul>    The provided assets will be added to the <em>plug</em> function's collection of existing assets,   replacing any existing assets with the same name.    Please note that it is not allowed to update the plug.json</code> json file with a changed value for any of the    <code>name</code>, <code>version</code> and/or <code>runtime</code> attributes.    For each <em>runtime</em> other files are supported.
        :param name: The name of the function. (required)
        :type name: str
        :param version: The version of the function. (required)
        :type version: str
        :param content: The assets for a <em>plug</em> function can be provided as either   <ul>     <li>a single <em>tar</em> archive (optionally compressed), with one of the content types      <code>application/octet-stream</code>, <code>application/tar</code>, <code>application/tar+gzip</code>, <code>application/x-gzip</code>, <code>application/x-tar</code>, <code>application/gzip</code></li>     <li>separate files in a <code>multipart/form-data</code> request</li>   </ul>    The provided assets will be added to the <em>plug</em> function's collection of existing assets,   replacing any existing assets with the same name.    Please note that it is not allowed to update the plug.json</code> json file with a changed value for any of the    <code>name</code>, <code>version</code> and/or <code>runtime</code> attributes.    For each <em>runtime</em> other files are supported.
        :type content: ContentRequest, optional
        :param files: The files of a `content-type: multipart/form-data` request.
        :type files: FilesRequest, optional
        :param query: URL Query parameters.
        :type query: UpdateAssetsQuery | QueryParamTypes, optional
        :param query['scaleToZero'] (dict) <br> query.scale_to_zero (Query) : If set to <code>true</code>, after successful deployment, the deployed function will be scaled to zero. This saves computing resources when the function is not to be used immediately.
        :type query['scaleToZero']: bool
        :param query['deploy'] (dict) <br> query.deploy (Query) : Indicates that a function should be _deployed_ when its assets are valid.  * If `true` (default), jobs to build and deploy the function will be initiated after it is checked that the assets are valid. Invalid assets lead to a validation error, and the function and its assets are not created or updated. * If `false`, the uploaded assets are stored and the function is created/updated in `registered` state. Asset validation errors are only returned as warning, and stored as `failureReason` on the function entity. Use an _asset update_ or _rebuild_ to initiate a build and deploy at a later stage.
        :type query['deploy']: bool
        :param query['chown'] (dict) <br> query.chown (Query) : If set, ownership of the draft function is transferred to the current user.
        :type query['chown']: bool
        :param query['comment'] (dict) <br> query.comment (Query) : An optional user-specified comment corresponding to the operation.
        :type query['comment']: str
        :param query['author'] (dict) <br> query.author (Query) : Optionally changes the author metadata when updating a function.
        :type query['author']: str
        :param query['async'] (dict) <br> query.var_async (Query) : Unless this is set to <code>false</code>, the server will start the required job actions asynchronously and return a <code>202</code> <em>Accepted</em> response. If <code>false</code> the request will block until the job actions are completed, or a timeout occurs.
        :type query['async']: bool
        :param raw_response: If true, return the http Response object instead of returning an api model object, or throwing an ApiError.
        :param select_path: Denotes the json path applied to the response object before returning it.
                Set it to the empty string `""` to receive the full response object.
        :param response_type: If specified, the response is parsed into an instance of the specified type.
        :param validate_request: If set to false, the request body and query parameters are NOT validated against the models in the service types package, even when available.
        :param headers: Header parameters for this request
        :type headers: dict, optional
        :param `**kwargs`: Additional parameters passed on to the http client.
            See below.
        :Keyword Arguments:
            * timeout: a single numeric timeout in seconds,
                or a tuple of _connect_, _read_, _write_ and _pool_ timeouts.
            * stream: if true, the response will be in streaming mode
            * cookies
            * extensions
            * auth
            * follow_redirects: bool

        :return: Returns the result object if the http request succeeded with status code '2XX'.
        :raises APIError: If the http request has a status code different from `2XX`. This
            object wraps both the http Response and any parsed data.
        """

        # path parameters
        path_params: Dict[str, str] = {
            "name": str(name),
            "version": str(version),
        }

        ## named body parameters
        body_args: Dict[str, Any] = {}
        body_args["content"] = content
        body_args["files"] = files

        # query parameters
        if query is not None and MODELS_AVAILABLE and validate_request:
            query = TypeAdapter(UpdateAssetsQuery).validate_python(query)

        response_types_map: Dict[str, Any] = (
            {"2XX": response_type}
            if response_type is not None
            else {
                "201": PostPlugJobSyncResponseV2 if not select_path else Model,
                "202": PostPlugJobAsyncResponseV2 if not select_path else Model,
            }
        )
        non_200_response_types_map: Dict[str, Any] = {
            "403": RegistryErrorResponse,
        }
        response_types_map.update(non_200_response_types_map)

        ## peform request
        return await self.api_client.request(
            method="PUT",
            resource_path="/registry/v2/plugs/{name}/versions/{version}/content",
            path_params=path_params,
            params=query,
            **body_args,
            headers=headers,
            **kwargs,
            response_type=response_types_map,
            select_path=select_path,
            raw_response=raw_response,
        )

    @overload
    async def verify(
        self,
        name: Annotated[StrictStr, Field(description="The name of the function.")],
        version: Annotated[
            str, Field(strict=True, description="The version of the function.")
        ],
        *,
        query: VerifyQuery | QueryParamTypes | None = None,
        raw_response: Literal[False] = False,
        select_path: Literal[""] = "",
        response_type: Literal[None] = None,
        validate_request: StrictBool = True,
        headers: HeaderTypes | None = None,
        **kwargs,
    ) -> VerifyPlugSyncResponseV2 | PostPlugJobAsyncResponseV2: ...

    @overload
    async def verify(
        self,
        name: Annotated[StrictStr, Field(description="The name of the function.")],
        version: Annotated[
            str, Field(strict=True, description="The version of the function.")
        ],
        *,
        query: VerifyQuery | QueryParamTypes | None = None,
        raw_response: Literal[False] = False,
        select_path: Literal[""] = "",
        response_type: T,
        validate_request: StrictBool = True,
        headers: HeaderTypes | None = None,
        **kwargs,
    ) -> T: ...

    @overload
    async def verify(
        self,
        name: Annotated[StrictStr, Field(description="The name of the function.")],
        version: Annotated[
            str, Field(strict=True, description="The version of the function.")
        ],
        *,
        query: VerifyQuery | QueryParamTypes | None = None,
        raw_response: Literal[True],
        select_path: Literal["_not_used_"] = "_not_used_",
        response_type: Literal[None] = None,  # not used
        validate_request: StrictBool = True,
        headers: HeaderTypes | None = None,
        **kwargs,
    ) -> Response: ...

    @overload
    async def verify(
        self,
        name: Annotated[StrictStr, Field(description="The name of the function.")],
        version: Annotated[
            str, Field(strict=True, description="The version of the function.")
        ],
        *,
        query: VerifyQuery | QueryParamTypes | None = None,
        raw_response: Literal[False] = False,
        select_path: str,
        response_type: Literal[None] = None,
        validate_request: StrictBool = True,
        headers: HeaderTypes | None = None,
        **kwargs,
    ) -> Model: ...

    @overload
    async def verify(
        self,
        name: Annotated[StrictStr, Field(description="The name of the function.")],
        version: Annotated[
            str, Field(strict=True, description="The version of the function.")
        ],
        *,
        query: VerifyQuery | QueryParamTypes | None = None,
        raw_response: Literal[False] = False,
        select_path: str,
        response_type: T,
        validate_request: StrictBool = True,
        headers: HeaderTypes | None = None,
        **kwargs,
    ) -> T: ...

    async def verify(
        self,
        name: Annotated[StrictStr, Field(description="The name of the function.")],
        version: Annotated[
            str, Field(strict=True, description="The version of the function.")
        ],
        *,
        query: VerifyQuery | QueryParamTypes | None = None,
        raw_response: StrictBool = False,
        select_path: str = "",
        response_type: T | None = None,
        validate_request: StrictBool = True,
        headers: HeaderTypes | None = None,
        **kwargs,
    ) -> VerifyPlugSyncResponseV2 | PostPlugJobAsyncResponseV2 | T | Response | Model:
        """Verify Health Of Plug.

        Verify health of plug deployed on openfaas.
        :param name: The name of the function. (required)
        :type name: str
        :param version: The version of the function. (required)
        :type version: str
        :param query: URL Query parameters.
        :type query: VerifyQuery | QueryParamTypes, optional
        :param query['scaleToZero'] (dict) <br> query.scale_to_zero (Query) : Indicates whether the function needs to be scaled down after successful verification. If not set, the function is scaled to zero only if it was not active before this command.
        :type query['scaleToZero']: bool
        :param query['async'] (dict) <br> query.var_async (Query) : Unless this is set to <code>false</code>, the server will start the required job actions asynchronously and return a <code>202</code> <em>Accepted</em> response. If <code>false</code> the request will block until the job actions are completed, or a timeout occurs.
        :type query['async']: bool
        :param raw_response: If true, return the http Response object instead of returning an api model object, or throwing an ApiError.
        :param select_path: Denotes the json path applied to the response object before returning it.
                Set it to the empty string `""` to receive the full response object.
        :param response_type: If specified, the response is parsed into an instance of the specified type.
        :param validate_request: If set to false, the request body and query parameters are NOT validated against the models in the service types package, even when available.
        :param headers: Header parameters for this request
        :type headers: dict, optional
        :param `**kwargs`: Additional parameters passed on to the http client.
            See below.
        :Keyword Arguments:
            * timeout: a single numeric timeout in seconds,
                or a tuple of _connect_, _read_, _write_ and _pool_ timeouts.
            * stream: if true, the response will be in streaming mode
            * cookies
            * extensions
            * auth
            * follow_redirects: bool

        :return: Returns the result object if the http request succeeded with status code '2XX'.
        :raises APIError: If the http request has a status code different from `2XX`. This
            object wraps both the http Response and any parsed data.
        """

        # path parameters
        path_params: Dict[str, str] = {
            "name": str(name),
            "version": str(version),
        }

        ## named body parameters
        body_args: Dict[str, Any] = {}

        # query parameters
        if query is not None and MODELS_AVAILABLE and validate_request:
            query = TypeAdapter(VerifyQuery).validate_python(query)

        response_types_map: Dict[str, Any] = (
            {"2XX": response_type}
            if response_type is not None
            else {
                "200": VerifyPlugSyncResponseV2 if not select_path else Model,
                "202": PostPlugJobAsyncResponseV2 if not select_path else Model,
            }
        )
        non_200_response_types_map: Dict[str, Any] = {}
        response_types_map.update(non_200_response_types_map)

        ## peform request
        return await self.api_client.request(
            method="POST",
            resource_path="/registry/v2/plugs/{name}/versions/{version}/verify",
            path_params=path_params,
            params=query,
            **body_args,
            headers=headers,
            **kwargs,
            response_type=response_types_map,
            select_path=select_path,
            raw_response=raw_response,
        )
