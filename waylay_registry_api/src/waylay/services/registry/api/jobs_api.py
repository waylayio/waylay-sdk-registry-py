# coding: utf-8
"""Waylay Function Registry api.

This code was generated from the OpenAPI documentation of 'Waylay Function Registry'

Generated by OpenAPI Generator (https://openapi-generator.tech)

Do not edit the class manually.
"""

from __future__ import annotations  # for Python 3.7â€“3.9

import enum
from pydantic import validate_call, StrictStr, StrictBool
from typing import (
    Dict,
    Literal,
    Optional,
    Union,
    Any,
    overload,
    TYPE_CHECKING,
)

from waylay.sdk.plugin import WithApiClient
from waylay.sdk.api import Request, Response, HeaderTypes, RequestFiles
from httpx import Headers

if TYPE_CHECKING:
    from waylay.services.registry.queries.jobs_api import EventsQuery

    from waylay.services.registry.models import EventWithCloseSSE

    from waylay.services.registry.models import EventWithCloseSSE

    from waylay.services.registry.models import JobType

    from waylay.services.registry.queries.jobs_api import GetQuery

    from waylay.services.registry.models import JobResponse

    from waylay.services.registry.models import JobResponse

    from waylay.services.registry.queries.jobs_api import ListQuery

    from waylay.services.registry.models import JobsResponse

    from waylay.services.registry.models import JobsResponse


try:
    from waylay.services.registry.queries.jobs_api import EventsQuery

    from waylay.services.registry.models import EventWithCloseSSE

    from waylay.services.registry.models import EventWithCloseSSE

    from waylay.services.registry.models import JobType

    from waylay.services.registry.queries.jobs_api import GetQuery

    from waylay.services.registry.models import JobResponse

    from waylay.services.registry.models import JobResponse

    from waylay.services.registry.queries.jobs_api import ListQuery

    from waylay.services.registry.models import JobsResponse

    from waylay.services.registry.models import JobsResponse

    types_available = True
except ImportError:
    types_available = False

    if not TYPE_CHECKING:
        EventsQuery = dict

        EventWithCloseSSE = Any

        EventWithCloseSSE = Any

        JobType = str

        GetQuery = dict

        JobResponse = Any

        JobResponse = Any

        ListQuery = dict

        JobsResponse = Any

        JobsResponse = Any


class JobsApi(WithApiClient):
    """JobsApi service methods.

    NOTE: This class is auto generated by OpenAPI Generator
    Ref: https://openapi-generator.tech

    Do not edit the class manually.
    """

    @overload
    async def events(
        self,
        *,
        query: Optional[EventsQuery] = None,
        raw_response: Literal[False] = False,
        select_path: Literal[""],
        headers: Optional[HeaderTypes] = None,
        **kwargs,
    ) -> EventWithCloseSSE: ...

    @overload
    async def events(
        self,
        *,
        query: Optional[EventsQuery] = None,
        raw_response: Literal[True],
        select_path: Literal["_not_used_"] = "_not_used_",
        headers: Optional[HeaderTypes] = None,
        **kwargs,
    ) -> Response: ...

    @validate_call
    async def events(
        self,
        *,
        query: Optional[EventsQuery] = None,
        raw_response: StrictBool = False,
        select_path: str = "",
        headers: Optional[HeaderTypes] = None,
        **kwargs,
    ) -> Union[EventWithCloseSSE, Response, Any]:
        """Stream Events.

        Get an SSE stream of all job events for the users tenant.  The stream can be filtered on job type or on a specific job id.   When filtering on job id, the server will send a <code>close</code> event  upon completion of the job. The client should handle this event by closing the stream.

        :param query: Supported query params. (optional)
        :type query: TypedDict, optional:
            :param query.type: The type of the job.
            :type query.type: JobType
            :param query.id: The id of the job.
            :type query.id: str
            :param query.children: If set to <code>true</code>, the event stream will include events of the job's dependants. E.g., when subscribing to a verify job with `children=true`, you will also receive the events of the underlying build and deploy jobs. Defaults to <code>false</code>.
            :type query.children: bool
        :raw_response: If true, return the http Response object instead of returning an api model object, or throwing an ApiError.
        :select_path: Denotes the json path applied to the response object before returning it.
                Set it to the empty string `""` to receive the full response object.
        :param headers: Header parameters for this request
        :type headers: dict, optional
        :param `**kwargs`: Additional parameters passed on to the http client.
            See below.
        :Keyword Arguments:
            * timeout: a single numeric timeout in seconds,
                or a tuple of _connect_, _read_, _write_ and _pool_ timeouts.
            * stream: if true, the response will be in streaming mode
            * cookies
            * extensions
            * auth
            * follow_redirects: bool

        :return: Returns the result object if the http request succeeded with status code '2XX'.
        :raises APIError: If the http request has a status code different from `2XX`. This
            object wraps both the http Response and any parsed data.
        """
        send_args = {}
        for key in ["stream", "follow_redirects", "auth"]:
            if key in kwargs:
                send_args[key] = kwargs.pop(key)
        api_request = self._events_serialize(
            body=None,
            files=None,
            query=query,
            headers=headers,
            **kwargs,
        )
        response = await self.api_client.send(api_request, **send_args)
        if raw_response:
            return response
        response_types_map: Dict[str, Optional[Union[str, Any]]] = {
            "200": EventWithCloseSSE if not select_path else Any,
        }
        stream = send_args.get("stream", False)
        return self.api_client.response_deserialize(
            response, response_types_map, select_path, stream=stream
        )

    def _events_serialize(
        self,
        body,
        files: Optional[RequestFiles],
        query,
        headers: Optional[HeaderTypes] = None,
        **kwargs,
    ) -> Request:
        _path_params: Dict[str, str] = {}
        _query_params: Dict[str, Any] = {}
        _header_params: Headers = Headers(headers) if headers else Headers()
        _files: Optional[RequestFiles] = None
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        if query is not None:
            query_param = query.get("type", None)
            if query_param is not None:
                _query_params["type"] = query_param.value
            query_param = query.get("id", None)
            if query_param is not None:
                _query_params["id"] = query_param
            query_param = query.get("children", None)
            if query_param is not None:
                _query_params["children"] = query_param
        # process the form parameters
        # process the body parameter

        headers = _header_params
        return self.api_client.build_api_request(
            method="GET",
            resource_path="/registry/v2/jobs/events",
            path_params=_path_params,
            query_params=_query_params,
            body=_body_params,
            files=_files,
            headers=headers,
            **kwargs,
        )

    @overload
    async def get(
        self,
        type: JobType,
        id: StrictStr,
        *,
        query: Optional[GetQuery] = None,
        raw_response: Literal[False] = False,
        select_path: Literal[""],
        headers: Optional[HeaderTypes] = None,
        **kwargs,
    ) -> JobResponse: ...

    @overload
    async def get(
        self,
        type: JobType,
        id: StrictStr,
        *,
        query: Optional[GetQuery] = None,
        raw_response: Literal[True],
        select_path: Literal["_not_used_"] = "_not_used_",
        headers: Optional[HeaderTypes] = None,
        **kwargs,
    ) -> Response: ...

    @validate_call
    async def get(
        self,
        type: JobType,
        id: StrictStr,
        *,
        query: Optional[GetQuery] = None,
        raw_response: StrictBool = False,
        select_path: str = "",
        headers: Optional[HeaderTypes] = None,
        **kwargs,
    ) -> Union[JobResponse, Response, Any]:
        """Get Job.

        Get a background job by type and id.

        :param type: (required)
        :type type: JobType
        :param id: (required)
        :type id: str
        :param query: Supported query params. (optional)
        :type query: TypedDict, optional:
        :raw_response: If true, return the http Response object instead of returning an api model object, or throwing an ApiError.
        :select_path: Denotes the json path applied to the response object before returning it.
                Set it to the empty string `""` to receive the full response object.
        :param headers: Header parameters for this request
        :type headers: dict, optional
        :param `**kwargs`: Additional parameters passed on to the http client.
            See below.
        :Keyword Arguments:
            * timeout: a single numeric timeout in seconds,
                or a tuple of _connect_, _read_, _write_ and _pool_ timeouts.
            * stream: if true, the response will be in streaming mode
            * cookies
            * extensions
            * auth
            * follow_redirects: bool

        :return: Returns the result object if the http request succeeded with status code '2XX'.
        :raises APIError: If the http request has a status code different from `2XX`. This
            object wraps both the http Response and any parsed data.
        """
        send_args = {}
        for key in ["stream", "follow_redirects", "auth"]:
            if key in kwargs:
                send_args[key] = kwargs.pop(key)
        api_request = self._get_serialize(
            type=type,
            id=id,
            body=None,
            files=None,
            query=query,
            headers=headers,
            **kwargs,
        )
        response = await self.api_client.send(api_request, **send_args)
        if raw_response:
            return response
        response_types_map: Dict[str, Optional[Union[str, Any]]] = {
            "200": JobResponse if not select_path else Any,
        }
        stream = send_args.get("stream", False)
        return self.api_client.response_deserialize(
            response, response_types_map, select_path, stream=stream
        )

    def _get_serialize(
        self,
        type,
        id,
        body,
        files: Optional[RequestFiles],
        query,
        headers: Optional[HeaderTypes] = None,
        **kwargs,
    ) -> Request:
        _path_params: Dict[str, str] = {}
        _query_params: Dict[str, Any] = {}
        _header_params: Headers = Headers(headers) if headers else Headers()
        _files: Optional[RequestFiles] = None
        _body_params: Optional[bytes] = None

        # process the path parameters
        if type is not None:
            _path_params["type"] = type.value
        if id is not None:
            _path_params["id"] = id
        # process the query parameters
        if query is not None:
            pass
        # process the form parameters
        # process the body parameter

        headers = _header_params
        return self.api_client.build_api_request(
            method="GET",
            resource_path="/registry/v2/jobs/{type}/{id}",
            path_params=_path_params,
            query_params=_query_params,
            body=_body_params,
            files=_files,
            headers=headers,
            **kwargs,
        )

    @overload
    async def list(
        self,
        *,
        query: Optional[ListQuery] = None,
        raw_response: Literal[False] = False,
        select_path: Literal[""],
        headers: Optional[HeaderTypes] = None,
        **kwargs,
    ) -> JobsResponse: ...

    @overload
    async def list(
        self,
        *,
        query: Optional[ListQuery] = None,
        raw_response: Literal[True],
        select_path: Literal["_not_used_"] = "_not_used_",
        headers: Optional[HeaderTypes] = None,
        **kwargs,
    ) -> Response: ...

    @validate_call
    async def list(
        self,
        *,
        query: Optional[ListQuery] = None,
        raw_response: StrictBool = False,
        select_path: str = "",
        headers: Optional[HeaderTypes] = None,
        **kwargs,
    ) -> Union[JobsResponse, Response, Any]:
        """List Jobs.

        List all background jobs for the users tenant.

        :param query: Supported query params. (optional)
        :type query: TypedDict, optional:
            :param query.limit: The maximum number of items to be return from this query. Has a deployment-defined default and maximum value.
            :type query.limit: float
            :param query.type: Filter on job type
            :type query.type: List[JobTypeSchema]
            :param query.state: Filter on job state
            :type query.state: List[JobStateResult]
            :param query.function_type: Filter on function type
            :type query.function_type: List[FunctionType]
            :param query.created_before: Filter on jobs that created before the given timestamp or age
            :type query.created_before: TimestampSpec
            :param query.created_after: Filter on jobs that created after the given timestamp or age
            :type query.created_after: TimestampSpec
        :raw_response: If true, return the http Response object instead of returning an api model object, or throwing an ApiError.
        :select_path: Denotes the json path applied to the response object before returning it.
                Set it to the empty string `""` to receive the full response object.
        :param headers: Header parameters for this request
        :type headers: dict, optional
        :param `**kwargs`: Additional parameters passed on to the http client.
            See below.
        :Keyword Arguments:
            * timeout: a single numeric timeout in seconds,
                or a tuple of _connect_, _read_, _write_ and _pool_ timeouts.
            * stream: if true, the response will be in streaming mode
            * cookies
            * extensions
            * auth
            * follow_redirects: bool

        :return: Returns the result object if the http request succeeded with status code '2XX'.
        :raises APIError: If the http request has a status code different from `2XX`. This
            object wraps both the http Response and any parsed data.
        """
        send_args = {}
        for key in ["stream", "follow_redirects", "auth"]:
            if key in kwargs:
                send_args[key] = kwargs.pop(key)
        api_request = self._list_serialize(
            body=None,
            files=None,
            query=query,
            headers=headers,
            **kwargs,
        )
        response = await self.api_client.send(api_request, **send_args)
        if raw_response:
            return response
        response_types_map: Dict[str, Optional[Union[str, Any]]] = {
            "200": JobsResponse if not select_path else Any,
        }
        stream = send_args.get("stream", False)
        return self.api_client.response_deserialize(
            response, response_types_map, select_path, stream=stream
        )

    def _list_serialize(
        self,
        body,
        files: Optional[RequestFiles],
        query,
        headers: Optional[HeaderTypes] = None,
        **kwargs,
    ) -> Request:
        _path_params: Dict[str, str] = {}
        _query_params: Dict[str, Any] = {}
        _header_params: Headers = Headers(headers) if headers else Headers()
        _files: Optional[RequestFiles] = None
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        if query is not None:
            query_param = query.get("limit", None)
            if query_param is not None:
                _query_params["limit"] = query_param
            query_param = query.get("type", None)
            if query_param is not None:
                _query_params["type"] = query_param
            query_param = query.get("state", None)
            if query_param is not None:
                _query_params["state"] = query_param
            query_param = query.get("function_type", None)
            if query_param is not None:
                _query_params["functionType"] = [
                    v.value if isinstance(v, enum.Enum) else v for v in query_param
                ]
            query_param = query.get("created_before", None)
            if query_param is not None:
                _query_params["createdBefore"] = query_param
            query_param = query.get("created_after", None)
            if query_param is not None:
                _query_params["createdAfter"] = query_param
        # process the form parameters
        # process the body parameter

        headers = _header_params
        return self.api_client.build_api_request(
            method="GET",
            resource_path="/registry/v2/jobs/",
            path_params=_path_params,
            query_params=_query_params,
            body=_body_params,
            files=_files,
            headers=headers,
            **kwargs,
        )
