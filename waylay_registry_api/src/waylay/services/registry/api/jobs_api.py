# coding: utf-8
"""Waylay Function Registry api.

This code was generated from the OpenAPI documentation of 'Waylay Function Registry'

Generated by OpenAPI Generator (https://openapi-generator.tech)

Do not edit the class manually.
"""


from __future__ import annotations  # for Python 3.7â€“3.9
import io
import warnings

import enum
from pydantic import validate_call, Field, StrictFloat, StrictStr, StrictInt, StrictBool, StrictBytes
from typing import Dict, List, Literal, Optional, Tuple, Union, Any, overload, TYPE_CHECKING
from typing_extensions import NotRequired, TypedDict

from waylay.sdk.api import ApiValueError

try:
    from typing import Annotated
except ImportError:
    from typing_extensions import Annotated  # type: ignore

if TYPE_CHECKING:

    from waylay.services.registry.models import JobType

    from waylay.services.registry.queries.jobs_api import EventsQuery
    from waylay.services.registry.queries.jobs_api import GetQuery
    from waylay.services.registry.queries.jobs_api import ListQuery

    from waylay.services.registry.models import EventWithCloseSSE

    from waylay.services.registry.models import JobResponse

    from waylay.services.registry.models import JobsResponse


try:

    from waylay.services.registry.models import JobType

    from waylay.services.registry.queries.jobs_api import EventsQuery
    from waylay.services.registry.queries.jobs_api import GetQuery
    from waylay.services.registry.queries.jobs_api import ListQuery

    from waylay.services.registry.models import EventWithCloseSSE

    from waylay.services.registry.models import JobResponse

    from waylay.services.registry.models import JobsResponse

    types_available = True
except ImportError:
    types_available = False

    if not TYPE_CHECKING:

        JobType = str

        EventsQuery = Dict
        GetQuery = Dict
        ListQuery = Dict

        EventWithCloseSSE = Any

        JobResponse = Any

        JobsResponse = Any


from waylay.sdk.api import (
    ApiClient, ApiResponse, RESTTimeout
)


class JobsApi:
    """JobsApi service methods.

    NOTE: This class is auto generated by OpenAPI Generator
    Ref: https://openapi-generator.tech

    Do not edit the class manually.
    """

    def __init__(self, api_client: ApiClient) -> None:
        """Create a JobsApi instance."""
        self._api_client: ApiClient = api_client

    @overload
    async def events(
        self,
        *,
        query: Optional[EventsQuery] = None,
        _request_timeout: Optional[RESTTimeout] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        with_http_info: Literal[False] = False,
    ) -> EventWithCloseSSE: ...

    @overload
    async def events(
        self,
        *,
        query: Optional[EventsQuery] = None,
        _request_timeout: Optional[RESTTimeout] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        with_http_info: Literal[True],
    ) -> ApiResponse[EventWithCloseSSE]: ...

    @validate_call
    async def events(
        self,
        *,
        query: Optional[EventsQuery] = None,
        _request_timeout: Optional[RESTTimeout] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        with_http_info: StrictBool = False,
    ) -> Union[EventWithCloseSSE, ApiResponse[EventWithCloseSSE]]:
        """Stream Events.

        Get an SSE stream of all job events for the users tenant.  The stream can be filtered on job type or on a specific job id.   When filtering on job id, the server will send a <code>close</code> event  upon completion of the job. The client should handle this event by closing the stream.

        :param query: Supported query params. (optional)
        :type query: TypedDict, optional:
            :param query.type: The type of the job.
            :type query.type: JobType
            :param query.id: The id of the job.
            :type query.id: str
            :param query.children: If set to <code>true</code>, the event stream will include events of the job's dependants. E.g., when subscribing to a verify job with `children=true`, you will also receive the events of the underlying build and deploy jobs. Defaults to <code>false</code>.
            :type query.children: bool
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :return: Returns the result object.
        """

        _request_params = self._events_serialize(
            body=None,
            files=None,
            query=query,
            _headers=_headers,
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "waylay.services.registry.models.EventWithCloseSSE",
        }
        response_data = await self._api_client.call_api(
            **_request_params,
            _request_timeout=_request_timeout
        )
        result = self._api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )
        return result if with_http_info else result.data

    def _events_serialize(
        self,
        body,
        files,
        query,
        _headers,
    ) -> dict[str, Any]:

        _path_params: Dict[str, str] = {}
        _query_params: Dict[str, Any] = {}
        _header_params: Dict[str, Optional[str]] = {k.lower(): v for k, v in _headers.items()} if _headers else {}
        _form_params: Dict[str, str] = {}
        _files: Dict[str, str] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        if query is not None:
            query_param = query.get('type', None)
            if query_param is not None:
                _query_params['type'] = query_param.value

            query_param = query.get('id', None)
            if query_param is not None:
                _query_params['id'] = query_param

            query_param = query.get('children', None)
            if query_param is not None:
                _query_params['children'] = query_param

        # process the form parameters
        # process the body parameter

        return self._api_client.param_serialize(
            method='GET',
            resource_path='/registry/v2/jobs/events',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            files=_files,
        )

    @overload
    async def get(
        self,
        type: JobType,
        id: StrictStr,
        *,
        query: Optional[GetQuery] = None,
        _request_timeout: Optional[RESTTimeout] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        with_http_info: Literal[False] = False,
    ) -> JobResponse: ...

    @overload
    async def get(
        self,
        type: JobType,
        id: StrictStr,
        *,
        query: Optional[GetQuery] = None,
        _request_timeout: Optional[RESTTimeout] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        with_http_info: Literal[True],
    ) -> ApiResponse[JobResponse]: ...

    @validate_call
    async def get(
        self,
        type: JobType,
        id: StrictStr,
        *,
        query: Optional[GetQuery] = None,
        _request_timeout: Optional[RESTTimeout] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        with_http_info: StrictBool = False,
    ) -> Union[JobResponse, ApiResponse[JobResponse]]:
        """Get Job.

        Get a background job by type and id.

        :param type: (required)
        :type type: JobType
        :param id: (required)
        :type id: str
        :param query: Supported query params. (optional)
        :type query: TypedDict, optional:
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :return: Returns the result object.
        """

        _request_params = self._get_serialize(
            type=type,
            id=id,
            body=None,
            files=None,
            query=query,
            _headers=_headers,
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "waylay.services.registry.models.JobResponse",
        }
        response_data = await self._api_client.call_api(
            **_request_params,
            _request_timeout=_request_timeout
        )
        result = self._api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )
        return result if with_http_info else result.data

    def _get_serialize(
        self,
        type,
        id,
        body,
        files,
        query,
        _headers,
    ) -> dict[str, Any]:

        _path_params: Dict[str, str] = {}
        _query_params: Dict[str, Any] = {}
        _header_params: Dict[str, Optional[str]] = {k.lower(): v for k, v in _headers.items()} if _headers else {}
        _form_params: Dict[str, str] = {}
        _files: Dict[str, str] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if type is not None:
            _path_params['type'] = type.value
        if id is not None:
            _path_params['id'] = id
        # process the query parameters
        if query is not None:
            pass
        # process the form parameters
        # process the body parameter

        return self._api_client.param_serialize(
            method='GET',
            resource_path='/registry/v2/jobs/{type}/{id}',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            files=_files,
        )

    @overload
    async def list(
        self,
        *,
        query: Optional[ListQuery] = None,
        _request_timeout: Optional[RESTTimeout] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        with_http_info: Literal[False] = False,
    ) -> JobsResponse: ...

    @overload
    async def list(
        self,
        *,
        query: Optional[ListQuery] = None,
        _request_timeout: Optional[RESTTimeout] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        with_http_info: Literal[True],
    ) -> ApiResponse[JobsResponse]: ...

    @validate_call
    async def list(
        self,
        *,
        query: Optional[ListQuery] = None,
        _request_timeout: Optional[RESTTimeout] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        with_http_info: StrictBool = False,
    ) -> Union[JobsResponse, ApiResponse[JobsResponse]]:
        """List Jobs.

        List all background jobs for the users tenant.

        :param query: Supported query params. (optional)
        :type query: TypedDict, optional:
            :param query.limit: The maximum number of items to be return from this query. Has a deployment-defined default and maximum value.
            :type query.limit: float
            :param query.type: Filter on job type
            :type query.type: List[JobTypeSchema]
            :param query.state: Filter on job state
            :type query.state: List[JobStateResult]
            :param query.function_type: Filter on function type
            :type query.function_type: List[FunctionType]
            :param query.created_before: Filter on jobs that created before the given timestamp or age
            :type query.created_before: TimestampSpec
            :param query.created_after: Filter on jobs that created after the given timestamp or age
            :type query.created_after: TimestampSpec
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :return: Returns the result object.
        """

        _request_params = self._list_serialize(
            body=None,
            files=None,
            query=query,
            _headers=_headers,
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "waylay.services.registry.models.JobsResponse",
        }
        response_data = await self._api_client.call_api(
            **_request_params,
            _request_timeout=_request_timeout
        )
        result = self._api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )
        return result if with_http_info else result.data

    def _list_serialize(
        self,
        body,
        files,
        query,
        _headers,
    ) -> dict[str, Any]:

        _path_params: Dict[str, str] = {}
        _query_params: Dict[str, Any] = {}
        _header_params: Dict[str, Optional[str]] = {k.lower(): v for k, v in _headers.items()} if _headers else {}
        _form_params: Dict[str, str] = {}
        _files: Dict[str, str] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        if query is not None:
            query_param = query.get('limit', None)
            if query_param is not None:
                _query_params['limit'] = query_param

            query_param = query.get('type', None)
            if query_param is not None:

                _query_params['type'] = query_param

            query_param = query.get('state', None)
            if query_param is not None:

                _query_params['state'] = query_param

            query_param = query.get('function_type', None)
            if query_param is not None:

                _query_params['functionType'] = [v.value if isinstance(v, enum.Enum) else v for v in query_param]

            query_param = query.get('created_before', None)
            if query_param is not None:
                _query_params['createdBefore'] = query_param

            query_param = query.get('created_after', None)
            if query_param is not None:
                _query_params['createdAfter'] = query_param

        # process the form parameters
        # process the body parameter

        return self._api_client.param_serialize(
            method='GET',
            resource_path='/registry/v2/jobs/',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            files=_files,
        )
