# coding: utf-8
"""Waylay Function Registry api.

This code was generated from the OpenAPI documentation of 'Waylay Function Registry'

Generated by OpenAPI Generator (https://openapi-generator.tech)

Do not edit the class manually.
"""


from __future__ import annotations  # for Python 3.7â€“3.9

import enum
from pydantic import validate_call, Field, StrictStr, StrictBool
from typing import Dict, Literal, Optional, Union, Any, overload, TYPE_CHECKING

from waylay.sdk.api import ApiValueError

try:
    from typing import Annotated
except ImportError:
    from typing_extensions import Annotated  # type: ignore # noqa: F401

if TYPE_CHECKING:
    from waylay.services.registry.models import MultipartFileUpload
    from waylay.services.registry.models import FunctionMeta
    from waylay.services.registry.models import FileUpload
    from waylay.services.registry.models import MultipartFileUpload

    from waylay.services.registry.queries.model_functions_api import CreateQuery
    from waylay.services.registry.queries.model_functions_api import DeleteAssetQuery
    from waylay.services.registry.queries.model_functions_api import GetArchiveQuery
    from waylay.services.registry.queries.model_functions_api import GetAssetQuery
    from waylay.services.registry.queries.model_functions_api import (
        GetLatestVersionQuery,
    )
    from waylay.services.registry.queries.model_functions_api import GetVersionQuery
    from waylay.services.registry.queries.model_functions_api import JobsQuery
    from waylay.services.registry.queries.model_functions_api import ListAllQuery
    from waylay.services.registry.queries.model_functions_api import ListVersionsQuery
    from waylay.services.registry.queries.model_functions_api import PatchMetadataQuery
    from waylay.services.registry.queries.model_functions_api import PublishQuery
    from waylay.services.registry.queries.model_functions_api import RebuildQuery
    from waylay.services.registry.queries.model_functions_api import RemoveVersionQuery
    from waylay.services.registry.queries.model_functions_api import RemoveVersionsQuery
    from waylay.services.registry.queries.model_functions_api import UpdateAssetQuery
    from waylay.services.registry.queries.model_functions_api import UpdateAssetsQuery
    from waylay.services.registry.queries.model_functions_api import VerifyQuery

    from waylay.services.registry.models import PostModelJobSyncResponseV2

    from waylay.services.registry.models import PostModelJobSyncResponseV2

    from waylay.services.registry.models import GetModelResponseV2

    from waylay.services.registry.models import GetModelResponseV2

    from waylay.services.registry.models import JobsForModelResponseV2

    from waylay.services.registry.models import LatestModelsResponseV2

    from waylay.services.registry.models import ModelVersionsResponseV2

    from waylay.services.registry.models import GetModelResponseV2

    from waylay.services.registry.models import PostModelJobSyncResponseV2

    from waylay.services.registry.models import RebuildModelSyncResponseV2

    from waylay.services.registry.models import UndeployedResponseV2

    from waylay.services.registry.models import UndeployedResponseV2

    from waylay.services.registry.models import PostModelJobSyncResponseV2

    from waylay.services.registry.models import PostModelJobSyncResponseV2

    from waylay.services.registry.models import VerifyModelSyncResponseV2


try:
    from waylay.services.registry.models import MultipartFileUpload
    from waylay.services.registry.models import FunctionMeta
    from waylay.services.registry.models import FileUpload
    from waylay.services.registry.models import MultipartFileUpload

    from waylay.services.registry.queries.model_functions_api import CreateQuery
    from waylay.services.registry.queries.model_functions_api import DeleteAssetQuery
    from waylay.services.registry.queries.model_functions_api import GetArchiveQuery
    from waylay.services.registry.queries.model_functions_api import GetAssetQuery
    from waylay.services.registry.queries.model_functions_api import (
        GetLatestVersionQuery,
    )
    from waylay.services.registry.queries.model_functions_api import GetVersionQuery
    from waylay.services.registry.queries.model_functions_api import JobsQuery
    from waylay.services.registry.queries.model_functions_api import ListAllQuery
    from waylay.services.registry.queries.model_functions_api import ListVersionsQuery
    from waylay.services.registry.queries.model_functions_api import PatchMetadataQuery
    from waylay.services.registry.queries.model_functions_api import PublishQuery
    from waylay.services.registry.queries.model_functions_api import RebuildQuery
    from waylay.services.registry.queries.model_functions_api import RemoveVersionQuery
    from waylay.services.registry.queries.model_functions_api import RemoveVersionsQuery
    from waylay.services.registry.queries.model_functions_api import UpdateAssetQuery
    from waylay.services.registry.queries.model_functions_api import UpdateAssetsQuery
    from waylay.services.registry.queries.model_functions_api import VerifyQuery

    from waylay.services.registry.models import PostModelJobSyncResponseV2

    from waylay.services.registry.models import PostModelJobSyncResponseV2

    from waylay.services.registry.models import GetModelResponseV2

    from waylay.services.registry.models import GetModelResponseV2

    from waylay.services.registry.models import JobsForModelResponseV2

    from waylay.services.registry.models import LatestModelsResponseV2

    from waylay.services.registry.models import ModelVersionsResponseV2

    from waylay.services.registry.models import GetModelResponseV2

    from waylay.services.registry.models import PostModelJobSyncResponseV2

    from waylay.services.registry.models import RebuildModelSyncResponseV2

    from waylay.services.registry.models import UndeployedResponseV2

    from waylay.services.registry.models import UndeployedResponseV2

    from waylay.services.registry.models import PostModelJobSyncResponseV2

    from waylay.services.registry.models import PostModelJobSyncResponseV2

    from waylay.services.registry.models import VerifyModelSyncResponseV2

    types_available = True
except ImportError:
    types_available = False

    if not TYPE_CHECKING:
        MultipartFileUpload = Any
        FunctionMeta = Any
        FileUpload = Any
        MultipartFileUpload = Any

        CreateQuery = Dict
        DeleteAssetQuery = Dict
        GetArchiveQuery = Dict
        GetAssetQuery = Dict
        GetLatestVersionQuery = Dict
        GetVersionQuery = Dict
        JobsQuery = Dict
        ListAllQuery = Dict
        ListVersionsQuery = Dict
        PatchMetadataQuery = Dict
        PublishQuery = Dict
        RebuildQuery = Dict
        RemoveVersionQuery = Dict
        RemoveVersionsQuery = Dict
        UpdateAssetQuery = Dict
        UpdateAssetsQuery = Dict
        VerifyQuery = Dict

        PostModelJobSyncResponseV2 = Any

        PostModelJobSyncResponseV2 = Any

        GetModelResponseV2 = Any

        GetModelResponseV2 = Any

        JobsForModelResponseV2 = Any

        LatestModelsResponseV2 = Any

        ModelVersionsResponseV2 = Any

        GetModelResponseV2 = Any

        PostModelJobSyncResponseV2 = Any

        RebuildModelSyncResponseV2 = Any

        UndeployedResponseV2 = Any

        UndeployedResponseV2 = Any

        PostModelJobSyncResponseV2 = Any

        PostModelJobSyncResponseV2 = Any

        VerifyModelSyncResponseV2 = Any


from waylay.sdk.api import ApiClient, ApiResponse, RESTTimeout


class ModelFunctionsApi:
    """ModelFunctionsApi service methods.

    NOTE: This class is auto generated by OpenAPI Generator
    Ref: https://openapi-generator.tech

    Do not edit the class manually.
    """

    def __init__(self, api_client: ApiClient) -> None:
        """Create a ModelFunctionsApi instance."""
        self._api_client: ApiClient = api_client

    @overload
    async def create(
        self,
        *,
        body: Union[
            Annotated[
                Optional[MultipartFileUpload],
                Field(
                    description="The assets for a <em>model</em> function can be provided as either   <ul>     <li>a single <em>tar</em> archive (optionally compressed), with one of the content types      <code>application/octet-stream</code>, <code>application/tar+gzip</code>, <code>application/x-gzip</code>, <code>application/x-tar</code>, <code>application/gzip</code></li>     <li>separate files in a <code>multipart/form-data</code> request</li>   </ul>      The required <code>model.json</code> json file contains the function metadata,   and must have a <code>runtime</code> attribute that is one of the supported <em>runtime</em>s    (see <code>GET /registry/v2/runtimes?functionType=kfserving</code>).    For each <em>runtime</em> other files will be required or supported. "
                ),
            ],
            Annotated[
                Dict[StrictStr, Any], Field(description="Multipart file upload.")
            ],
        ] = None,
        files: Annotated[
            Optional[Dict[StrictStr, Any]], Field(description="Multipart file upload.")
        ] = None,
        query: Optional[CreateQuery] = None,
        _request_timeout: Optional[RESTTimeout] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        with_http_info: Literal[False] = False,
    ) -> PostModelJobSyncResponseV2:
        ...

    @overload
    async def create(
        self,
        *,
        body: Union[
            Annotated[
                Optional[MultipartFileUpload],
                Field(
                    description="The assets for a <em>model</em> function can be provided as either   <ul>     <li>a single <em>tar</em> archive (optionally compressed), with one of the content types      <code>application/octet-stream</code>, <code>application/tar+gzip</code>, <code>application/x-gzip</code>, <code>application/x-tar</code>, <code>application/gzip</code></li>     <li>separate files in a <code>multipart/form-data</code> request</li>   </ul>      The required <code>model.json</code> json file contains the function metadata,   and must have a <code>runtime</code> attribute that is one of the supported <em>runtime</em>s    (see <code>GET /registry/v2/runtimes?functionType=kfserving</code>).    For each <em>runtime</em> other files will be required or supported. "
                ),
            ],
            Annotated[
                Dict[StrictStr, Any], Field(description="Multipart file upload.")
            ],
        ] = None,
        files: Annotated[
            Optional[Dict[StrictStr, Any]], Field(description="Multipart file upload.")
        ] = None,
        query: Optional[CreateQuery] = None,
        _request_timeout: Optional[RESTTimeout] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        with_http_info: Literal[True],
    ) -> ApiResponse[PostModelJobSyncResponseV2]:
        ...

    @validate_call
    async def create(
        self,
        *,
        body: Union[
            Annotated[
                Optional[MultipartFileUpload],
                Field(
                    description="The assets for a <em>model</em> function can be provided as either   <ul>     <li>a single <em>tar</em> archive (optionally compressed), with one of the content types      <code>application/octet-stream</code>, <code>application/tar+gzip</code>, <code>application/x-gzip</code>, <code>application/x-tar</code>, <code>application/gzip</code></li>     <li>separate files in a <code>multipart/form-data</code> request</li>   </ul>      The required <code>model.json</code> json file contains the function metadata,   and must have a <code>runtime</code> attribute that is one of the supported <em>runtime</em>s    (see <code>GET /registry/v2/runtimes?functionType=kfserving</code>).    For each <em>runtime</em> other files will be required or supported. "
                ),
            ],
            Annotated[
                Dict[StrictStr, Any], Field(description="Multipart file upload.")
            ],
        ] = None,
        files: Annotated[
            Optional[Dict[StrictStr, Any]], Field(description="Multipart file upload.")
        ] = None,
        query: Optional[CreateQuery] = None,
        _request_timeout: Optional[RESTTimeout] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        with_http_info: StrictBool = False,
    ) -> Union[PostModelJobSyncResponseV2, ApiResponse[PostModelJobSyncResponseV2]]:
        """Create Model.

        Creates a new <em>model</em> function by uploading its assets.      The assets for a <em>model</em> function can be provided as either   <ul>     <li>a single <em>tar</em> archive (optionally compressed), with one of the content types      <code>application/octet-stream</code>, <code>application/tar+gzip</code>, <code>application/x-gzip</code>, <code>application/x-tar</code>, <code>application/gzip</code></li>     <li>separate files in a <code>multipart/form-data</code> request</li>   </ul>      The required <code>model.json</code> json file contains the function metadata,   and must have a <code>runtime</code> attribute that is one of the supported <em>runtime</em>s    (see <code>GET /registry/v2/runtimes?functionType=kfserving</code>).    For each <em>runtime</em> other files will be required or supported.

        :param body: The assets for a <em>model</em> function can be provided as either   <ul>     <li>a single <em>tar</em> archive (optionally compressed), with one of the content types      <code>application/octet-stream</code>, <code>application/tar+gzip</code>, <code>application/x-gzip</code>, <code>application/x-tar</code>, <code>application/gzip</code></li>     <li>separate files in a <code>multipart/form-data</code> request</li>   </ul>      The required <code>model.json</code> json file contains the function metadata,   and must have a <code>runtime</code> attribute that is one of the supported <em>runtime</em>s    (see <code>GET /registry/v2/runtimes?functionType=kfserving</code>).    For each <em>runtime</em> other files will be required or supported.
        :type body: MultipartFileUpload
        :param files: The multipart file upload. This equivalent to setting `body` along with the `content-type: multipart/form-data` header.
        :type files: Dict[str, bytearray], optional,
        :param query: Supported query params. (optional)
        :type query: TypedDict, optional:
            :param query.deprecate_previous: Set the cleanup policy used to automatically deprecate/delete previous versions.
            :type query.deprecate_previous: DeprecatePreviousPolicy
            :param query.dry_run: If set to <code>true</code>, validates the deployment conditions, but does not change anything.
            :type query.dry_run: bool
            :param query.var_async: Unless this is set to <code>false</code>, the server will start the required job actions asynchronously and return a <code>202</code> <em>Accepted</em> response. If <code>false</code> the request will block until the job actions are completed, or a timeout occurs.
            :type query.var_async: bool
            :param query.scale_to_zero: If set to <code>true</code>, after successful deployment, the deployed function will be scaled to zero. Saves computing resources when the function is not to be used immediately.
            :type query.scale_to_zero: bool
            :param query.version: If set, the function version will be an increment of the latest existing version that satisfies the `version` range. Note that this increment always takes precedence over an explicit `version` in the function manifest.
            :type query.version: SemanticVersionRange
            :param query.name: If set, the value will be used as the function name instead of the one specified in the manifest.
            :type query.name: str
            :param query.draft: If set, the created function will be a draft function and its assets are still mutable. A build and deploy is initiated only in the case when all necessary assets are present and valid.
            :type query.draft: bool
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :return: Returns the result object.
        """

        _request_params = self._create_serialize(
            body=body,
            files=files,
            query=query,
            _headers=_headers,
        )

        _response_types_map: Dict[str, Optional[str]] = {
            "201": "waylay.services.registry.models.PostModelJobSyncResponseV2",
            "202": "waylay.services.registry.models.PostModelJobAsyncResponseV2",
        }
        response_data = await self._api_client.call_api(
            **_request_params, _request_timeout=_request_timeout
        )
        result = self._api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )
        return result if with_http_info else result.data

    def _create_serialize(
        self,
        body,
        files,
        query,
        _headers,
    ) -> dict[str, Any]:
        _path_params: Dict[str, str] = {}
        _query_params: Dict[str, Any] = {}
        _header_params: Dict[str, Optional[str]] = (
            {k.lower(): v for k, v in _headers.items()} if _headers else {}
        )
        _form_params: Dict[str, str] = {}
        _files: Dict[str, str] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        if query is not None:
            query_param = query.get("deprecate_previous", None)
            if query_param is not None:
                _query_params["deprecatePrevious"] = query_param.value

            query_param = query.get("dry_run", None)
            if query_param is not None:
                _query_params["dryRun"] = query_param

            query_param = query.get("var_async", None)
            if query_param is not None:
                _query_params["async"] = query_param

            query_param = query.get("scale_to_zero", None)
            if query_param is not None:
                _query_params["scaleToZero"] = query_param

            query_param = query.get("version", None)
            if query_param is not None:
                _query_params["version"] = query_param

            query_param = query.get("name", None)
            if query_param is not None:
                _query_params["name"] = query_param

            query_param = query.get("draft", None)
            if query_param is not None:
                _query_params["draft"] = query_param

        # process the form parameters
        if files:
            _files.update(files)
        # if `body` and `content-type` multipart/form-data, wrap it in `files` instead of `body`
        content_type = _header_params.get("content-type")
        if (
            not files
            and body
            and content_type
            and content_type.startswith("multipart/form-data")
        ):
            try:
                _files.update(body)
                body = None
                if "boundary" not in content_type:
                    # Content-Type header does not cotain a boundary, and hence, is not valid.
                    # Remove it to force the http framework to set it instead.
                    del _header_params["content-type"]
            except ValueError as err:
                raise ApiValueError("Body is not a valid dictionary", "body") from err
        # process the body parameter
        if body is not None:
            _body_params = body

        return self._api_client.param_serialize(
            method="POST",
            resource_path="/registry/v2/models/",
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            files=_files,
        )

    @overload
    async def delete_asset(
        self,
        name: Annotated[StrictStr, Field(description="The name of the function.")],
        version: Annotated[
            str, Field(strict=True, description="The version of the function.")
        ],
        wildcard: Annotated[
            StrictStr,
            Field(
                description="Full path or path prefix of the asset within the archive"
            ),
        ],
        *,
        query: Optional[DeleteAssetQuery] = None,
        _request_timeout: Optional[RESTTimeout] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        with_http_info: Literal[False] = False,
    ) -> PostModelJobSyncResponseV2:
        ...

    @overload
    async def delete_asset(
        self,
        name: Annotated[StrictStr, Field(description="The name of the function.")],
        version: Annotated[
            str, Field(strict=True, description="The version of the function.")
        ],
        wildcard: Annotated[
            StrictStr,
            Field(
                description="Full path or path prefix of the asset within the archive"
            ),
        ],
        *,
        query: Optional[DeleteAssetQuery] = None,
        _request_timeout: Optional[RESTTimeout] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        with_http_info: Literal[True],
    ) -> ApiResponse[PostModelJobSyncResponseV2]:
        ...

    @validate_call
    async def delete_asset(
        self,
        name: Annotated[StrictStr, Field(description="The name of the function.")],
        version: Annotated[
            str, Field(strict=True, description="The version of the function.")
        ],
        wildcard: Annotated[
            StrictStr,
            Field(
                description="Full path or path prefix of the asset within the archive"
            ),
        ],
        *,
        query: Optional[DeleteAssetQuery] = None,
        _request_timeout: Optional[RESTTimeout] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        with_http_info: StrictBool = False,
    ) -> Union[PostModelJobSyncResponseV2, ApiResponse[PostModelJobSyncResponseV2]]:
        """Delete Model Asset.

        Delete an asset from the model's collection of existing assets.

        :param name: The name of the function. (required)
        :type name: str
        :param version: The version of the function. (required)
        :type version: str
        :param wildcard: Full path or path prefix of the asset within the archive (required)
        :type wildcard: str
        :param query: Supported query params. (optional)
        :type query: TypedDict, optional:
            :param query.comment: An optional user-specified comment corresponding to the operation.
            :type query.comment: str
            :param query.var_async: Unless this is set to <code>false</code>, the server will start the required job actions asynchronously and return a <code>202</code> <em>Accepted</em> response. If <code>false</code> the request will block until the job actions are completed, or a timeout occurs.
            :type query.var_async: bool
            :param query.chown: If set, ownership of the draft function is transferred to the current user. (required)
            :type query.chown: bool
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :return: Returns the result object.
        """

        _request_params = self._delete_asset_serialize(
            name=name,
            version=version,
            wildcard=wildcard,
            body=None,
            files=None,
            query=query,
            _headers=_headers,
        )

        _response_types_map: Dict[str, Optional[str]] = {
            "201": "waylay.services.registry.models.PostModelJobSyncResponseV2",
            "202": "waylay.services.registry.models.PostModelJobAsyncResponseV2",
        }
        response_data = await self._api_client.call_api(
            **_request_params, _request_timeout=_request_timeout
        )
        result = self._api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )
        return result if with_http_info else result.data

    def _delete_asset_serialize(
        self,
        name,
        version,
        wildcard,
        body,
        files,
        query,
        _headers,
    ) -> dict[str, Any]:
        _path_params: Dict[str, str] = {}
        _query_params: Dict[str, Any] = {}
        _header_params: Dict[str, Optional[str]] = (
            {k.lower(): v for k, v in _headers.items()} if _headers else {}
        )
        _form_params: Dict[str, str] = {}
        _files: Dict[str, str] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if name is not None:
            _path_params["name"] = name
        if version is not None:
            _path_params["version"] = version
        if wildcard is not None:
            _path_params["wildcard"] = wildcard
        # process the query parameters
        if query is not None:
            query_param = query.get("comment", None)
            if query_param is not None:
                _query_params["comment"] = query_param

            query_param = query.get("var_async", None)
            if query_param is not None:
                _query_params["async"] = query_param

            query_param = query.get("chown", None)
            if query_param is not None:
                _query_params["chown"] = query_param

        # process the form parameters
        # process the body parameter

        return self._api_client.param_serialize(
            method="DELETE",
            resource_path="/registry/v2/models/{name}/versions/{version}/content/{wildcard}",
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            files=_files,
        )

    @overload
    async def get_archive(
        self,
        name: Annotated[StrictStr, Field(description="The name of the function.")],
        version: Annotated[
            str, Field(strict=True, description="The version of the function.")
        ],
        *,
        query: Optional[GetArchiveQuery] = None,
        _request_timeout: Optional[RESTTimeout] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        with_http_info: Literal[False] = False,
    ) -> bytearray:
        ...

    @overload
    async def get_archive(
        self,
        name: Annotated[StrictStr, Field(description="The name of the function.")],
        version: Annotated[
            str, Field(strict=True, description="The version of the function.")
        ],
        *,
        query: Optional[GetArchiveQuery] = None,
        _request_timeout: Optional[RESTTimeout] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        with_http_info: Literal[True],
    ) -> ApiResponse[bytearray]:
        ...

    @validate_call
    async def get_archive(
        self,
        name: Annotated[StrictStr, Field(description="The name of the function.")],
        version: Annotated[
            str, Field(strict=True, description="The version of the function.")
        ],
        *,
        query: Optional[GetArchiveQuery] = None,
        _request_timeout: Optional[RESTTimeout] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        with_http_info: StrictBool = False,
    ) -> Union[bytearray, ApiResponse[bytearray]]:
        """Get Model Archive.

        Get the specification archive of a model.

        :param name: The name of the function. (required)
        :type name: str
        :param version: The version of the function. (required)
        :type version: str
        :param query: Supported query params. (optional)
        :type query: TypedDict, optional:
            :param query.ls: If set to `true`, the result will be a listing of the files in the asset, annotated with metadata and validation report from the asset conditions of the functions runtime.
            :type query.ls: bool
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :return: Returns the result object.
        """

        _request_params = self._get_archive_serialize(
            name=name,
            version=version,
            body=None,
            files=None,
            query=query,
            _headers=_headers,
        )

        _response_types_map: Dict[str, Optional[str]] = {
            "200": "bytearray",
        }
        response_data = await self._api_client.call_api(
            **_request_params, _request_timeout=_request_timeout
        )
        result = self._api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )
        return result if with_http_info else result.data

    def _get_archive_serialize(
        self,
        name,
        version,
        body,
        files,
        query,
        _headers,
    ) -> dict[str, Any]:
        _path_params: Dict[str, str] = {}
        _query_params: Dict[str, Any] = {}
        _header_params: Dict[str, Optional[str]] = (
            {k.lower(): v for k, v in _headers.items()} if _headers else {}
        )
        _form_params: Dict[str, str] = {}
        _files: Dict[str, str] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if name is not None:
            _path_params["name"] = name
        if version is not None:
            _path_params["version"] = version
        # process the query parameters
        if query is not None:
            query_param = query.get("ls", None)
            if query_param is not None:
                _query_params["ls"] = query_param

        # process the form parameters
        # process the body parameter

        return self._api_client.param_serialize(
            method="GET",
            resource_path="/registry/v2/models/{name}/versions/{version}/content",
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            files=_files,
        )

    @overload
    async def get_asset(
        self,
        name: Annotated[StrictStr, Field(description="The name of the function.")],
        version: Annotated[
            str, Field(strict=True, description="The version of the function.")
        ],
        wildcard: Annotated[
            StrictStr,
            Field(
                description="Full path or path prefix of the asset within the archive"
            ),
        ],
        *,
        query: Optional[GetAssetQuery] = None,
        _request_timeout: Optional[RESTTimeout] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        with_http_info: Literal[False] = False,
    ) -> bytearray:
        ...

    @overload
    async def get_asset(
        self,
        name: Annotated[StrictStr, Field(description="The name of the function.")],
        version: Annotated[
            str, Field(strict=True, description="The version of the function.")
        ],
        wildcard: Annotated[
            StrictStr,
            Field(
                description="Full path or path prefix of the asset within the archive"
            ),
        ],
        *,
        query: Optional[GetAssetQuery] = None,
        _request_timeout: Optional[RESTTimeout] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        with_http_info: Literal[True],
    ) -> ApiResponse[bytearray]:
        ...

    @validate_call
    async def get_asset(
        self,
        name: Annotated[StrictStr, Field(description="The name of the function.")],
        version: Annotated[
            str, Field(strict=True, description="The version of the function.")
        ],
        wildcard: Annotated[
            StrictStr,
            Field(
                description="Full path or path prefix of the asset within the archive"
            ),
        ],
        *,
        query: Optional[GetAssetQuery] = None,
        _request_timeout: Optional[RESTTimeout] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        with_http_info: StrictBool = False,
    ) -> Union[bytearray, ApiResponse[bytearray]]:
        """Get File From Model Archive.

        Get a file from the specification archive of a model.

        :param name: The name of the function. (required)
        :type name: str
        :param version: The version of the function. (required)
        :type version: str
        :param wildcard: Full path or path prefix of the asset within the archive (required)
        :type wildcard: str
        :param query: Supported query params. (optional)
        :type query: TypedDict, optional:
            :param query.ls: If set to `true`, the result will be a listing of the files in the asset, annotated with metadata and validation report from the asset conditions of the functions runtime.
            :type query.ls: bool
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :return: Returns the result object.
        """

        _request_params = self._get_asset_serialize(
            name=name,
            version=version,
            wildcard=wildcard,
            body=None,
            files=None,
            query=query,
            _headers=_headers,
        )

        _response_types_map: Dict[str, Optional[str]] = {
            "200": "bytearray",
        }
        response_data = await self._api_client.call_api(
            **_request_params, _request_timeout=_request_timeout
        )
        result = self._api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )
        return result if with_http_info else result.data

    def _get_asset_serialize(
        self,
        name,
        version,
        wildcard,
        body,
        files,
        query,
        _headers,
    ) -> dict[str, Any]:
        _path_params: Dict[str, str] = {}
        _query_params: Dict[str, Any] = {}
        _header_params: Dict[str, Optional[str]] = (
            {k.lower(): v for k, v in _headers.items()} if _headers else {}
        )
        _form_params: Dict[str, str] = {}
        _files: Dict[str, str] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if name is not None:
            _path_params["name"] = name
        if version is not None:
            _path_params["version"] = version
        if wildcard is not None:
            _path_params["wildcard"] = wildcard
        # process the query parameters
        if query is not None:
            query_param = query.get("ls", None)
            if query_param is not None:
                _query_params["ls"] = query_param

        # process the form parameters
        # process the body parameter

        return self._api_client.param_serialize(
            method="GET",
            resource_path="/registry/v2/models/{name}/versions/{version}/content/{wildcard}",
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            files=_files,
        )

    @overload
    async def get_latest_version(
        self,
        name: Annotated[StrictStr, Field(description="The name of the function.")],
        *,
        query: Optional[GetLatestVersionQuery] = None,
        _request_timeout: Optional[RESTTimeout] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        with_http_info: Literal[False] = False,
    ) -> GetModelResponseV2:
        ...

    @overload
    async def get_latest_version(
        self,
        name: Annotated[StrictStr, Field(description="The name of the function.")],
        *,
        query: Optional[GetLatestVersionQuery] = None,
        _request_timeout: Optional[RESTTimeout] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        with_http_info: Literal[True],
    ) -> ApiResponse[GetModelResponseV2]:
        ...

    @validate_call
    async def get_latest_version(
        self,
        name: Annotated[StrictStr, Field(description="The name of the function.")],
        *,
        query: Optional[GetLatestVersionQuery] = None,
        _request_timeout: Optional[RESTTimeout] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        with_http_info: StrictBool = False,
    ) -> Union[GetModelResponseV2, ApiResponse[GetModelResponseV2]]:
        """Get Latest Model Version.

        Fetch the latest version of a <em>model</em>.    By default, the result shows the latest non-deprecated, non-draft version.   If there is no such version, the latest deprecated or the latest draft version is returned, with the former taking precedence.       Use the boolean query parameters <code>includeDeprecated</code> or <code>includeDraft</code> to change this behaviour:   <ul>   <li><code>includeDeprecated=true</code>: do not prefer non-deprecated versions as a latest version: if the latest version is a deprecated one, it will be shown, even if there are older non-deprecated versions.</li>   <li><code>includeDraft=true</code>: do not prefer non-draft versions as a latest version: if the latest version is a draft, it will be shown, even if there are older non-draft versions.</li>   </ul>     The returned <em>model version</em> will contain a link to its   latest _draft_ or latest _published_ version (if existing and different).

        :param name: The name of the function. (required)
        :type name: str
        :param query: Supported query params. (optional)
        :type query: TypedDict, optional:
            :param query.include_draft: Configures the inclusion of _draft_ versions when selecting latest versions per name. By default, draft versions are only considered when no other versions are available. If set to `true`, draft versions are **included**. If set to `false`, draft versions are **excluded**.
            :type query.include_draft: bool
            :param query.include_deprecated: Configures the inclusion of _deprecated_ versions when selecting latest versions per name. By default, deprecated versions are only considered when no other versions are available. If set to `true`, deprecated versions are **included**. If set to `false`, deprecated versions are **excluded**.
            :type query.include_deprecated: bool
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :return: Returns the result object.
        """

        _request_params = self._get_latest_version_serialize(
            name=name,
            body=None,
            files=None,
            query=query,
            _headers=_headers,
        )

        _response_types_map: Dict[str, Optional[str]] = {
            "200": "waylay.services.registry.models.GetModelResponseV2",
        }
        response_data = await self._api_client.call_api(
            **_request_params, _request_timeout=_request_timeout
        )
        result = self._api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )
        return result if with_http_info else result.data

    def _get_latest_version_serialize(
        self,
        name,
        body,
        files,
        query,
        _headers,
    ) -> dict[str, Any]:
        _path_params: Dict[str, str] = {}
        _query_params: Dict[str, Any] = {}
        _header_params: Dict[str, Optional[str]] = (
            {k.lower(): v for k, v in _headers.items()} if _headers else {}
        )
        _form_params: Dict[str, str] = {}
        _files: Dict[str, str] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if name is not None:
            _path_params["name"] = name
        # process the query parameters
        if query is not None:
            query_param = query.get("include_draft", None)
            if query_param is not None:
                _query_params["includeDraft"] = query_param

            query_param = query.get("include_deprecated", None)
            if query_param is not None:
                _query_params["includeDeprecated"] = query_param

        # process the form parameters
        # process the body parameter

        return self._api_client.param_serialize(
            method="GET",
            resource_path="/registry/v2/models/{name}",
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            files=_files,
        )

    @overload
    async def get_version(
        self,
        name: Annotated[StrictStr, Field(description="The name of the function.")],
        version: Annotated[
            str, Field(strict=True, description="The version of the function.")
        ],
        *,
        query: Optional[GetVersionQuery] = None,
        _request_timeout: Optional[RESTTimeout] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        with_http_info: Literal[False] = False,
    ) -> GetModelResponseV2:
        ...

    @overload
    async def get_version(
        self,
        name: Annotated[StrictStr, Field(description="The name of the function.")],
        version: Annotated[
            str, Field(strict=True, description="The version of the function.")
        ],
        *,
        query: Optional[GetVersionQuery] = None,
        _request_timeout: Optional[RESTTimeout] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        with_http_info: Literal[True],
    ) -> ApiResponse[GetModelResponseV2]:
        ...

    @validate_call
    async def get_version(
        self,
        name: Annotated[StrictStr, Field(description="The name of the function.")],
        version: Annotated[
            str, Field(strict=True, description="The version of the function.")
        ],
        *,
        query: Optional[GetVersionQuery] = None,
        _request_timeout: Optional[RESTTimeout] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        with_http_info: StrictBool = False,
    ) -> Union[GetModelResponseV2, ApiResponse[GetModelResponseV2]]:
        """Get Model Version.

        Get a model by name and version.

        :param name: The name of the function. (required)
        :type name: str
        :param version: The version of the function. (required)
        :type version: str
        :param query: Supported query params. (optional)
        :type query: TypedDict, optional:
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :return: Returns the result object.
        """

        _request_params = self._get_version_serialize(
            name=name,
            version=version,
            body=None,
            files=None,
            query=query,
            _headers=_headers,
        )

        _response_types_map: Dict[str, Optional[str]] = {
            "200": "waylay.services.registry.models.GetModelResponseV2",
        }
        response_data = await self._api_client.call_api(
            **_request_params, _request_timeout=_request_timeout
        )
        result = self._api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )
        return result if with_http_info else result.data

    def _get_version_serialize(
        self,
        name,
        version,
        body,
        files,
        query,
        _headers,
    ) -> dict[str, Any]:
        _path_params: Dict[str, str] = {}
        _query_params: Dict[str, Any] = {}
        _header_params: Dict[str, Optional[str]] = (
            {k.lower(): v for k, v in _headers.items()} if _headers else {}
        )
        _form_params: Dict[str, str] = {}
        _files: Dict[str, str] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if name is not None:
            _path_params["name"] = name
        if version is not None:
            _path_params["version"] = version
        # process the query parameters
        if query is not None:
            pass
        # process the form parameters
        # process the body parameter

        return self._api_client.param_serialize(
            method="GET",
            resource_path="/registry/v2/models/{name}/versions/{version}",
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            files=_files,
        )

    @overload
    async def jobs(
        self,
        name: Annotated[StrictStr, Field(description="The name of the function.")],
        version: Annotated[
            str, Field(strict=True, description="The version of the function.")
        ],
        *,
        query: Optional[JobsQuery] = None,
        _request_timeout: Optional[RESTTimeout] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        with_http_info: Literal[False] = False,
    ) -> JobsForModelResponseV2:
        ...

    @overload
    async def jobs(
        self,
        name: Annotated[StrictStr, Field(description="The name of the function.")],
        version: Annotated[
            str, Field(strict=True, description="The version of the function.")
        ],
        *,
        query: Optional[JobsQuery] = None,
        _request_timeout: Optional[RESTTimeout] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        with_http_info: Literal[True],
    ) -> ApiResponse[JobsForModelResponseV2]:
        ...

    @validate_call
    async def jobs(
        self,
        name: Annotated[StrictStr, Field(description="The name of the function.")],
        version: Annotated[
            str, Field(strict=True, description="The version of the function.")
        ],
        *,
        query: Optional[JobsQuery] = None,
        _request_timeout: Optional[RESTTimeout] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        with_http_info: StrictBool = False,
    ) -> Union[JobsForModelResponseV2, ApiResponse[JobsForModelResponseV2]]:
        """List Model Jobs.

        List the ongoing and completed operations on a model.

        :param name: The name of the function. (required)
        :type name: str
        :param version: The version of the function. (required)
        :type version: str
        :param query: Supported query params. (optional)
        :type query: TypedDict, optional:
            :param query.limit: The maximum number of items to be return from this query. Has a deployment-defined default and maximum value.
            :type query.limit: float
            :param query.type: Filter on job type
            :type query.type: List[JobTypeSchema]
            :param query.state: Filter on job state
            :type query.state: List[JobStateResult]
            :param query.function_type: Filter on function type
            :type query.function_type: List[FunctionType]
            :param query.created_before: Filter on jobs that created before the given timestamp or age
            :type query.created_before: TimestampSpec
            :param query.created_after: Filter on jobs that created after the given timestamp or age
            :type query.created_after: TimestampSpec
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :return: Returns the result object.
        """

        _request_params = self._jobs_serialize(
            name=name,
            version=version,
            body=None,
            files=None,
            query=query,
            _headers=_headers,
        )

        _response_types_map: Dict[str, Optional[str]] = {
            "200": "waylay.services.registry.models.JobsForModelResponseV2",
        }
        response_data = await self._api_client.call_api(
            **_request_params, _request_timeout=_request_timeout
        )
        result = self._api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )
        return result if with_http_info else result.data

    def _jobs_serialize(
        self,
        name,
        version,
        body,
        files,
        query,
        _headers,
    ) -> dict[str, Any]:
        _path_params: Dict[str, str] = {}
        _query_params: Dict[str, Any] = {}
        _header_params: Dict[str, Optional[str]] = (
            {k.lower(): v for k, v in _headers.items()} if _headers else {}
        )
        _form_params: Dict[str, str] = {}
        _files: Dict[str, str] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if name is not None:
            _path_params["name"] = name
        if version is not None:
            _path_params["version"] = version
        # process the query parameters
        if query is not None:
            query_param = query.get("limit", None)
            if query_param is not None:
                _query_params["limit"] = query_param

            query_param = query.get("type", None)
            if query_param is not None:
                _query_params["type"] = query_param

            query_param = query.get("state", None)
            if query_param is not None:
                _query_params["state"] = query_param

            query_param = query.get("function_type", None)
            if query_param is not None:
                _query_params["functionType"] = [
                    v.value if isinstance(v, enum.Enum) else v for v in query_param
                ]

            query_param = query.get("created_before", None)
            if query_param is not None:
                _query_params["createdBefore"] = query_param

            query_param = query.get("created_after", None)
            if query_param is not None:
                _query_params["createdAfter"] = query_param

        # process the form parameters
        # process the body parameter

        return self._api_client.param_serialize(
            method="GET",
            resource_path="/registry/v2/models/{name}/versions/{version}/jobs",
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            files=_files,
        )

    @overload
    async def list_all(
        self,
        *,
        query: Optional[ListAllQuery] = None,
        _request_timeout: Optional[RESTTimeout] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        with_http_info: Literal[False] = False,
    ) -> LatestModelsResponseV2:
        ...

    @overload
    async def list_all(
        self,
        *,
        query: Optional[ListAllQuery] = None,
        _request_timeout: Optional[RESTTimeout] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        with_http_info: Literal[True],
    ) -> ApiResponse[LatestModelsResponseV2]:
        ...

    @validate_call
    async def list_all(
        self,
        *,
        query: Optional[ListAllQuery] = None,
        _request_timeout: Optional[RESTTimeout] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        with_http_info: StrictBool = False,
    ) -> Union[LatestModelsResponseV2, ApiResponse[LatestModelsResponseV2]]:
        """List Models.

        List the (latest) versions of available <em>models</em>.  ### List Latest Model Versions By default, the result includes the latest non-deprecated, non-draft version for each <em>model</em> name. If there is no such version, the latest _deprecated_ or the latest _draft_ version is included, with the former taking precedence.     Use the boolean query parameters <code>includeDeprecated</code> or <code>includeDraft</code> to change this behaviour:   <ul>   <li><code>includeDeprecated=true</code>: do not prefer non-deprecated versions as a latest version: if the latest version is a deprecated one, it will be shown, even if there are older non-deprecated versions.</li>   <li><code>includeDraft=true</code>: do not prefer non-draft versions as a latest version: if the latest version is a draft, it will be shown, even if there are older non-draft versions.</li>   </ul>   As long as no _version filters_ are used, each listed <em>model version</em> item will contain a HAL **link to the  latest** _draft_ (`entities[]._links.draft`) or latest _published_ (`entities[]._links.publisned`) version (if existing and different).  ### List Latest Model Versions (with filter) When any of the _version filter_ query parameters are used, the response contains the _latest_ version per named <em>model</em> that satisfy the filters, but **without links**.  ### List All Model Versions When using `latest=false` (default when using the `namedVersion` filter), the listing contains _all_  <em>models</em> versions that satisfy the query, possibly multiple versions per named <em>models</em>. No HAL links are provided.  #### Filter on _status_ By default <em>model versions</em> with status  `undeployed` are **excluded** in all cases. Use the _version filter_ `status` to include/exclude a status from the results. By example,  > `?status=any&includeDeprecated=true&includeDraft=true&latest=false`  will list _ALL_ versions known to the function registry.  #### Version filter parameters The following query parameters are _version filters_ for the <em>model</em> listing: > `version`, `status`, `runtimeVersion`, `createdBy`, `createdBefore`, `createdAfter`, `updatedBy`, `updatedBefore`, `updatedAfter`, `nameVersion`, `deprecated`, `draft`

        :param query: Supported query params. (optional)
        :type query: TypedDict, optional:
            :param query.limit: The maximum number of items to be return from this query. Has a deployment-defined default and maximum value.
            :type query.limit: float
            :param query.page: The number of pages to skip when returning result to this query.
            :type query.page: float
            :param query.include_draft: Configures the inclusion of _draft_ versions when selecting latest versions per name. By default, draft versions are only considered when no other versions are available. If set to `true`, draft versions are **included**. If set to `false`, draft versions are **excluded**.
            :type query.include_draft: bool
            :param query.include_deprecated: Configures the inclusion of _deprecated_ versions when selecting latest versions per name. By default, deprecated versions are only considered when no other versions are available. If set to `true`, deprecated versions are **included**. If set to `false`, deprecated versions are **excluded**.
            :type query.include_deprecated: bool
            :param query.deprecated: Filter on the deprecation status of the function.
            :type query.deprecated: bool
            :param query.draft: Filter on the draft status of the function.
            :type query.draft: bool
            :param query.name_version: Filter on exact `{name}@{version}` functions. Using this filter implies a `latest=false` default, returning multiple versions of the same named versions if they are filtered.
            :type query.name_version: List[str]
            :param query.version: Filter on the version of the function (case-sensitive, supports wildcards).
            :type query.version: str
            :param query.status: Filter on the status of the plug. Filter values with a `-` postfix exclude the status. Use the `any` filter value to include all states. When not specified, a default `undeployed-` filter excludes _undeployed_ functions.
            :type query.status: List[StatusFilter]
            :param query.runtime_version: Filter on the runtime version.
            :type query.runtime_version: SemanticVersionRange
            :param query.created_by: Filter on the user that create the plug. You can use the `@me` token to indicate your own plugs.
            :type query.created_by: str
            :param query.updated_by: Filter on the user that last updated the plug. You can use the `@me` token to indicate your own plugs.
            :type query.updated_by: str
            :param query.created_before: Filter on funtions that were created before the given timestamp or age.
            :type query.created_before: TimestampSpec
            :param query.created_after: Filter on funtions that were created after the given timestamp or age.
            :type query.created_after: TimestampSpec
            :param query.updated_before: Filter on funtions that were updated before the given timestamp or age.
            :type query.updated_before: TimestampSpec
            :param query.updated_after: Filter on funtions that were updated after the given timestamp or age.
            :type query.updated_after: TimestampSpec
            :param query.name: Filter on the name of the function. This is case-insensitive and supports wild-cards `?` (any one character) and `*` (any sequence of characters).
            :type query.name: str
            :param query.archive_format: Filter on the archive format of the function.
            :type query.archive_format: List[ArchiveFormat]
            :param query.runtime: Filter on the runtime of the function.
            :type query.runtime: List[str]
            :param query.latest: When `true`, only the latest version per function name is returned. If set to `false`, multiple versions per named function can be returned. Defaults to `true`, except when specific versions are selected with the `nameVersion` filter.
            :type query.latest: bool
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :return: Returns the result object.
        """

        _request_params = self._list_all_serialize(
            body=None,
            files=None,
            query=query,
            _headers=_headers,
        )

        _response_types_map: Dict[str, Optional[str]] = {
            "200": "waylay.services.registry.models.LatestModelsResponseV2",
        }
        response_data = await self._api_client.call_api(
            **_request_params, _request_timeout=_request_timeout
        )
        result = self._api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )
        return result if with_http_info else result.data

    def _list_all_serialize(
        self,
        body,
        files,
        query,
        _headers,
    ) -> dict[str, Any]:
        _path_params: Dict[str, str] = {}
        _query_params: Dict[str, Any] = {}
        _header_params: Dict[str, Optional[str]] = (
            {k.lower(): v for k, v in _headers.items()} if _headers else {}
        )
        _form_params: Dict[str, str] = {}
        _files: Dict[str, str] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        if query is not None:
            query_param = query.get("limit", None)
            if query_param is not None:
                _query_params["limit"] = query_param

            query_param = query.get("page", None)
            if query_param is not None:
                _query_params["page"] = query_param

            query_param = query.get("include_draft", None)
            if query_param is not None:
                _query_params["includeDraft"] = query_param

            query_param = query.get("include_deprecated", None)
            if query_param is not None:
                _query_params["includeDeprecated"] = query_param

            query_param = query.get("deprecated", None)
            if query_param is not None:
                _query_params["deprecated"] = query_param

            query_param = query.get("draft", None)
            if query_param is not None:
                _query_params["draft"] = query_param

            query_param = query.get("name_version", None)
            if query_param is not None:
                _query_params["nameVersion"] = query_param

            query_param = query.get("version", None)
            if query_param is not None:
                _query_params["version"] = query_param

            query_param = query.get("status", None)
            if query_param is not None:
                _query_params["status"] = query_param

            query_param = query.get("runtime_version", None)
            if query_param is not None:
                _query_params["runtimeVersion"] = query_param

            query_param = query.get("created_by", None)
            if query_param is not None:
                _query_params["createdBy"] = query_param

            query_param = query.get("updated_by", None)
            if query_param is not None:
                _query_params["updatedBy"] = query_param

            query_param = query.get("created_before", None)
            if query_param is not None:
                _query_params["createdBefore"] = query_param

            query_param = query.get("created_after", None)
            if query_param is not None:
                _query_params["createdAfter"] = query_param

            query_param = query.get("updated_before", None)
            if query_param is not None:
                _query_params["updatedBefore"] = query_param

            query_param = query.get("updated_after", None)
            if query_param is not None:
                _query_params["updatedAfter"] = query_param

            query_param = query.get("name", None)
            if query_param is not None:
                _query_params["name"] = query_param

            query_param = query.get("archive_format", None)
            if query_param is not None:
                _query_params["archiveFormat"] = [
                    v.value if isinstance(v, enum.Enum) else v for v in query_param
                ]

            query_param = query.get("runtime", None)
            if query_param is not None:
                _query_params["runtime"] = query_param

            query_param = query.get("latest", None)
            if query_param is not None:
                _query_params["latest"] = query_param

        # process the form parameters
        # process the body parameter

        return self._api_client.param_serialize(
            method="GET",
            resource_path="/registry/v2/models/",
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            files=_files,
        )

    @overload
    async def list_versions(
        self,
        name: Annotated[StrictStr, Field(description="The name of the function.")],
        *,
        query: Optional[ListVersionsQuery] = None,
        _request_timeout: Optional[RESTTimeout] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        with_http_info: Literal[False] = False,
    ) -> ModelVersionsResponseV2:
        ...

    @overload
    async def list_versions(
        self,
        name: Annotated[StrictStr, Field(description="The name of the function.")],
        *,
        query: Optional[ListVersionsQuery] = None,
        _request_timeout: Optional[RESTTimeout] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        with_http_info: Literal[True],
    ) -> ApiResponse[ModelVersionsResponseV2]:
        ...

    @validate_call
    async def list_versions(
        self,
        name: Annotated[StrictStr, Field(description="The name of the function.")],
        *,
        query: Optional[ListVersionsQuery] = None,
        _request_timeout: Optional[RESTTimeout] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        with_http_info: StrictBool = False,
    ) -> Union[ModelVersionsResponseV2, ApiResponse[ModelVersionsResponseV2]]:
        """List Model Versions.

        List all deployed versions of a model.

        :param name: The name of the function. (required)
        :type name: str
        :param query: Supported query params. (optional)
        :type query: TypedDict, optional:
            :param query.limit: The maximum number of items to be return from this query. Has a deployment-defined default and maximum value.
            :type query.limit: float
            :param query.page: The number of pages to skip when returning result to this query.
            :type query.page: float
            :param query.deprecated: Filter on the deprecation status of the function.
            :type query.deprecated: bool
            :param query.draft: Filter on the draft status of the function.
            :type query.draft: bool
            :param query.version: Filter on the version of the function (case-sensitive, supports wildcards).
            :type query.version: str
            :param query.status: Filter on the status of the plug. Filter values with a `-` postfix exclude the status. Use the `any` filter value to include all states. When not specified, a default `undeployed-` filter excludes _undeployed_ functions.
            :type query.status: List[StatusFilter]
            :param query.runtime_version: Filter on the runtime version.
            :type query.runtime_version: SemanticVersionRange
            :param query.created_by: Filter on the user that create the plug. You can use the `@me` token to indicate your own plugs.
            :type query.created_by: str
            :param query.updated_by: Filter on the user that last updated the plug. You can use the `@me` token to indicate your own plugs.
            :type query.updated_by: str
            :param query.created_before: Filter on funtions that were created before the given timestamp or age.
            :type query.created_before: TimestampSpec
            :param query.created_after: Filter on funtions that were created after the given timestamp or age.
            :type query.created_after: TimestampSpec
            :param query.updated_before: Filter on funtions that were updated before the given timestamp or age.
            :type query.updated_before: TimestampSpec
            :param query.updated_after: Filter on funtions that were updated after the given timestamp or age.
            :type query.updated_after: TimestampSpec
            :param query.archive_format: Filter on the archive format of the function.
            :type query.archive_format: List[ArchiveFormat]
            :param query.runtime: Filter on the runtime of the function.
            :type query.runtime: List[str]
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :return: Returns the result object.
        """

        _request_params = self._list_versions_serialize(
            name=name,
            body=None,
            files=None,
            query=query,
            _headers=_headers,
        )

        _response_types_map: Dict[str, Optional[str]] = {
            "200": "waylay.services.registry.models.ModelVersionsResponseV2",
        }
        response_data = await self._api_client.call_api(
            **_request_params, _request_timeout=_request_timeout
        )
        result = self._api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )
        return result if with_http_info else result.data

    def _list_versions_serialize(
        self,
        name,
        body,
        files,
        query,
        _headers,
    ) -> dict[str, Any]:
        _path_params: Dict[str, str] = {}
        _query_params: Dict[str, Any] = {}
        _header_params: Dict[str, Optional[str]] = (
            {k.lower(): v for k, v in _headers.items()} if _headers else {}
        )
        _form_params: Dict[str, str] = {}
        _files: Dict[str, str] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if name is not None:
            _path_params["name"] = name
        # process the query parameters
        if query is not None:
            query_param = query.get("limit", None)
            if query_param is not None:
                _query_params["limit"] = query_param

            query_param = query.get("page", None)
            if query_param is not None:
                _query_params["page"] = query_param

            query_param = query.get("deprecated", None)
            if query_param is not None:
                _query_params["deprecated"] = query_param

            query_param = query.get("draft", None)
            if query_param is not None:
                _query_params["draft"] = query_param

            query_param = query.get("version", None)
            if query_param is not None:
                _query_params["version"] = query_param

            query_param = query.get("status", None)
            if query_param is not None:
                _query_params["status"] = query_param

            query_param = query.get("runtime_version", None)
            if query_param is not None:
                _query_params["runtimeVersion"] = query_param

            query_param = query.get("created_by", None)
            if query_param is not None:
                _query_params["createdBy"] = query_param

            query_param = query.get("updated_by", None)
            if query_param is not None:
                _query_params["updatedBy"] = query_param

            query_param = query.get("created_before", None)
            if query_param is not None:
                _query_params["createdBefore"] = query_param

            query_param = query.get("created_after", None)
            if query_param is not None:
                _query_params["createdAfter"] = query_param

            query_param = query.get("updated_before", None)
            if query_param is not None:
                _query_params["updatedBefore"] = query_param

            query_param = query.get("updated_after", None)
            if query_param is not None:
                _query_params["updatedAfter"] = query_param

            query_param = query.get("archive_format", None)
            if query_param is not None:
                _query_params["archiveFormat"] = [
                    v.value if isinstance(v, enum.Enum) else v for v in query_param
                ]

            query_param = query.get("runtime", None)
            if query_param is not None:
                _query_params["runtime"] = query_param

        # process the form parameters
        # process the body parameter

        return self._api_client.param_serialize(
            method="GET",
            resource_path="/registry/v2/models/{name}/versions",
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            files=_files,
        )

    @overload
    async def patch_metadata(
        self,
        name: Annotated[StrictStr, Field(description="The name of the function.")],
        version: Annotated[
            str, Field(strict=True, description="The version of the function.")
        ],
        *,
        body: Optional[FunctionMeta] = None,
        query: Optional[PatchMetadataQuery] = None,
        _request_timeout: Optional[RESTTimeout] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        with_http_info: Literal[False] = False,
    ) -> GetModelResponseV2:
        ...

    @overload
    async def patch_metadata(
        self,
        name: Annotated[StrictStr, Field(description="The name of the function.")],
        version: Annotated[
            str, Field(strict=True, description="The version of the function.")
        ],
        *,
        body: Optional[FunctionMeta] = None,
        query: Optional[PatchMetadataQuery] = None,
        _request_timeout: Optional[RESTTimeout] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        with_http_info: Literal[True],
    ) -> ApiResponse[GetModelResponseV2]:
        ...

    @validate_call
    async def patch_metadata(
        self,
        name: Annotated[StrictStr, Field(description="The name of the function.")],
        version: Annotated[
            str, Field(strict=True, description="The version of the function.")
        ],
        *,
        body: Optional[FunctionMeta] = None,
        query: Optional[PatchMetadataQuery] = None,
        _request_timeout: Optional[RESTTimeout] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        with_http_info: StrictBool = False,
    ) -> Union[GetModelResponseV2, ApiResponse[GetModelResponseV2]]:
        """Patch Model Metadata.

        Patch the metadata of a model version.

        :param name: The name of the function. (required)
        :type name: str
        :param version: The version of the function. (required)
        :type version: str
        :param body: The request body.
        :type body: FunctionMeta
        :param query: Supported query params. (optional)
        :type query: TypedDict, optional:
            :param query.comment: An optional user-specified comment corresponding to the operation.
            :type query.comment: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :return: Returns the result object.
        """

        _request_params = self._patch_metadata_serialize(
            name=name,
            version=version,
            body=body,
            files=None,
            query=query,
            _headers=_headers,
        )

        _response_types_map: Dict[str, Optional[str]] = {
            "200": "waylay.services.registry.models.GetModelResponseV2",
        }
        response_data = await self._api_client.call_api(
            **_request_params, _request_timeout=_request_timeout
        )
        result = self._api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )
        return result if with_http_info else result.data

    def _patch_metadata_serialize(
        self,
        name,
        version,
        body,
        files,
        query,
        _headers,
    ) -> dict[str, Any]:
        _path_params: Dict[str, str] = {}
        _query_params: Dict[str, Any] = {}
        _header_params: Dict[str, Optional[str]] = (
            {k.lower(): v for k, v in _headers.items()} if _headers else {}
        )
        _form_params: Dict[str, str] = {}
        _files: Dict[str, str] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if name is not None:
            _path_params["name"] = name
        if version is not None:
            _path_params["version"] = version
        # process the query parameters
        if query is not None:
            query_param = query.get("comment", None)
            if query_param is not None:
                _query_params["comment"] = query_param

        # process the form parameters
        # process the body parameter
        if body is not None:
            _body_params = body

        return self._api_client.param_serialize(
            method="PATCH",
            resource_path="/registry/v2/models/{name}/versions/{version}/metadata",
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            files=_files,
        )

    @overload
    async def publish(
        self,
        name: Annotated[StrictStr, Field(description="The name of the function.")],
        version: Annotated[
            str, Field(strict=True, description="The version of the function.")
        ],
        *,
        query: Optional[PublishQuery] = None,
        _request_timeout: Optional[RESTTimeout] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        with_http_info: Literal[False] = False,
    ) -> PostModelJobSyncResponseV2:
        ...

    @overload
    async def publish(
        self,
        name: Annotated[StrictStr, Field(description="The name of the function.")],
        version: Annotated[
            str, Field(strict=True, description="The version of the function.")
        ],
        *,
        query: Optional[PublishQuery] = None,
        _request_timeout: Optional[RESTTimeout] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        with_http_info: Literal[True],
    ) -> ApiResponse[PostModelJobSyncResponseV2]:
        ...

    @validate_call
    async def publish(
        self,
        name: Annotated[StrictStr, Field(description="The name of the function.")],
        version: Annotated[
            str, Field(strict=True, description="The version of the function.")
        ],
        *,
        query: Optional[PublishQuery] = None,
        _request_timeout: Optional[RESTTimeout] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        with_http_info: StrictBool = False,
    ) -> Union[PostModelJobSyncResponseV2, ApiResponse[PostModelJobSyncResponseV2]]:
        """Publish Draft Model.

        Mark the <em>model</em> to be ready and stable, taking it out of draft mode.,    Typically, the <em>model</em> should be in the <code>running</code> status,    such that publishing becomes a simple operation where the existing deployment can be re-used.   In other statuses, plug-registry may need to initiate a new build and deployment procedure.

        :param name: The name of the function. (required)
        :type name: str
        :param version: The version of the function. (required)
        :type version: str
        :param query: Supported query params. (optional)
        :type query: TypedDict, optional:
            :param query.comment: An optional user-specified comment corresponding to the operation.
            :type query.comment: str
            :param query.deprecate_previous: Set the cleanup policy used to automatically deprecate/delete previous versions.
            :type query.deprecate_previous: DeprecatePreviousPolicy
            :param query.var_async: Unless this is set to <code>false</code>, the server will start the required job actions asynchronously and return a <code>202</code> <em>Accepted</em> response. If <code>false</code> the request will block until the job actions are completed, or a timeout occurs.
            :type query.var_async: bool
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :return: Returns the result object.
        """

        _request_params = self._publish_serialize(
            name=name,
            version=version,
            body=None,
            files=None,
            query=query,
            _headers=_headers,
        )

        _response_types_map: Dict[str, Optional[str]] = {
            "201": "waylay.services.registry.models.PostModelJobSyncResponseV2",
            "202": "waylay.services.registry.models.PostModelJobAsyncResponseV2",
        }
        response_data = await self._api_client.call_api(
            **_request_params, _request_timeout=_request_timeout
        )
        result = self._api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )
        return result if with_http_info else result.data

    def _publish_serialize(
        self,
        name,
        version,
        body,
        files,
        query,
        _headers,
    ) -> dict[str, Any]:
        _path_params: Dict[str, str] = {}
        _query_params: Dict[str, Any] = {}
        _header_params: Dict[str, Optional[str]] = (
            {k.lower(): v for k, v in _headers.items()} if _headers else {}
        )
        _form_params: Dict[str, str] = {}
        _files: Dict[str, str] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if name is not None:
            _path_params["name"] = name
        if version is not None:
            _path_params["version"] = version
        # process the query parameters
        if query is not None:
            query_param = query.get("comment", None)
            if query_param is not None:
                _query_params["comment"] = query_param

            query_param = query.get("deprecate_previous", None)
            if query_param is not None:
                _query_params["deprecatePrevious"] = query_param.value

            query_param = query.get("var_async", None)
            if query_param is not None:
                _query_params["async"] = query_param

        # process the form parameters
        # process the body parameter

        return self._api_client.param_serialize(
            method="POST",
            resource_path="/registry/v2/models/{name}/versions/{version}/publish",
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            files=_files,
        )

    @overload
    async def rebuild(
        self,
        name: Annotated[StrictStr, Field(description="The name of the function.")],
        version: Annotated[
            str, Field(strict=True, description="The version of the function.")
        ],
        *,
        query: Optional[RebuildQuery] = None,
        _request_timeout: Optional[RESTTimeout] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        with_http_info: Literal[False] = False,
    ) -> RebuildModelSyncResponseV2:
        ...

    @overload
    async def rebuild(
        self,
        name: Annotated[StrictStr, Field(description="The name of the function.")],
        version: Annotated[
            str, Field(strict=True, description="The version of the function.")
        ],
        *,
        query: Optional[RebuildQuery] = None,
        _request_timeout: Optional[RESTTimeout] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        with_http_info: Literal[True],
    ) -> ApiResponse[RebuildModelSyncResponseV2]:
        ...

    @validate_call
    async def rebuild(
        self,
        name: Annotated[StrictStr, Field(description="The name of the function.")],
        version: Annotated[
            str, Field(strict=True, description="The version of the function.")
        ],
        *,
        query: Optional[RebuildQuery] = None,
        _request_timeout: Optional[RESTTimeout] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        with_http_info: StrictBool = False,
    ) -> Union[RebuildModelSyncResponseV2, ApiResponse[RebuildModelSyncResponseV2]]:
        """Rebuild Model.

        Rebuild and deploy a model with the original or updated base image.

        :param name: The name of the function. (required)
        :type name: str
        :param version: The version of the function. (required)
        :type version: str
        :param query: Supported query params. (optional)
        :type query: TypedDict, optional:
            :param query.comment: An optional user-specified comment corresponding to the operation.
            :type query.comment: str
            :param query.dry_run: If set to <code>true</code>, checks whether rebuild jobs are needed, but do not start any jobs.
            :type query.dry_run: bool
            :param query.var_async: Unless this is set to <code>false</code>, the server will start the required job actions asynchronously and return a <code>202</code> <em>Accepted</em> response. If <code>false</code> the request will block until the job actions are completed, or a timeout occurs.
            :type query.var_async: bool
            :param query.upgrade: If set, force a rebuild with the given <em>runtime</em> version selection policy. <ul>  <li><code>same</code> <b>patch</b> version.   This should only include backward compatible upgrades.  </li>  <li><code>minor</code> <b>major</b> version.   This might include an upgrade of e.g. the language runtime and/or provided   dependencies that could break compatiblity with the function. .</li> </ul>
            :type query.upgrade: RebuildPolicy
            :param query.force_version: If set, force a rebuild with the given runtime version (including downgrades). This parameter is mutually exclusive to the `upgrade` parameter.
            :type query.force_version: str
            :param query.ignore_checks: If set to true, checks that normally prevent a rebuild are overriden. These checks include: * function state in `pending`, `running`, `failed` or `undeployed` * backoff period due to recent failures * usage of deprecated dependencies * running jobs on entity * the `dryRun` option
            :type query.ignore_checks: bool
            :param query.scale_to_zero: Indicates whether the function needs to be scaled down after successful (re-)deployment. If not set, the function is scaled to zero only if it was not active before this command.
            :type query.scale_to_zero: bool
            :param query.skip_rebuild: If set, the function will not be rebuild. Always uses the current runtime version when re-deploying/re-verifying the function.
            :type query.skip_rebuild: bool
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :return: Returns the result object.
        """

        _request_params = self._rebuild_serialize(
            name=name,
            version=version,
            body=None,
            files=None,
            query=query,
            _headers=_headers,
        )

        _response_types_map: Dict[str, Optional[str]] = {
            "200": "waylay.services.registry.models.RebuildModelSyncResponseV2",
            "202": "waylay.services.registry.models.RebuildModelAsyncResponseV2",
        }
        response_data = await self._api_client.call_api(
            **_request_params, _request_timeout=_request_timeout
        )
        result = self._api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )
        return result if with_http_info else result.data

    def _rebuild_serialize(
        self,
        name,
        version,
        body,
        files,
        query,
        _headers,
    ) -> dict[str, Any]:
        _path_params: Dict[str, str] = {}
        _query_params: Dict[str, Any] = {}
        _header_params: Dict[str, Optional[str]] = (
            {k.lower(): v for k, v in _headers.items()} if _headers else {}
        )
        _form_params: Dict[str, str] = {}
        _files: Dict[str, str] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if name is not None:
            _path_params["name"] = name
        if version is not None:
            _path_params["version"] = version
        # process the query parameters
        if query is not None:
            query_param = query.get("comment", None)
            if query_param is not None:
                _query_params["comment"] = query_param

            query_param = query.get("dry_run", None)
            if query_param is not None:
                _query_params["dryRun"] = query_param

            query_param = query.get("var_async", None)
            if query_param is not None:
                _query_params["async"] = query_param

            query_param = query.get("upgrade", None)
            if query_param is not None:
                _query_params["upgrade"] = query_param.value

            query_param = query.get("force_version", None)
            if query_param is not None:
                _query_params["forceVersion"] = query_param

            query_param = query.get("ignore_checks", None)
            if query_param is not None:
                _query_params["ignoreChecks"] = query_param

            query_param = query.get("scale_to_zero", None)
            if query_param is not None:
                _query_params["scaleToZero"] = query_param

            query_param = query.get("skip_rebuild", None)
            if query_param is not None:
                _query_params["skipRebuild"] = query_param

        # process the form parameters
        # process the body parameter

        return self._api_client.param_serialize(
            method="POST",
            resource_path="/registry/v2/models/{name}/versions/{version}/rebuild",
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            files=_files,
        )

    @overload
    async def remove_version(
        self,
        name: Annotated[StrictStr, Field(description="The name of the function.")],
        version: Annotated[
            str, Field(strict=True, description="The version of the function.")
        ],
        *,
        query: Optional[RemoveVersionQuery] = None,
        _request_timeout: Optional[RESTTimeout] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        with_http_info: Literal[False] = False,
    ) -> UndeployedResponseV2:
        ...

    @overload
    async def remove_version(
        self,
        name: Annotated[StrictStr, Field(description="The name of the function.")],
        version: Annotated[
            str, Field(strict=True, description="The version of the function.")
        ],
        *,
        query: Optional[RemoveVersionQuery] = None,
        _request_timeout: Optional[RESTTimeout] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        with_http_info: Literal[True],
    ) -> ApiResponse[UndeployedResponseV2]:
        ...

    @validate_call
    async def remove_version(
        self,
        name: Annotated[StrictStr, Field(description="The name of the function.")],
        version: Annotated[
            str, Field(strict=True, description="The version of the function.")
        ],
        *,
        query: Optional[RemoveVersionQuery] = None,
        _request_timeout: Optional[RESTTimeout] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        with_http_info: StrictBool = False,
    ) -> Union[UndeployedResponseV2, ApiResponse[UndeployedResponseV2]]:
        """Remove Model Version.

        Deprecate, undeploy and/or remove a <em>model</em> version.    By default, a `DELETE`    * _deprecates_ the model version(s): they are no longer included in listings by default.   * _undeploys_ the model version(s) with delay: the function can no longer be invoked, the small delay allows     other services to discover the removal.   * _removes_ the version(s) from the plug registry.    Use `?force=true` to immediately _undeploy_ and _remove_ without delay.    Use `?undeploy=true` to undeploy, but keep the model version registered in a `undeployed` state.   An `undeployed` version can later be restored by a _rebuild_ action.

        :param name: The name of the function. (required)
        :type name: str
        :param version: The version of the function. (required)
        :type version: str
        :param query: Supported query params. (optional)
        :type query: TypedDict, optional:
            :param query.comment: An optional user-specified comment corresponding to the operation.
            :type query.comment: str
            :param query.var_async: Unless this is set to <code>false</code>, the server will start the required job actions asynchronously and return a <code>202</code> <em>Accepted</em> response. If <code>false</code> the request will block until the job actions are completed, or a timeout occurs.
            :type query.var_async: bool
            :param query.force: If <code>true</code>, the function version will be immediately undeployed and removed.  Otherwise, the removal will be delayed to allow current invocations to end. During that period, the function is marked _deprecated_.
            :type query.force: bool
            :param query.undeploy: If `true`, the `DELETE` operation * undeploys the (openfaas) function: it becomes no longer available for invocation. * does NOT remove the function from registry: it stays in an `undeployed` status.  All assets and definitions are retained, so the version can be restored later with a  _rebuild_ action.  If `false`, the `DELETE` operation * _only_ marks the plug function as _deprecated_, the function remains active but is removed from the default listings.   This also applies to _draft_ versions.  This parameter is incompatible with `force=true`.  If not set the default behaviour applies: * _draft_ versions are _undeployed_ and _removed_ from registry. * non-_draft_ versions are marked _deprecated_ only.
            :type query.undeploy: bool
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :return: Returns the result object.
        """

        _request_params = self._remove_version_serialize(
            name=name,
            version=version,
            body=None,
            files=None,
            query=query,
            _headers=_headers,
        )

        _response_types_map: Dict[str, Optional[str]] = {
            "200": "waylay.services.registry.models.UndeployedResponseV2",
            "202": "waylay.services.registry.models.UndeploySubmittedResponseV2",
        }
        response_data = await self._api_client.call_api(
            **_request_params, _request_timeout=_request_timeout
        )
        result = self._api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )
        return result if with_http_info else result.data

    def _remove_version_serialize(
        self,
        name,
        version,
        body,
        files,
        query,
        _headers,
    ) -> dict[str, Any]:
        _path_params: Dict[str, str] = {}
        _query_params: Dict[str, Any] = {}
        _header_params: Dict[str, Optional[str]] = (
            {k.lower(): v for k, v in _headers.items()} if _headers else {}
        )
        _form_params: Dict[str, str] = {}
        _files: Dict[str, str] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if name is not None:
            _path_params["name"] = name
        if version is not None:
            _path_params["version"] = version
        # process the query parameters
        if query is not None:
            query_param = query.get("comment", None)
            if query_param is not None:
                _query_params["comment"] = query_param

            query_param = query.get("var_async", None)
            if query_param is not None:
                _query_params["async"] = query_param

            query_param = query.get("force", None)
            if query_param is not None:
                _query_params["force"] = query_param

            query_param = query.get("undeploy", None)
            if query_param is not None:
                _query_params["undeploy"] = query_param

        # process the form parameters
        # process the body parameter

        return self._api_client.param_serialize(
            method="DELETE",
            resource_path="/registry/v2/models/{name}/versions/{version}",
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            files=_files,
        )

    @overload
    async def remove_versions(
        self,
        name: Annotated[StrictStr, Field(description="The name of the function.")],
        *,
        query: Optional[RemoveVersionsQuery] = None,
        _request_timeout: Optional[RESTTimeout] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        with_http_info: Literal[False] = False,
    ) -> UndeployedResponseV2:
        ...

    @overload
    async def remove_versions(
        self,
        name: Annotated[StrictStr, Field(description="The name of the function.")],
        *,
        query: Optional[RemoveVersionsQuery] = None,
        _request_timeout: Optional[RESTTimeout] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        with_http_info: Literal[True],
    ) -> ApiResponse[UndeployedResponseV2]:
        ...

    @validate_call
    async def remove_versions(
        self,
        name: Annotated[StrictStr, Field(description="The name of the function.")],
        *,
        query: Optional[RemoveVersionsQuery] = None,
        _request_timeout: Optional[RESTTimeout] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        with_http_info: StrictBool = False,
    ) -> Union[UndeployedResponseV2, ApiResponse[UndeployedResponseV2]]:
        """Remove Model.

        Deprecate, undeploy and/or remove all versions of this named <em>model</em>.    By default, a `DELETE`    * _deprecates_ the model version(s): they are no longer included in listings by default.   * _undeploys_ the model version(s) with delay: the function can no longer be invoked, the small delay allows     other services to discover the removal.   * _removes_ the version(s) from the plug registry.    Use `?force=true` to immediately _undeploy_ and _remove_ without delay.    Use `?undeploy=true` to undeploy, but keep the model version registered in a `undeployed` state.   An `undeployed` version can later be restored by a _rebuild_ action.

        :param name: The name of the function. (required)
        :type name: str
        :param query: Supported query params. (optional)
        :type query: TypedDict, optional:
            :param query.comment: An optional user-specified comment corresponding to the operation.
            :type query.comment: str
            :param query.force: If <code>true</code>, the function version will be immediately undeployed and removed.  Otherwise, the removal will be delayed to allow current invocations to end. During that period, the function is marked _deprecated_.
            :type query.force: bool
            :param query.undeploy: If `true`, the `DELETE` operation * undeploys the (openfaas) function: it becomes no longer available for invocation. * does NOT remove the function from registry: it stays in an `undeployed` status.  All assets and definitions are retained, so the version can be restored later with a  _rebuild_ action.  If `false`, the `DELETE` operation * _only_ marks the plug function as _deprecated_, the function remains active but is removed from the default listings.   This also applies to _draft_ versions.  This parameter is incompatible with `force=true`.  If not set the default behaviour applies: * _draft_ versions are _undeployed_ and _removed_ from registry. * non-_draft_ versions are marked _deprecated_ only.
            :type query.undeploy: bool
            :param query.var_async: Unless this is set to <code>false</code>, the server will start the required job actions asynchronously and return a <code>202</code> <em>Accepted</em> response. If <code>false</code> the request will block until the job actions are completed, or a timeout occurs.
            :type query.var_async: bool
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :return: Returns the result object.
        """

        _request_params = self._remove_versions_serialize(
            name=name,
            body=None,
            files=None,
            query=query,
            _headers=_headers,
        )

        _response_types_map: Dict[str, Optional[str]] = {
            "200": "waylay.services.registry.models.UndeployedResponseV2",
            "202": "waylay.services.registry.models.UndeploySubmittedResponseV2",
        }
        response_data = await self._api_client.call_api(
            **_request_params, _request_timeout=_request_timeout
        )
        result = self._api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )
        return result if with_http_info else result.data

    def _remove_versions_serialize(
        self,
        name,
        body,
        files,
        query,
        _headers,
    ) -> dict[str, Any]:
        _path_params: Dict[str, str] = {}
        _query_params: Dict[str, Any] = {}
        _header_params: Dict[str, Optional[str]] = (
            {k.lower(): v for k, v in _headers.items()} if _headers else {}
        )
        _form_params: Dict[str, str] = {}
        _files: Dict[str, str] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if name is not None:
            _path_params["name"] = name
        # process the query parameters
        if query is not None:
            query_param = query.get("comment", None)
            if query_param is not None:
                _query_params["comment"] = query_param

            query_param = query.get("force", None)
            if query_param is not None:
                _query_params["force"] = query_param

            query_param = query.get("undeploy", None)
            if query_param is not None:
                _query_params["undeploy"] = query_param

            query_param = query.get("var_async", None)
            if query_param is not None:
                _query_params["async"] = query_param

        # process the form parameters
        # process the body parameter

        return self._api_client.param_serialize(
            method="DELETE",
            resource_path="/registry/v2/models/{name}",
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            files=_files,
        )

    @overload
    async def update_asset(
        self,
        name: Annotated[StrictStr, Field(description="The name of the function.")],
        version: Annotated[
            str, Field(strict=True, description="The version of the function.")
        ],
        wildcard: Annotated[
            StrictStr,
            Field(
                description="Full path or path prefix of the asset within the archive"
            ),
        ],
        *,
        body: Annotated[
            Optional[FileUpload], Field(description="A single asset file.")
        ] = None,
        query: Optional[UpdateAssetQuery] = None,
        _request_timeout: Optional[RESTTimeout] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        with_http_info: Literal[False] = False,
    ) -> PostModelJobSyncResponseV2:
        ...

    @overload
    async def update_asset(
        self,
        name: Annotated[StrictStr, Field(description="The name of the function.")],
        version: Annotated[
            str, Field(strict=True, description="The version of the function.")
        ],
        wildcard: Annotated[
            StrictStr,
            Field(
                description="Full path or path prefix of the asset within the archive"
            ),
        ],
        *,
        body: Annotated[
            Optional[FileUpload], Field(description="A single asset file.")
        ] = None,
        query: Optional[UpdateAssetQuery] = None,
        _request_timeout: Optional[RESTTimeout] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        with_http_info: Literal[True],
    ) -> ApiResponse[PostModelJobSyncResponseV2]:
        ...

    @validate_call
    async def update_asset(
        self,
        name: Annotated[StrictStr, Field(description="The name of the function.")],
        version: Annotated[
            str, Field(strict=True, description="The version of the function.")
        ],
        wildcard: Annotated[
            StrictStr,
            Field(
                description="Full path or path prefix of the asset within the archive"
            ),
        ],
        *,
        body: Annotated[
            Optional[FileUpload], Field(description="A single asset file.")
        ] = None,
        query: Optional[UpdateAssetQuery] = None,
        _request_timeout: Optional[RESTTimeout] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        with_http_info: StrictBool = False,
    ) -> Union[PostModelJobSyncResponseV2, ApiResponse[PostModelJobSyncResponseV2]]:
        """Update Model Asset.

        The provided asset will be added to the <em>model</em> function's collection of existing assets,   replacing any existing asset with the same name.    Please note that it is not allowed to update the model.json json file with a changed value for any of the     <code>name</code>, <code>version</code> and/or <code>runtime</code> attributes.    For each <em>runtime</em> other files are supported.

        :param name: The name of the function. (required)
        :type name: str
        :param version: The version of the function. (required)
        :type version: str
        :param wildcard: Full path or path prefix of the asset within the archive (required)
        :type wildcard: str
        :param body: A single asset file.
        :type body: FileUpload
        :param query: Supported query params. (optional)
        :type query: TypedDict, optional:
            :param query.comment: An optional user-specified comment corresponding to the operation.
            :type query.comment: str
            :param query.var_async: Unless this is set to <code>false</code>, the server will start the required job actions asynchronously and return a <code>202</code> <em>Accepted</em> response. If <code>false</code> the request will block until the job actions are completed, or a timeout occurs.
            :type query.var_async: bool
            :param query.chown: If set, ownership of the draft function is transferred to the current user. (required)
            :type query.chown: bool
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :return: Returns the result object.
        """

        _request_params = self._update_asset_serialize(
            name=name,
            version=version,
            wildcard=wildcard,
            body=body,
            files=None,
            query=query,
            _headers=_headers,
        )

        _response_types_map: Dict[str, Optional[str]] = {
            "201": "waylay.services.registry.models.PostModelJobSyncResponseV2",
            "202": "waylay.services.registry.models.PostModelJobAsyncResponseV2",
        }
        response_data = await self._api_client.call_api(
            **_request_params, _request_timeout=_request_timeout
        )
        result = self._api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )
        return result if with_http_info else result.data

    def _update_asset_serialize(
        self,
        name,
        version,
        wildcard,
        body,
        files,
        query,
        _headers,
    ) -> dict[str, Any]:
        _path_params: Dict[str, str] = {}
        _query_params: Dict[str, Any] = {}
        _header_params: Dict[str, Optional[str]] = (
            {k.lower(): v for k, v in _headers.items()} if _headers else {}
        )
        _form_params: Dict[str, str] = {}
        _files: Dict[str, str] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if name is not None:
            _path_params["name"] = name
        if version is not None:
            _path_params["version"] = version
        if wildcard is not None:
            _path_params["wildcard"] = wildcard
        # process the query parameters
        if query is not None:
            query_param = query.get("comment", None)
            if query_param is not None:
                _query_params["comment"] = query_param

            query_param = query.get("var_async", None)
            if query_param is not None:
                _query_params["async"] = query_param

            query_param = query.get("chown", None)
            if query_param is not None:
                _query_params["chown"] = query_param

        # process the form parameters
        # process the body parameter
        if body is not None:
            _body_params = body

        return self._api_client.param_serialize(
            method="PUT",
            resource_path="/registry/v2/models/{name}/versions/{version}/content/{wildcard}",
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            files=_files,
        )

    @overload
    async def update_assets(
        self,
        name: Annotated[StrictStr, Field(description="The name of the function.")],
        version: Annotated[
            str, Field(strict=True, description="The version of the function.")
        ],
        *,
        body: Union[
            Annotated[
                Optional[MultipartFileUpload],
                Field(
                    description="The assets for a <em>model</em> function can be provided as either   <ul>     <li>a single <em>tar</em> archive (optionally compressed), with one of the content types      <code>application/octet-stream</code>, <code>application/tar+gzip</code>, <code>application/x-gzip</code>, <code>application/x-tar</code>, <code>application/gzip</code></li>     <li>separate files in a <code>multipart/form-data</code> request</li>   </ul>    The provided assets will be added to the <em>model</em> function's collection of existing assets,   replacing any existing assets with the same name.    Please note that it is not allowed to update the model.json</code> json file with a changed value for any of the    <code>name</code>, <code>version</code> and/or <code>runtime</code> attributes.    For each <em>runtime</em> other files are supported. "
                ),
            ],
            Annotated[
                Dict[StrictStr, Any], Field(description="Multipart file upload.")
            ],
        ] = None,
        files: Annotated[
            Optional[Dict[StrictStr, Any]], Field(description="Multipart file upload.")
        ] = None,
        query: Optional[UpdateAssetsQuery] = None,
        _request_timeout: Optional[RESTTimeout] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        with_http_info: Literal[False] = False,
    ) -> PostModelJobSyncResponseV2:
        ...

    @overload
    async def update_assets(
        self,
        name: Annotated[StrictStr, Field(description="The name of the function.")],
        version: Annotated[
            str, Field(strict=True, description="The version of the function.")
        ],
        *,
        body: Union[
            Annotated[
                Optional[MultipartFileUpload],
                Field(
                    description="The assets for a <em>model</em> function can be provided as either   <ul>     <li>a single <em>tar</em> archive (optionally compressed), with one of the content types      <code>application/octet-stream</code>, <code>application/tar+gzip</code>, <code>application/x-gzip</code>, <code>application/x-tar</code>, <code>application/gzip</code></li>     <li>separate files in a <code>multipart/form-data</code> request</li>   </ul>    The provided assets will be added to the <em>model</em> function's collection of existing assets,   replacing any existing assets with the same name.    Please note that it is not allowed to update the model.json</code> json file with a changed value for any of the    <code>name</code>, <code>version</code> and/or <code>runtime</code> attributes.    For each <em>runtime</em> other files are supported. "
                ),
            ],
            Annotated[
                Dict[StrictStr, Any], Field(description="Multipart file upload.")
            ],
        ] = None,
        files: Annotated[
            Optional[Dict[StrictStr, Any]], Field(description="Multipart file upload.")
        ] = None,
        query: Optional[UpdateAssetsQuery] = None,
        _request_timeout: Optional[RESTTimeout] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        with_http_info: Literal[True],
    ) -> ApiResponse[PostModelJobSyncResponseV2]:
        ...

    @validate_call
    async def update_assets(
        self,
        name: Annotated[StrictStr, Field(description="The name of the function.")],
        version: Annotated[
            str, Field(strict=True, description="The version of the function.")
        ],
        *,
        body: Union[
            Annotated[
                Optional[MultipartFileUpload],
                Field(
                    description="The assets for a <em>model</em> function can be provided as either   <ul>     <li>a single <em>tar</em> archive (optionally compressed), with one of the content types      <code>application/octet-stream</code>, <code>application/tar+gzip</code>, <code>application/x-gzip</code>, <code>application/x-tar</code>, <code>application/gzip</code></li>     <li>separate files in a <code>multipart/form-data</code> request</li>   </ul>    The provided assets will be added to the <em>model</em> function's collection of existing assets,   replacing any existing assets with the same name.    Please note that it is not allowed to update the model.json</code> json file with a changed value for any of the    <code>name</code>, <code>version</code> and/or <code>runtime</code> attributes.    For each <em>runtime</em> other files are supported. "
                ),
            ],
            Annotated[
                Dict[StrictStr, Any], Field(description="Multipart file upload.")
            ],
        ] = None,
        files: Annotated[
            Optional[Dict[StrictStr, Any]], Field(description="Multipart file upload.")
        ] = None,
        query: Optional[UpdateAssetsQuery] = None,
        _request_timeout: Optional[RESTTimeout] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        with_http_info: StrictBool = False,
    ) -> Union[PostModelJobSyncResponseV2, ApiResponse[PostModelJobSyncResponseV2]]:
        """Update Model Assets.

        Update a draft <em>model</em> function by updating its assets.      The assets for a <em>model</em> function can be provided as either   <ul>     <li>a single <em>tar</em> archive (optionally compressed), with one of the content types      <code>application/octet-stream</code>, <code>application/tar+gzip</code>, <code>application/x-gzip</code>, <code>application/x-tar</code>, <code>application/gzip</code></li>     <li>separate files in a <code>multipart/form-data</code> request</li>   </ul>    The provided assets will be added to the <em>model</em> function's collection of existing assets,   replacing any existing assets with the same name.    Please note that it is not allowed to update the model.json</code> json file with a changed value for any of the    <code>name</code>, <code>version</code> and/or <code>runtime</code> attributes.    For each <em>runtime</em> other files are supported.

        :param name: The name of the function. (required)
        :type name: str
        :param version: The version of the function. (required)
        :type version: str
        :param body: The assets for a <em>model</em> function can be provided as either   <ul>     <li>a single <em>tar</em> archive (optionally compressed), with one of the content types      <code>application/octet-stream</code>, <code>application/tar+gzip</code>, <code>application/x-gzip</code>, <code>application/x-tar</code>, <code>application/gzip</code></li>     <li>separate files in a <code>multipart/form-data</code> request</li>   </ul>    The provided assets will be added to the <em>model</em> function's collection of existing assets,   replacing any existing assets with the same name.    Please note that it is not allowed to update the model.json</code> json file with a changed value for any of the    <code>name</code>, <code>version</code> and/or <code>runtime</code> attributes.    For each <em>runtime</em> other files are supported.
        :type body: MultipartFileUpload
        :param files: The multipart file upload. This equivalent to setting `body` along with the `content-type: multipart/form-data` header.
        :type files: Dict[str, bytearray], optional,
        :param query: Supported query params. (optional)
        :type query: TypedDict, optional:
            :param query.comment: An optional user-specified comment corresponding to the operation.
            :type query.comment: str
            :param query.var_async: Unless this is set to <code>false</code>, the server will start the required job actions asynchronously and return a <code>202</code> <em>Accepted</em> response. If <code>false</code> the request will block until the job actions are completed, or a timeout occurs.
            :type query.var_async: bool
            :param query.chown: If set, ownership of the draft function is transferred to the current user. (required)
            :type query.chown: bool
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :return: Returns the result object.
        """

        _request_params = self._update_assets_serialize(
            name=name,
            version=version,
            body=body,
            files=files,
            query=query,
            _headers=_headers,
        )

        _response_types_map: Dict[str, Optional[str]] = {
            "201": "waylay.services.registry.models.PostModelJobSyncResponseV2",
            "202": "waylay.services.registry.models.PostModelJobAsyncResponseV2",
        }
        response_data = await self._api_client.call_api(
            **_request_params, _request_timeout=_request_timeout
        )
        result = self._api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )
        return result if with_http_info else result.data

    def _update_assets_serialize(
        self,
        name,
        version,
        body,
        files,
        query,
        _headers,
    ) -> dict[str, Any]:
        _path_params: Dict[str, str] = {}
        _query_params: Dict[str, Any] = {}
        _header_params: Dict[str, Optional[str]] = (
            {k.lower(): v for k, v in _headers.items()} if _headers else {}
        )
        _form_params: Dict[str, str] = {}
        _files: Dict[str, str] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if name is not None:
            _path_params["name"] = name
        if version is not None:
            _path_params["version"] = version
        # process the query parameters
        if query is not None:
            query_param = query.get("comment", None)
            if query_param is not None:
                _query_params["comment"] = query_param

            query_param = query.get("var_async", None)
            if query_param is not None:
                _query_params["async"] = query_param

            query_param = query.get("chown", None)
            if query_param is not None:
                _query_params["chown"] = query_param

        # process the form parameters
        if files:
            _files.update(files)
        # if `body` and `content-type` multipart/form-data, wrap it in `files` instead of `body`
        content_type = _header_params.get("content-type")
        if (
            not files
            and body
            and content_type
            and content_type.startswith("multipart/form-data")
        ):
            try:
                _files.update(body)
                body = None
                if "boundary" not in content_type:
                    # Content-Type header does not cotain a boundary, and hence, is not valid.
                    # Remove it to force the http framework to set it instead.
                    del _header_params["content-type"]
            except ValueError as err:
                raise ApiValueError("Body is not a valid dictionary", "body") from err
        # process the body parameter
        if body is not None:
            _body_params = body

        return self._api_client.param_serialize(
            method="PUT",
            resource_path="/registry/v2/models/{name}/versions/{version}/content",
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            files=_files,
        )

    @overload
    async def verify(
        self,
        name: Annotated[StrictStr, Field(description="The name of the function.")],
        version: Annotated[
            str, Field(strict=True, description="The version of the function.")
        ],
        *,
        query: Optional[VerifyQuery] = None,
        _request_timeout: Optional[RESTTimeout] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        with_http_info: Literal[False] = False,
    ) -> VerifyModelSyncResponseV2:
        ...

    @overload
    async def verify(
        self,
        name: Annotated[StrictStr, Field(description="The name of the function.")],
        version: Annotated[
            str, Field(strict=True, description="The version of the function.")
        ],
        *,
        query: Optional[VerifyQuery] = None,
        _request_timeout: Optional[RESTTimeout] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        with_http_info: Literal[True],
    ) -> ApiResponse[VerifyModelSyncResponseV2]:
        ...

    @validate_call
    async def verify(
        self,
        name: Annotated[StrictStr, Field(description="The name of the function.")],
        version: Annotated[
            str, Field(strict=True, description="The version of the function.")
        ],
        *,
        query: Optional[VerifyQuery] = None,
        _request_timeout: Optional[RESTTimeout] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        with_http_info: StrictBool = False,
    ) -> Union[VerifyModelSyncResponseV2, ApiResponse[VerifyModelSyncResponseV2]]:
        """Verify Health Of Model.

        Verify health of model deployed on openfaas.

        :param name: The name of the function. (required)
        :type name: str
        :param version: The version of the function. (required)
        :type version: str
        :param query: Supported query params. (optional)
        :type query: TypedDict, optional:
            :param query.comment: An optional user-specified comment corresponding to the operation.
            :type query.comment: str
            :param query.var_async: Unless this is set to <code>false</code>, the server will start the required job actions asynchronously and return a <code>202</code> <em>Accepted</em> response. If <code>false</code> the request will block until the job actions are completed, or a timeout occurs.
            :type query.var_async: bool
            :param query.scale_to_zero: Indicates whether the function needs to be scaled down after successful verification. If not set, the function is scaled to zero only if it was not active before this command.
            :type query.scale_to_zero: bool
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :return: Returns the result object.
        """

        _request_params = self._verify_serialize(
            name=name,
            version=version,
            body=None,
            files=None,
            query=query,
            _headers=_headers,
        )

        _response_types_map: Dict[str, Optional[str]] = {
            "200": "waylay.services.registry.models.VerifyModelSyncResponseV2",
            "202": "waylay.services.registry.models.PostModelJobAsyncResponseV2",
        }
        response_data = await self._api_client.call_api(
            **_request_params, _request_timeout=_request_timeout
        )
        result = self._api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )
        return result if with_http_info else result.data

    def _verify_serialize(
        self,
        name,
        version,
        body,
        files,
        query,
        _headers,
    ) -> dict[str, Any]:
        _path_params: Dict[str, str] = {}
        _query_params: Dict[str, Any] = {}
        _header_params: Dict[str, Optional[str]] = (
            {k.lower(): v for k, v in _headers.items()} if _headers else {}
        )
        _form_params: Dict[str, str] = {}
        _files: Dict[str, str] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if name is not None:
            _path_params["name"] = name
        if version is not None:
            _path_params["version"] = version
        # process the query parameters
        if query is not None:
            query_param = query.get("comment", None)
            if query_param is not None:
                _query_params["comment"] = query_param

            query_param = query.get("var_async", None)
            if query_param is not None:
                _query_params["async"] = query_param

            query_param = query.get("scale_to_zero", None)
            if query_param is not None:
                _query_params["scaleToZero"] = query_param

        # process the form parameters
        # process the body parameter

        return self._api_client.param_serialize(
            method="POST",
            resource_path="/registry/v2/models/{name}/versions/{version}/verify",
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            files=_files,
        )
