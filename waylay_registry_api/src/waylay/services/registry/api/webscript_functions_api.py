# coding: utf-8
"""Waylay Function Registry api.

This code was generated from the OpenAPI documentation of 'Waylay Function Registry'

Generated by OpenAPI Generator (https://openapi-generator.tech)

Do not edit the class manually.
"""

from __future__ import annotations  # for Python 3.7â€“3.9

from pydantic import Field, StrictStr, StrictBool, TypeAdapter, ConfigDict
from typing import (
    Dict,
    Literal,
    Optional,
    Union,
    Any,
    overload,
    TYPE_CHECKING,
)
from typing_extensions import (
    Annotated,  # >=3.9,
)

from waylay.sdk.plugin import WithApiClient
from waylay.sdk.api import (
    Response,
    HeaderTypes,
    QueryParamTypes,
    RequestFiles,
    RequestContent,
)
from waylay.sdk.api._models import Model

if TYPE_CHECKING:
    from waylay.services.registry.models import MultipartFileUpload

    from waylay.services.registry.queries.webscript_functions_api import CreateQuery

    from waylay.services.registry.models import PostWebscriptJobSyncResponseV2

    from waylay.services.registry.models import PostWebscriptJobSyncResponseV2
    from waylay.services.registry.models import PostWebscriptJobAsyncResponseV2

    from waylay.services.registry.queries.webscript_functions_api import (
        DeleteAssetQuery,
    )

    from waylay.services.registry.models import PostWebscriptJobSyncResponseV2

    from waylay.services.registry.models import PostWebscriptJobSyncResponseV2
    from waylay.services.registry.models import PostWebscriptJobAsyncResponseV2

    from waylay.services.registry.queries.webscript_functions_api import GetArchiveQuery

    from waylay.services.registry.queries.webscript_functions_api import GetAssetQuery

    from waylay.services.registry.queries.webscript_functions_api import GetLatestQuery

    from waylay.services.registry.models import GetWebscriptResponseV2

    from waylay.services.registry.models import GetWebscriptResponseV2

    from waylay.services.registry.queries.webscript_functions_api import GetQuery

    from waylay.services.registry.models import GetWebscriptResponseV2

    from waylay.services.registry.models import GetWebscriptResponseV2

    from waylay.services.registry.queries.webscript_functions_api import JobsQuery

    from waylay.services.registry.models import JobsForWebscriptResponseV2

    from waylay.services.registry.models import JobsForWebscriptResponseV2

    from waylay.services.registry.queries.webscript_functions_api import (
        ListVersionsQuery,
    )

    from waylay.services.registry.models import WebscriptVersionsResponseV2

    from waylay.services.registry.models import WebscriptVersionsResponseV2

    from waylay.services.registry.queries.webscript_functions_api import ListQuery

    from waylay.services.registry.models import LatestWebscriptsResponseV2

    from waylay.services.registry.models import LatestWebscriptsResponseV2

    from waylay.services.registry.models import FunctionMeta

    from waylay.services.registry.queries.webscript_functions_api import (
        PatchMetadataQuery,
    )

    from waylay.services.registry.models import GetWebscriptResponseV2

    from waylay.services.registry.models import GetWebscriptResponseV2

    from waylay.services.registry.queries.webscript_functions_api import PublishQuery

    from waylay.services.registry.models import PostWebscriptJobSyncResponseV2

    from waylay.services.registry.models import PostWebscriptJobSyncResponseV2
    from waylay.services.registry.models import PostWebscriptJobAsyncResponseV2

    from waylay.services.registry.queries.webscript_functions_api import RebuildQuery

    from waylay.services.registry.models import RebuildWebscriptSyncResponseV2

    from waylay.services.registry.models import RebuildWebscriptSyncResponseV2
    from waylay.services.registry.models import RebuildWebscriptAsyncResponseV2

    from waylay.services.registry.queries.webscript_functions_api import (
        RemoveVersionQuery,
    )

    from waylay.services.registry.models import UndeployedResponseV2

    from waylay.services.registry.models import UndeployedResponseV2
    from waylay.services.registry.models import UndeploySubmittedResponseV2

    from waylay.services.registry.queries.webscript_functions_api import (
        RemoveVersionsQuery,
    )

    from waylay.services.registry.models import UndeployedResponseV2

    from waylay.services.registry.models import UndeployedResponseV2
    from waylay.services.registry.models import UndeploySubmittedResponseV2

    from waylay.services.registry.models import FileUpload

    from waylay.services.registry.queries.webscript_functions_api import (
        UpdateAssetQuery,
    )

    from waylay.services.registry.models import PostWebscriptJobSyncResponseV2

    from waylay.services.registry.models import PostWebscriptJobSyncResponseV2
    from waylay.services.registry.models import PostWebscriptJobAsyncResponseV2

    from waylay.services.registry.models import MultipartFileUpload

    from waylay.services.registry.queries.webscript_functions_api import (
        UpdateAssetsQuery,
    )

    from waylay.services.registry.models import PostWebscriptJobSyncResponseV2

    from waylay.services.registry.models import PostWebscriptJobSyncResponseV2
    from waylay.services.registry.models import PostWebscriptJobAsyncResponseV2

    from waylay.services.registry.queries.webscript_functions_api import VerifyQuery

    from waylay.services.registry.models import VerifyWebscriptSyncResponseV2

    from waylay.services.registry.models import VerifyWebscriptSyncResponseV2
    from waylay.services.registry.models import PostWebscriptJobAsyncResponseV2


try:
    from waylay.services.registry.models import MultipartFileUpload

    from waylay.services.registry.queries.webscript_functions_api import CreateQuery

    from waylay.services.registry.models import PostWebscriptJobSyncResponseV2

    from waylay.services.registry.models import PostWebscriptJobSyncResponseV2
    from waylay.services.registry.models import PostWebscriptJobAsyncResponseV2

    from waylay.services.registry.queries.webscript_functions_api import (
        DeleteAssetQuery,
    )

    from waylay.services.registry.models import PostWebscriptJobSyncResponseV2

    from waylay.services.registry.models import PostWebscriptJobSyncResponseV2
    from waylay.services.registry.models import PostWebscriptJobAsyncResponseV2

    from waylay.services.registry.queries.webscript_functions_api import GetArchiveQuery

    from waylay.services.registry.queries.webscript_functions_api import GetAssetQuery

    from waylay.services.registry.queries.webscript_functions_api import GetLatestQuery

    from waylay.services.registry.models import GetWebscriptResponseV2

    from waylay.services.registry.models import GetWebscriptResponseV2

    from waylay.services.registry.queries.webscript_functions_api import GetQuery

    from waylay.services.registry.models import GetWebscriptResponseV2

    from waylay.services.registry.models import GetWebscriptResponseV2

    from waylay.services.registry.queries.webscript_functions_api import JobsQuery

    from waylay.services.registry.models import JobsForWebscriptResponseV2

    from waylay.services.registry.models import JobsForWebscriptResponseV2

    from waylay.services.registry.queries.webscript_functions_api import (
        ListVersionsQuery,
    )

    from waylay.services.registry.models import WebscriptVersionsResponseV2

    from waylay.services.registry.models import WebscriptVersionsResponseV2

    from waylay.services.registry.queries.webscript_functions_api import ListQuery

    from waylay.services.registry.models import LatestWebscriptsResponseV2

    from waylay.services.registry.models import LatestWebscriptsResponseV2

    from waylay.services.registry.models import FunctionMeta

    from waylay.services.registry.queries.webscript_functions_api import (
        PatchMetadataQuery,
    )

    from waylay.services.registry.models import GetWebscriptResponseV2

    from waylay.services.registry.models import GetWebscriptResponseV2

    from waylay.services.registry.queries.webscript_functions_api import PublishQuery

    from waylay.services.registry.models import PostWebscriptJobSyncResponseV2

    from waylay.services.registry.models import PostWebscriptJobSyncResponseV2
    from waylay.services.registry.models import PostWebscriptJobAsyncResponseV2

    from waylay.services.registry.queries.webscript_functions_api import RebuildQuery

    from waylay.services.registry.models import RebuildWebscriptSyncResponseV2

    from waylay.services.registry.models import RebuildWebscriptSyncResponseV2
    from waylay.services.registry.models import RebuildWebscriptAsyncResponseV2

    from waylay.services.registry.queries.webscript_functions_api import (
        RemoveVersionQuery,
    )

    from waylay.services.registry.models import UndeployedResponseV2

    from waylay.services.registry.models import UndeployedResponseV2
    from waylay.services.registry.models import UndeploySubmittedResponseV2

    from waylay.services.registry.queries.webscript_functions_api import (
        RemoveVersionsQuery,
    )

    from waylay.services.registry.models import UndeployedResponseV2

    from waylay.services.registry.models import UndeployedResponseV2
    from waylay.services.registry.models import UndeploySubmittedResponseV2

    from waylay.services.registry.models import FileUpload

    from waylay.services.registry.queries.webscript_functions_api import (
        UpdateAssetQuery,
    )

    from waylay.services.registry.models import PostWebscriptJobSyncResponseV2

    from waylay.services.registry.models import PostWebscriptJobSyncResponseV2
    from waylay.services.registry.models import PostWebscriptJobAsyncResponseV2

    from waylay.services.registry.models import MultipartFileUpload

    from waylay.services.registry.queries.webscript_functions_api import (
        UpdateAssetsQuery,
    )

    from waylay.services.registry.models import PostWebscriptJobSyncResponseV2

    from waylay.services.registry.models import PostWebscriptJobSyncResponseV2
    from waylay.services.registry.models import PostWebscriptJobAsyncResponseV2

    from waylay.services.registry.queries.webscript_functions_api import VerifyQuery

    from waylay.services.registry.models import VerifyWebscriptSyncResponseV2

    from waylay.services.registry.models import VerifyWebscriptSyncResponseV2
    from waylay.services.registry.models import PostWebscriptJobAsyncResponseV2

    types_available = True
except ImportError:
    types_available = False

    if not TYPE_CHECKING:
        MultipartFileUpload = Model

        CreateQuery = dict

        PostWebscriptJobSyncResponseV2 = Model

        PostWebscriptJobSyncResponseV2 = Model
        PostWebscriptJobAsyncResponseV2 = Model

        DeleteAssetQuery = dict

        PostWebscriptJobSyncResponseV2 = Model

        PostWebscriptJobSyncResponseV2 = Model
        PostWebscriptJobAsyncResponseV2 = Model

        GetArchiveQuery = dict

        GetAssetQuery = dict

        GetLatestQuery = dict

        GetWebscriptResponseV2 = Model

        GetWebscriptResponseV2 = Model

        GetQuery = dict

        GetWebscriptResponseV2 = Model

        GetWebscriptResponseV2 = Model

        JobsQuery = dict

        JobsForWebscriptResponseV2 = Model

        JobsForWebscriptResponseV2 = Model

        ListVersionsQuery = dict

        WebscriptVersionsResponseV2 = Model

        WebscriptVersionsResponseV2 = Model

        ListQuery = dict

        LatestWebscriptsResponseV2 = Model

        LatestWebscriptsResponseV2 = Model

        FunctionMeta = Model

        PatchMetadataQuery = dict

        GetWebscriptResponseV2 = Model

        GetWebscriptResponseV2 = Model

        PublishQuery = dict

        PostWebscriptJobSyncResponseV2 = Model

        PostWebscriptJobSyncResponseV2 = Model
        PostWebscriptJobAsyncResponseV2 = Model

        RebuildQuery = dict

        RebuildWebscriptSyncResponseV2 = Model

        RebuildWebscriptSyncResponseV2 = Model
        RebuildWebscriptAsyncResponseV2 = Model

        RemoveVersionQuery = dict

        UndeployedResponseV2 = Model

        UndeployedResponseV2 = Model
        UndeploySubmittedResponseV2 = Model

        RemoveVersionsQuery = dict

        UndeployedResponseV2 = Model

        UndeployedResponseV2 = Model
        UndeploySubmittedResponseV2 = Model

        FileUpload = Model

        UpdateAssetQuery = dict

        PostWebscriptJobSyncResponseV2 = Model

        PostWebscriptJobSyncResponseV2 = Model
        PostWebscriptJobAsyncResponseV2 = Model

        MultipartFileUpload = Model

        UpdateAssetsQuery = dict

        PostWebscriptJobSyncResponseV2 = Model

        PostWebscriptJobSyncResponseV2 = Model
        PostWebscriptJobAsyncResponseV2 = Model

        VerifyQuery = dict

        VerifyWebscriptSyncResponseV2 = Model

        VerifyWebscriptSyncResponseV2 = Model
        PostWebscriptJobAsyncResponseV2 = Model


StringAdapter = TypeAdapter(str, config=ConfigDict(coerce_numbers_to_str=True))


class WebscriptFunctionsApi(WithApiClient):
    """WebscriptFunctionsApi service methods.

    NOTE: This class is auto generated by OpenAPI Generator
    Ref: https://openapi-generator.tech

    Do not edit the class manually.
    """

    @overload
    async def create(
        self,
        *,
        content: Annotated[
            Optional[RequestContent],
            Field(
                description="The assets for a <em>webscript</em> function can be provided as either   <ul>     <li>a single <em>tar</em> archive (optionally compressed), with one of the content types      <code>application/octet-stream</code>, <code>application/tar+gzip</code>, <code>application/x-gzip</code>, <code>application/x-tar</code>, <code>application/gzip</code></li>     <li>separate files in a <code>multipart/form-data</code> request</li>   </ul>      The required <code>webscript.json</code> json file contains the function metadata,   and must have a <code>runtime</code> attribute that is one of the supported <em>runtime</em>s    (see <code>GET /registry/v2/runtimes?functionType=webscripts</code>).    For each <em>runtime</em> other files will be required or supported. "
            ),
        ] = None,
        files: Annotated[
            Optional[RequestFiles], Field(description="Multipart file upload")
        ] = None,
        query: Optional[Union[CreateQuery, QueryParamTypes]] = None,
        raw_response: Literal[False] = False,
        select_path: Literal[""],
        headers: Optional[HeaderTypes] = None,
        **kwargs,
    ) -> PostWebscriptJobSyncResponseV2: ...

    @overload
    async def create(
        self,
        *,
        content: Annotated[
            Optional[RequestContent],
            Field(
                description="The assets for a <em>webscript</em> function can be provided as either   <ul>     <li>a single <em>tar</em> archive (optionally compressed), with one of the content types      <code>application/octet-stream</code>, <code>application/tar+gzip</code>, <code>application/x-gzip</code>, <code>application/x-tar</code>, <code>application/gzip</code></li>     <li>separate files in a <code>multipart/form-data</code> request</li>   </ul>      The required <code>webscript.json</code> json file contains the function metadata,   and must have a <code>runtime</code> attribute that is one of the supported <em>runtime</em>s    (see <code>GET /registry/v2/runtimes?functionType=webscripts</code>).    For each <em>runtime</em> other files will be required or supported. "
            ),
        ] = None,
        files: Annotated[
            Optional[RequestFiles], Field(description="Multipart file upload")
        ] = None,
        query: Optional[Union[CreateQuery, QueryParamTypes]] = None,
        raw_response: Literal[True],
        select_path: Literal["_not_used_"] = "_not_used_",
        headers: Optional[HeaderTypes] = None,
        **kwargs,
    ) -> Response: ...

    # @validate_call
    async def create(
        self,
        *,
        content: Annotated[
            Optional[RequestContent],
            Field(
                description="The assets for a <em>webscript</em> function can be provided as either   <ul>     <li>a single <em>tar</em> archive (optionally compressed), with one of the content types      <code>application/octet-stream</code>, <code>application/tar+gzip</code>, <code>application/x-gzip</code>, <code>application/x-tar</code>, <code>application/gzip</code></li>     <li>separate files in a <code>multipart/form-data</code> request</li>   </ul>      The required <code>webscript.json</code> json file contains the function metadata,   and must have a <code>runtime</code> attribute that is one of the supported <em>runtime</em>s    (see <code>GET /registry/v2/runtimes?functionType=webscripts</code>).    For each <em>runtime</em> other files will be required or supported. "
            ),
        ] = None,
        files: Annotated[
            Optional[RequestFiles], Field(description="Multipart file upload")
        ] = None,
        query: Optional[Union[CreateQuery, QueryParamTypes]] = None,
        raw_response: StrictBool = False,
        select_path: str = "",
        headers: Optional[HeaderTypes] = None,
        **kwargs,
    ) -> Union[PostWebscriptJobSyncResponseV2, Response, Model]:
        """Create Webscript Version.

        Creates a new <em>webscript</em> function by uploading its assets.      The assets for a <em>webscript</em> function can be provided as either   <ul>     <li>a single <em>tar</em> archive (optionally compressed), with one of the content types      <code>application/octet-stream</code>, <code>application/tar+gzip</code>, <code>application/x-gzip</code>, <code>application/x-tar</code>, <code>application/gzip</code></li>     <li>separate files in a <code>multipart/form-data</code> request</li>   </ul>      The required <code>webscript.json</code> json file contains the function metadata,   and must have a <code>runtime</code> attribute that is one of the supported <em>runtime</em>s    (see <code>GET /registry/v2/runtimes?functionType=webscripts</code>).    For each <em>runtime</em> other files will be required or supported.
        :param content: The assets for a <em>webscript</em> function can be provided as either   <ul>     <li>a single <em>tar</em> archive (optionally compressed), with one of the content types      <code>application/octet-stream</code>, <code>application/tar+gzip</code>, <code>application/x-gzip</code>, <code>application/x-tar</code>, <code>application/gzip</code></li>     <li>separate files in a <code>multipart/form-data</code> request</li>   </ul>      The required <code>webscript.json</code> json file contains the function metadata,   and must have a <code>runtime</code> attribute that is one of the supported <em>runtime</em>s    (see <code>GET /registry/v2/runtimes?functionType=webscripts</code>).    For each <em>runtime</em> other files will be required or supported.
        :type content: ContentRequest, optional
        :param files: The files of a `content-type: multipart/form-data` request.
        :type files: FilesRequest, optional
        :param query: URL Query parameters.
        :type query: CreateQuery | QueryParamTypes, optional
        :param query['deprecatePrevious']: Set the cleanup policy used to automatically deprecate/delete previous versions.
        :type query['deprecatePrevious']: DeprecatePreviousPolicy
        :param query['dryRun']: If set to <code>true</code>, validates the deployment conditions, but does not change anything.
        :type query['dryRun']: bool
        :param query['async']: Unless this is set to <code>false</code>, the server will start the required job actions asynchronously and return a <code>202</code> <em>Accepted</em> response. If <code>false</code> the request will block until the job actions are completed, or a timeout occurs.
        :type query['async']: bool
        :param query['scaleToZero']: If set to <code>true</code>, after successful deployment, the deployed function will be scaled to zero. Saves computing resources when the function is not to be used immediately.
        :type query['scaleToZero']: bool
        :param query['version']: If set, the function version will be an increment of the latest existing version that satisfies the `version` range. Note that this increment always takes precedence over an explicit `version` in the function manifest.
        :type query['version']: SemanticVersionRange
        :param query['name']: If set, the value will be used as the function name instead of the one specified in the manifest.
        :type query['name']: str
        :param query['draft']: If set, the created function will be a draft function and its assets are still mutable. A build and deploy is initiated only in the case when all necessary assets are present and valid.
        :type query['draft']: bool
        :param raw_response: If true, return the http Response object instead of returning an api model object, or throwing an ApiError.
        :param select_path: Denotes the json path applied to the response object before returning it.
                Set it to the empty string `""` to receive the full response object.
        :param headers: Header parameters for this request
        :type headers: dict, optional
        :param `**kwargs`: Additional parameters passed on to the http client.
            See below.
        :Keyword Arguments:
            * timeout: a single numeric timeout in seconds,
                or a tuple of _connect_, _read_, _write_ and _pool_ timeouts.
            * stream: if true, the response will be in streaming mode
            * cookies
            * extensions
            * auth
            * follow_redirects: bool

        :return: Returns the result object if the http request succeeded with status code '2XX'.
        :raises APIError: If the http request has a status code different from `2XX`. This
            object wraps both the http Response and any parsed data.
        """

        # set aside send args
        send_args = {}
        for key in ["stream", "follow_redirects", "auth"]:
            if key in kwargs:
                send_args[key] = kwargs.pop(key)
        # path parameters
        path_params: Dict[str, str] = {}

        ## named body parameters
        body_args: Dict[str, Any] = {}
        body_args["content"] = content
        body_args["files"] = files

        ## create httpx.Request
        api_request = self.api_client.build_request(
            method="POST",
            resource_path="/registry/v2/webscripts/",
            path_params=path_params,
            params=query,
            **body_args,
            headers=headers,
            **kwargs,
        )

        ## initiate http request
        response = await self.api_client.send(api_request, **send_args)

        ## render response
        if raw_response:
            return response
        response_types_map: Dict[str, Optional[Union[str, Any]]] = {
            "201": PostWebscriptJobSyncResponseV2 if not select_path else Model,
            "202": PostWebscriptJobAsyncResponseV2 if not select_path else Model,
        }
        stream = send_args.get("stream", False)
        return self.api_client.response_deserialize(
            response, response_types_map, select_path, stream=stream
        )

    @overload
    async def delete_asset(
        self,
        name: Annotated[StrictStr, Field(description="The name of the function.")],
        version: Annotated[
            str, Field(strict=True, description="The version of the function.")
        ],
        wildcard: Annotated[
            StrictStr,
            Field(
                description="Full path or path prefix of the asset within the archive"
            ),
        ],
        *,
        query: Optional[Union[DeleteAssetQuery, QueryParamTypes]] = None,
        raw_response: Literal[False] = False,
        select_path: Literal[""],
        headers: Optional[HeaderTypes] = None,
        **kwargs,
    ) -> PostWebscriptJobSyncResponseV2: ...

    @overload
    async def delete_asset(
        self,
        name: Annotated[StrictStr, Field(description="The name of the function.")],
        version: Annotated[
            str, Field(strict=True, description="The version of the function.")
        ],
        wildcard: Annotated[
            StrictStr,
            Field(
                description="Full path or path prefix of the asset within the archive"
            ),
        ],
        *,
        query: Optional[Union[DeleteAssetQuery, QueryParamTypes]] = None,
        raw_response: Literal[True],
        select_path: Literal["_not_used_"] = "_not_used_",
        headers: Optional[HeaderTypes] = None,
        **kwargs,
    ) -> Response: ...

    # @validate_call
    async def delete_asset(
        self,
        name: Annotated[StrictStr, Field(description="The name of the function.")],
        version: Annotated[
            str, Field(strict=True, description="The version of the function.")
        ],
        wildcard: Annotated[
            StrictStr,
            Field(
                description="Full path or path prefix of the asset within the archive"
            ),
        ],
        *,
        query: Optional[Union[DeleteAssetQuery, QueryParamTypes]] = None,
        raw_response: StrictBool = False,
        select_path: str = "",
        headers: Optional[HeaderTypes] = None,
        **kwargs,
    ) -> Union[PostWebscriptJobSyncResponseV2, Response, Model]:
        """Delete Webscript Asset.

        Delete an asset from the webscript's collection of existing assets.
        :param name: The name of the function. (required)
        :type name: str
        :param version: The version of the function. (required)
        :type version: str
        :param wildcard: Full path or path prefix of the asset within the archive (required)
        :type wildcard: str
        :param query: URL Query parameters.
        :type query: DeleteAssetQuery | QueryParamTypes, optional
        :param query['comment']: An optional user-specified comment corresponding to the operation.
        :type query['comment']: str
        :param query['async']: Unless this is set to <code>false</code>, the server will start the required job actions asynchronously and return a <code>202</code> <em>Accepted</em> response. If <code>false</code> the request will block until the job actions are completed, or a timeout occurs.
        :type query['async']: bool
        :param query['chown']: If set, ownership of the draft function is transferred to the current user. (required)
        :type query['chown']: bool
        :param raw_response: If true, return the http Response object instead of returning an api model object, or throwing an ApiError.
        :param select_path: Denotes the json path applied to the response object before returning it.
                Set it to the empty string `""` to receive the full response object.
        :param headers: Header parameters for this request
        :type headers: dict, optional
        :param `**kwargs`: Additional parameters passed on to the http client.
            See below.
        :Keyword Arguments:
            * timeout: a single numeric timeout in seconds,
                or a tuple of _connect_, _read_, _write_ and _pool_ timeouts.
            * stream: if true, the response will be in streaming mode
            * cookies
            * extensions
            * auth
            * follow_redirects: bool

        :return: Returns the result object if the http request succeeded with status code '2XX'.
        :raises APIError: If the http request has a status code different from `2XX`. This
            object wraps both the http Response and any parsed data.
        """

        # set aside send args
        send_args = {}
        for key in ["stream", "follow_redirects", "auth"]:
            if key in kwargs:
                send_args[key] = kwargs.pop(key)
        # path parameters
        path_params: Dict[str, str] = {
            "name": StringAdapter.validate_python(name),
            "version": StringAdapter.validate_python(version),
            "wildcard": StringAdapter.validate_python(wildcard),
        }

        ## named body parameters
        body_args: Dict[str, Any] = {}

        ## create httpx.Request
        api_request = self.api_client.build_request(
            method="DELETE",
            resource_path="/registry/v2/webscripts/{name}/versions/{version}/content/{wildcard}",
            path_params=path_params,
            params=query,
            **body_args,
            headers=headers,
            **kwargs,
        )

        ## initiate http request
        response = await self.api_client.send(api_request, **send_args)

        ## render response
        if raw_response:
            return response
        response_types_map: Dict[str, Optional[Union[str, Any]]] = {
            "201": PostWebscriptJobSyncResponseV2 if not select_path else Model,
            "202": PostWebscriptJobAsyncResponseV2 if not select_path else Model,
        }
        stream = send_args.get("stream", False)
        return self.api_client.response_deserialize(
            response, response_types_map, select_path, stream=stream
        )

    @overload
    async def get_archive(
        self,
        name: Annotated[StrictStr, Field(description="The name of the function.")],
        version: Annotated[
            str, Field(strict=True, description="The version of the function.")
        ],
        *,
        query: Optional[Union[GetArchiveQuery, QueryParamTypes]] = None,
        raw_response: Literal[False] = False,
        select_path: Literal[""],
        headers: Optional[HeaderTypes] = None,
        **kwargs,
    ) -> bytearray: ...

    @overload
    async def get_archive(
        self,
        name: Annotated[StrictStr, Field(description="The name of the function.")],
        version: Annotated[
            str, Field(strict=True, description="The version of the function.")
        ],
        *,
        query: Optional[Union[GetArchiveQuery, QueryParamTypes]] = None,
        raw_response: Literal[True],
        select_path: Literal["_not_used_"] = "_not_used_",
        headers: Optional[HeaderTypes] = None,
        **kwargs,
    ) -> Response: ...

    # @validate_call
    async def get_archive(
        self,
        name: Annotated[StrictStr, Field(description="The name of the function.")],
        version: Annotated[
            str, Field(strict=True, description="The version of the function.")
        ],
        *,
        query: Optional[Union[GetArchiveQuery, QueryParamTypes]] = None,
        raw_response: StrictBool = False,
        select_path: str = "",
        headers: Optional[HeaderTypes] = None,
        **kwargs,
    ) -> Union[bytearray, Response, Model]:
        """Get Webscript Archive.

        Get the specification archive of a webscript.
        :param name: The name of the function. (required)
        :type name: str
        :param version: The version of the function. (required)
        :type version: str
        :param query: URL Query parameters.
        :type query: GetArchiveQuery | QueryParamTypes, optional
        :param query['ls']: If set to `true`, the result will be a listing of the files in the asset, annotated with metadata and validation report from the asset conditions of the functions runtime.
        :type query['ls']: bool
        :param raw_response: If true, return the http Response object instead of returning an api model object, or throwing an ApiError.
        :param select_path: Denotes the json path applied to the response object before returning it.
                Set it to the empty string `""` to receive the full response object.
        :param headers: Header parameters for this request
        :type headers: dict, optional
        :param `**kwargs`: Additional parameters passed on to the http client.
            See below.
        :Keyword Arguments:
            * timeout: a single numeric timeout in seconds,
                or a tuple of _connect_, _read_, _write_ and _pool_ timeouts.
            * stream: if true, the response will be in streaming mode
            * cookies
            * extensions
            * auth
            * follow_redirects: bool

        :return: Returns the result object if the http request succeeded with status code '2XX'.
        :raises APIError: If the http request has a status code different from `2XX`. This
            object wraps both the http Response and any parsed data.
        """

        # set aside send args
        send_args = {}
        for key in ["stream", "follow_redirects", "auth"]:
            if key in kwargs:
                send_args[key] = kwargs.pop(key)
        # path parameters
        path_params: Dict[str, str] = {
            "name": StringAdapter.validate_python(name),
            "version": StringAdapter.validate_python(version),
        }

        ## named body parameters
        body_args: Dict[str, Any] = {}

        ## create httpx.Request
        api_request = self.api_client.build_request(
            method="GET",
            resource_path="/registry/v2/webscripts/{name}/versions/{version}/content",
            path_params=path_params,
            params=query,
            **body_args,
            headers=headers,
            **kwargs,
        )

        ## initiate http request
        response = await self.api_client.send(api_request, **send_args)

        ## render response
        if raw_response:
            return response
        response_types_map: Dict[str, Optional[Union[str, Any]]] = {
            "200": bytearray if not select_path else Model,
        }
        stream = send_args.get("stream", False)
        return self.api_client.response_deserialize(
            response, response_types_map, select_path, stream=stream
        )

    @overload
    async def get_asset(
        self,
        name: Annotated[StrictStr, Field(description="The name of the function.")],
        version: Annotated[
            str, Field(strict=True, description="The version of the function.")
        ],
        wildcard: Annotated[
            StrictStr,
            Field(
                description="Full path or path prefix of the asset within the archive"
            ),
        ],
        *,
        query: Optional[Union[GetAssetQuery, QueryParamTypes]] = None,
        raw_response: Literal[False] = False,
        select_path: Literal[""],
        headers: Optional[HeaderTypes] = None,
        **kwargs,
    ) -> bytearray: ...

    @overload
    async def get_asset(
        self,
        name: Annotated[StrictStr, Field(description="The name of the function.")],
        version: Annotated[
            str, Field(strict=True, description="The version of the function.")
        ],
        wildcard: Annotated[
            StrictStr,
            Field(
                description="Full path or path prefix of the asset within the archive"
            ),
        ],
        *,
        query: Optional[Union[GetAssetQuery, QueryParamTypes]] = None,
        raw_response: Literal[True],
        select_path: Literal["_not_used_"] = "_not_used_",
        headers: Optional[HeaderTypes] = None,
        **kwargs,
    ) -> Response: ...

    # @validate_call
    async def get_asset(
        self,
        name: Annotated[StrictStr, Field(description="The name of the function.")],
        version: Annotated[
            str, Field(strict=True, description="The version of the function.")
        ],
        wildcard: Annotated[
            StrictStr,
            Field(
                description="Full path or path prefix of the asset within the archive"
            ),
        ],
        *,
        query: Optional[Union[GetAssetQuery, QueryParamTypes]] = None,
        raw_response: StrictBool = False,
        select_path: str = "",
        headers: Optional[HeaderTypes] = None,
        **kwargs,
    ) -> Union[bytearray, Response, Model]:
        """Get File From Webscript Archive.

        Get a file from the specification archive of a webscript.
        :param name: The name of the function. (required)
        :type name: str
        :param version: The version of the function. (required)
        :type version: str
        :param wildcard: Full path or path prefix of the asset within the archive (required)
        :type wildcard: str
        :param query: URL Query parameters.
        :type query: GetAssetQuery | QueryParamTypes, optional
        :param query['ls']: If set to `true`, the result will be a listing of the files in the asset, annotated with metadata and validation report from the asset conditions of the functions runtime.
        :type query['ls']: bool
        :param raw_response: If true, return the http Response object instead of returning an api model object, or throwing an ApiError.
        :param select_path: Denotes the json path applied to the response object before returning it.
                Set it to the empty string `""` to receive the full response object.
        :param headers: Header parameters for this request
        :type headers: dict, optional
        :param `**kwargs`: Additional parameters passed on to the http client.
            See below.
        :Keyword Arguments:
            * timeout: a single numeric timeout in seconds,
                or a tuple of _connect_, _read_, _write_ and _pool_ timeouts.
            * stream: if true, the response will be in streaming mode
            * cookies
            * extensions
            * auth
            * follow_redirects: bool

        :return: Returns the result object if the http request succeeded with status code '2XX'.
        :raises APIError: If the http request has a status code different from `2XX`. This
            object wraps both the http Response and any parsed data.
        """

        # set aside send args
        send_args = {}
        for key in ["stream", "follow_redirects", "auth"]:
            if key in kwargs:
                send_args[key] = kwargs.pop(key)
        # path parameters
        path_params: Dict[str, str] = {
            "name": StringAdapter.validate_python(name),
            "version": StringAdapter.validate_python(version),
            "wildcard": StringAdapter.validate_python(wildcard),
        }

        ## named body parameters
        body_args: Dict[str, Any] = {}

        ## create httpx.Request
        api_request = self.api_client.build_request(
            method="GET",
            resource_path="/registry/v2/webscripts/{name}/versions/{version}/content/{wildcard}",
            path_params=path_params,
            params=query,
            **body_args,
            headers=headers,
            **kwargs,
        )

        ## initiate http request
        response = await self.api_client.send(api_request, **send_args)

        ## render response
        if raw_response:
            return response
        response_types_map: Dict[str, Optional[Union[str, Any]]] = {
            "200": bytearray if not select_path else Model,
        }
        stream = send_args.get("stream", False)
        return self.api_client.response_deserialize(
            response, response_types_map, select_path, stream=stream
        )

    @overload
    async def get_latest(
        self,
        name: Annotated[StrictStr, Field(description="The name of the function.")],
        *,
        query: Optional[Union[GetLatestQuery, QueryParamTypes]] = None,
        raw_response: Literal[False] = False,
        select_path: Literal[""],
        headers: Optional[HeaderTypes] = None,
        **kwargs,
    ) -> GetWebscriptResponseV2: ...

    @overload
    async def get_latest(
        self,
        name: Annotated[StrictStr, Field(description="The name of the function.")],
        *,
        query: Optional[Union[GetLatestQuery, QueryParamTypes]] = None,
        raw_response: Literal[True],
        select_path: Literal["_not_used_"] = "_not_used_",
        headers: Optional[HeaderTypes] = None,
        **kwargs,
    ) -> Response: ...

    # @validate_call
    async def get_latest(
        self,
        name: Annotated[StrictStr, Field(description="The name of the function.")],
        *,
        query: Optional[Union[GetLatestQuery, QueryParamTypes]] = None,
        raw_response: StrictBool = False,
        select_path: str = "",
        headers: Optional[HeaderTypes] = None,
        **kwargs,
    ) -> Union[GetWebscriptResponseV2, Response, Model]:
        """Get Latest Webscript Version.

        Fetch the latest version of a <em>webscript</em>.    By default, the result shows the latest non-deprecated, non-draft version.   If there is no such version, the latest deprecated or the latest draft version is returned, with the former taking precedence.       Use the boolean query parameters <code>includeDeprecated</code> or <code>includeDraft</code> to change this behaviour:   <ul>   <li><code>includeDeprecated=true</code>: do not prefer non-deprecated versions as a latest version: if the latest version is a deprecated one, it will be shown, even if there are older non-deprecated versions.</li>   <li><code>includeDraft=true</code>: do not prefer non-draft versions as a latest version: if the latest version is a draft, it will be shown, even if there are older non-draft versions.</li>   </ul>     The returned <em>webscript version</em> will contain a link to its   latest _draft_ or latest _published_ version (if existing and different).
        :param name: The name of the function. (required)
        :type name: str
        :param query: URL Query parameters.
        :type query: GetLatestQuery | QueryParamTypes, optional
        :param query['includeDraft']: Configures the inclusion of _draft_ versions when selecting latest versions per name. By default, draft versions are only considered when no other versions are available. If set to `true`, draft versions are **included**. If set to `false`, draft versions are **excluded**.
        :type query['includeDraft']: bool
        :param query['includeDeprecated']: Configures the inclusion of _deprecated_ versions when selecting latest versions per name. By default, deprecated versions are only considered when no other versions are available. If set to `true`, deprecated versions are **included**. If set to `false`, deprecated versions are **excluded**.
        :type query['includeDeprecated']: bool
        :param raw_response: If true, return the http Response object instead of returning an api model object, or throwing an ApiError.
        :param select_path: Denotes the json path applied to the response object before returning it.
                Set it to the empty string `""` to receive the full response object.
        :param headers: Header parameters for this request
        :type headers: dict, optional
        :param `**kwargs`: Additional parameters passed on to the http client.
            See below.
        :Keyword Arguments:
            * timeout: a single numeric timeout in seconds,
                or a tuple of _connect_, _read_, _write_ and _pool_ timeouts.
            * stream: if true, the response will be in streaming mode
            * cookies
            * extensions
            * auth
            * follow_redirects: bool

        :return: Returns the result object if the http request succeeded with status code '2XX'.
        :raises APIError: If the http request has a status code different from `2XX`. This
            object wraps both the http Response and any parsed data.
        """

        # set aside send args
        send_args = {}
        for key in ["stream", "follow_redirects", "auth"]:
            if key in kwargs:
                send_args[key] = kwargs.pop(key)
        # path parameters
        path_params: Dict[str, str] = {
            "name": StringAdapter.validate_python(name),
        }

        ## named body parameters
        body_args: Dict[str, Any] = {}

        ## create httpx.Request
        api_request = self.api_client.build_request(
            method="GET",
            resource_path="/registry/v2/webscripts/{name}",
            path_params=path_params,
            params=query,
            **body_args,
            headers=headers,
            **kwargs,
        )

        ## initiate http request
        response = await self.api_client.send(api_request, **send_args)

        ## render response
        if raw_response:
            return response
        response_types_map: Dict[str, Optional[Union[str, Any]]] = {
            "200": GetWebscriptResponseV2 if not select_path else Model,
        }
        stream = send_args.get("stream", False)
        return self.api_client.response_deserialize(
            response, response_types_map, select_path, stream=stream
        )

    @overload
    async def get(
        self,
        name: Annotated[StrictStr, Field(description="The name of the function.")],
        version: Annotated[
            str, Field(strict=True, description="The version of the function.")
        ],
        *,
        query: Optional[Union[GetQuery, QueryParamTypes]] = None,
        raw_response: Literal[False] = False,
        select_path: Literal[""],
        headers: Optional[HeaderTypes] = None,
        **kwargs,
    ) -> GetWebscriptResponseV2: ...

    @overload
    async def get(
        self,
        name: Annotated[StrictStr, Field(description="The name of the function.")],
        version: Annotated[
            str, Field(strict=True, description="The version of the function.")
        ],
        *,
        query: Optional[Union[GetQuery, QueryParamTypes]] = None,
        raw_response: Literal[True],
        select_path: Literal["_not_used_"] = "_not_used_",
        headers: Optional[HeaderTypes] = None,
        **kwargs,
    ) -> Response: ...

    # @validate_call
    async def get(
        self,
        name: Annotated[StrictStr, Field(description="The name of the function.")],
        version: Annotated[
            str, Field(strict=True, description="The version of the function.")
        ],
        *,
        query: Optional[Union[GetQuery, QueryParamTypes]] = None,
        raw_response: StrictBool = False,
        select_path: str = "",
        headers: Optional[HeaderTypes] = None,
        **kwargs,
    ) -> Union[GetWebscriptResponseV2, Response, Model]:
        """Get Webscript Version.

        Get the webscript version.
        :param name: The name of the function. (required)
        :type name: str
        :param version: The version of the function. (required)
        :type version: str
        :param query: URL Query parameters.
        :type query: GetQuery | QueryParamTypes, optional
        :param raw_response: If true, return the http Response object instead of returning an api model object, or throwing an ApiError.
        :param select_path: Denotes the json path applied to the response object before returning it.
                Set it to the empty string `""` to receive the full response object.
        :param headers: Header parameters for this request
        :type headers: dict, optional
        :param `**kwargs`: Additional parameters passed on to the http client.
            See below.
        :Keyword Arguments:
            * timeout: a single numeric timeout in seconds,
                or a tuple of _connect_, _read_, _write_ and _pool_ timeouts.
            * stream: if true, the response will be in streaming mode
            * cookies
            * extensions
            * auth
            * follow_redirects: bool

        :return: Returns the result object if the http request succeeded with status code '2XX'.
        :raises APIError: If the http request has a status code different from `2XX`. This
            object wraps both the http Response and any parsed data.
        """

        # set aside send args
        send_args = {}
        for key in ["stream", "follow_redirects", "auth"]:
            if key in kwargs:
                send_args[key] = kwargs.pop(key)
        # path parameters
        path_params: Dict[str, str] = {
            "name": StringAdapter.validate_python(name),
            "version": StringAdapter.validate_python(version),
        }

        ## named body parameters
        body_args: Dict[str, Any] = {}

        ## create httpx.Request
        api_request = self.api_client.build_request(
            method="GET",
            resource_path="/registry/v2/webscripts/{name}/versions/{version}",
            path_params=path_params,
            params=query,
            **body_args,
            headers=headers,
            **kwargs,
        )

        ## initiate http request
        response = await self.api_client.send(api_request, **send_args)

        ## render response
        if raw_response:
            return response
        response_types_map: Dict[str, Optional[Union[str, Any]]] = {
            "200": GetWebscriptResponseV2 if not select_path else Model,
        }
        stream = send_args.get("stream", False)
        return self.api_client.response_deserialize(
            response, response_types_map, select_path, stream=stream
        )

    @overload
    async def jobs(
        self,
        name: Annotated[StrictStr, Field(description="The name of the function.")],
        version: Annotated[
            str, Field(strict=True, description="The version of the function.")
        ],
        *,
        query: Optional[Union[JobsQuery, QueryParamTypes]] = None,
        raw_response: Literal[False] = False,
        select_path: Literal[""],
        headers: Optional[HeaderTypes] = None,
        **kwargs,
    ) -> JobsForWebscriptResponseV2: ...

    @overload
    async def jobs(
        self,
        name: Annotated[StrictStr, Field(description="The name of the function.")],
        version: Annotated[
            str, Field(strict=True, description="The version of the function.")
        ],
        *,
        query: Optional[Union[JobsQuery, QueryParamTypes]] = None,
        raw_response: Literal[True],
        select_path: Literal["_not_used_"] = "_not_used_",
        headers: Optional[HeaderTypes] = None,
        **kwargs,
    ) -> Response: ...

    # @validate_call
    async def jobs(
        self,
        name: Annotated[StrictStr, Field(description="The name of the function.")],
        version: Annotated[
            str, Field(strict=True, description="The version of the function.")
        ],
        *,
        query: Optional[Union[JobsQuery, QueryParamTypes]] = None,
        raw_response: StrictBool = False,
        select_path: str = "",
        headers: Optional[HeaderTypes] = None,
        **kwargs,
    ) -> Union[JobsForWebscriptResponseV2, Response, Model]:
        """List Webscript Jobs.

        List the ongoing and completed operations on a specific webscript.
        :param name: The name of the function. (required)
        :type name: str
        :param version: The version of the function. (required)
        :type version: str
        :param query: URL Query parameters.
        :type query: JobsQuery | QueryParamTypes, optional
        :param query['limit']: The maximum number of items to be return from this query. Has a deployment-defined default and maximum value.
        :type query['limit']: float
        :param query['type']: Filter on job type
        :type query['type']: List[JobTypeSchema]
        :param query['state']: Filter on job state
        :type query['state']: List[JobStateResult]
        :param query['functionType']: Filter on function type
        :type query['functionType']: List[FunctionType]
        :param query['createdBefore']: Filter on jobs that created before the given timestamp or age
        :type query['createdBefore']: TimestampSpec
        :param query['createdAfter']: Filter on jobs that created after the given timestamp or age
        :type query['createdAfter']: TimestampSpec
        :param raw_response: If true, return the http Response object instead of returning an api model object, or throwing an ApiError.
        :param select_path: Denotes the json path applied to the response object before returning it.
                Set it to the empty string `""` to receive the full response object.
        :param headers: Header parameters for this request
        :type headers: dict, optional
        :param `**kwargs`: Additional parameters passed on to the http client.
            See below.
        :Keyword Arguments:
            * timeout: a single numeric timeout in seconds,
                or a tuple of _connect_, _read_, _write_ and _pool_ timeouts.
            * stream: if true, the response will be in streaming mode
            * cookies
            * extensions
            * auth
            * follow_redirects: bool

        :return: Returns the result object if the http request succeeded with status code '2XX'.
        :raises APIError: If the http request has a status code different from `2XX`. This
            object wraps both the http Response and any parsed data.
        """

        # set aside send args
        send_args = {}
        for key in ["stream", "follow_redirects", "auth"]:
            if key in kwargs:
                send_args[key] = kwargs.pop(key)
        # path parameters
        path_params: Dict[str, str] = {
            "name": StringAdapter.validate_python(name),
            "version": StringAdapter.validate_python(version),
        }

        ## named body parameters
        body_args: Dict[str, Any] = {}

        ## create httpx.Request
        api_request = self.api_client.build_request(
            method="GET",
            resource_path="/registry/v2/webscripts/{name}/versions/{version}/jobs",
            path_params=path_params,
            params=query,
            **body_args,
            headers=headers,
            **kwargs,
        )

        ## initiate http request
        response = await self.api_client.send(api_request, **send_args)

        ## render response
        if raw_response:
            return response
        response_types_map: Dict[str, Optional[Union[str, Any]]] = {
            "200": JobsForWebscriptResponseV2 if not select_path else Model,
        }
        stream = send_args.get("stream", False)
        return self.api_client.response_deserialize(
            response, response_types_map, select_path, stream=stream
        )

    @overload
    async def list_versions(
        self,
        name: Annotated[StrictStr, Field(description="The name of the function.")],
        *,
        query: Optional[Union[ListVersionsQuery, QueryParamTypes]] = None,
        raw_response: Literal[False] = False,
        select_path: Literal[""],
        headers: Optional[HeaderTypes] = None,
        **kwargs,
    ) -> WebscriptVersionsResponseV2: ...

    @overload
    async def list_versions(
        self,
        name: Annotated[StrictStr, Field(description="The name of the function.")],
        *,
        query: Optional[Union[ListVersionsQuery, QueryParamTypes]] = None,
        raw_response: Literal[True],
        select_path: Literal["_not_used_"] = "_not_used_",
        headers: Optional[HeaderTypes] = None,
        **kwargs,
    ) -> Response: ...

    # @validate_call
    async def list_versions(
        self,
        name: Annotated[StrictStr, Field(description="The name of the function.")],
        *,
        query: Optional[Union[ListVersionsQuery, QueryParamTypes]] = None,
        raw_response: StrictBool = False,
        select_path: str = "",
        headers: Optional[HeaderTypes] = None,
        **kwargs,
    ) -> Union[WebscriptVersionsResponseV2, Response, Model]:
        """List Webscript Versions.

        List all deployed versions of a webscript.
        :param name: The name of the function. (required)
        :type name: str
        :param query: URL Query parameters.
        :type query: ListVersionsQuery | QueryParamTypes, optional
        :param query['limit']: The maximum number of items to be return from this query. Has a deployment-defined default and maximum value.
        :type query['limit']: float
        :param query['page']: The number of pages to skip when returning result to this query.
        :type query['page']: float
        :param query['deprecated']: Filter on the deprecation status of the function.
        :type query['deprecated']: bool
        :param query['draft']: Filter on the draft status of the function.
        :type query['draft']: bool
        :param query['version']: Filter on the version of the function (case-sensitive, supports wildcards).
        :type query['version']: str
        :param query['status']: Filter on the status of the plug. Filter values with a `-` postfix exclude the status. Use the `any` filter value to include all states. When not specified, a default `undeployed-` filter excludes _undeployed_ functions.
        :type query['status']: List[StatusFilter]
        :param query['runtimeVersion']: Filter on the runtime version.
        :type query['runtimeVersion']: SemanticVersionRange
        :param query['createdBy']: Filter on the user that create the plug. You can use the `@me` token to indicate your own plugs.
        :type query['createdBy']: str
        :param query['updatedBy']: Filter on the user that last updated the plug. You can use the `@me` token to indicate your own plugs.
        :type query['updatedBy']: str
        :param query['createdBefore']: Filter on funtions that were created before the given timestamp or age.
        :type query['createdBefore']: TimestampSpec
        :param query['createdAfter']: Filter on funtions that were created after the given timestamp or age.
        :type query['createdAfter']: TimestampSpec
        :param query['updatedBefore']: Filter on funtions that were updated before the given timestamp or age.
        :type query['updatedBefore']: TimestampSpec
        :param query['updatedAfter']: Filter on funtions that were updated after the given timestamp or age.
        :type query['updatedAfter']: TimestampSpec
        :param query['archiveFormat']: Filter on the archive format of the function.
        :type query['archiveFormat']: List[ArchiveFormat]
        :param query['runtime']: Filter on the runtime of the function.
        :type query['runtime']: List[str]
        :param raw_response: If true, return the http Response object instead of returning an api model object, or throwing an ApiError.
        :param select_path: Denotes the json path applied to the response object before returning it.
                Set it to the empty string `""` to receive the full response object.
        :param headers: Header parameters for this request
        :type headers: dict, optional
        :param `**kwargs`: Additional parameters passed on to the http client.
            See below.
        :Keyword Arguments:
            * timeout: a single numeric timeout in seconds,
                or a tuple of _connect_, _read_, _write_ and _pool_ timeouts.
            * stream: if true, the response will be in streaming mode
            * cookies
            * extensions
            * auth
            * follow_redirects: bool

        :return: Returns the result object if the http request succeeded with status code '2XX'.
        :raises APIError: If the http request has a status code different from `2XX`. This
            object wraps both the http Response and any parsed data.
        """

        # set aside send args
        send_args = {}
        for key in ["stream", "follow_redirects", "auth"]:
            if key in kwargs:
                send_args[key] = kwargs.pop(key)
        # path parameters
        path_params: Dict[str, str] = {
            "name": StringAdapter.validate_python(name),
        }

        ## named body parameters
        body_args: Dict[str, Any] = {}

        ## create httpx.Request
        api_request = self.api_client.build_request(
            method="GET",
            resource_path="/registry/v2/webscripts/{name}/versions",
            path_params=path_params,
            params=query,
            **body_args,
            headers=headers,
            **kwargs,
        )

        ## initiate http request
        response = await self.api_client.send(api_request, **send_args)

        ## render response
        if raw_response:
            return response
        response_types_map: Dict[str, Optional[Union[str, Any]]] = {
            "200": WebscriptVersionsResponseV2 if not select_path else Model,
        }
        stream = send_args.get("stream", False)
        return self.api_client.response_deserialize(
            response, response_types_map, select_path, stream=stream
        )

    @overload
    async def list(
        self,
        *,
        query: Optional[Union[ListQuery, QueryParamTypes]] = None,
        raw_response: Literal[False] = False,
        select_path: Literal[""],
        headers: Optional[HeaderTypes] = None,
        **kwargs,
    ) -> LatestWebscriptsResponseV2: ...

    @overload
    async def list(
        self,
        *,
        query: Optional[Union[ListQuery, QueryParamTypes]] = None,
        raw_response: Literal[True],
        select_path: Literal["_not_used_"] = "_not_used_",
        headers: Optional[HeaderTypes] = None,
        **kwargs,
    ) -> Response: ...

    # @validate_call
    async def list(
        self,
        *,
        query: Optional[Union[ListQuery, QueryParamTypes]] = None,
        raw_response: StrictBool = False,
        select_path: str = "",
        headers: Optional[HeaderTypes] = None,
        **kwargs,
    ) -> Union[LatestWebscriptsResponseV2, Response, Model]:
        """List Webscripts.

        List the (latest) versions of available <em>webscripts</em>.  ### List Latest Webscript Versions By default, the result includes the latest non-deprecated, non-draft version for each <em>webscript</em> name. If there is no such version, the latest _deprecated_ or the latest _draft_ version is included, with the former taking precedence.     Use the boolean query parameters <code>includeDeprecated</code> or <code>includeDraft</code> to change this behaviour:   <ul>   <li><code>includeDeprecated=true</code>: do not prefer non-deprecated versions as a latest version: if the latest version is a deprecated one, it will be shown, even if there are older non-deprecated versions.</li>   <li><code>includeDraft=true</code>: do not prefer non-draft versions as a latest version: if the latest version is a draft, it will be shown, even if there are older non-draft versions.</li>   </ul>   As long as no _version filters_ are used, each listed <em>webscript version</em> item will contain a HAL **link to the  latest** _draft_ (`entities[]._links.draft`) or latest _published_ (`entities[]._links.publisned`) version (if existing and different).  ### List Latest Webscript Versions (with filter) When any of the _version filter_ query parameters are used, the response contains the _latest_ version per named <em>webscript</em> that satisfy the filters, but **without links**.  ### List All Webscript Versions When using `latest=false` (default when using the `namedVersion` filter), the listing contains _all_  <em>webscripts</em> versions that satisfy the query, possibly multiple versions per named <em>webscripts</em>. No HAL links are provided.  #### Filter on _status_ By default <em>webscript versions</em> with status  `undeployed` are **excluded** in all cases. Use the _version filter_ `status` to include/exclude a status from the results. By example,  > `?status=any&includeDeprecated=true&includeDraft=true&latest=false`  will list _ALL_ versions known to the function registry.  #### Version filter parameters The following query parameters are _version filters_ for the <em>webscript</em> listing: > `version`, `status`, `runtimeVersion`, `createdBy`, `createdBefore`, `createdAfter`, `updatedBy`, `updatedBefore`, `updatedAfter`, `nameVersion`, `deprecated`, `draft`
        :param query: URL Query parameters.
        :type query: ListQuery | QueryParamTypes, optional
        :param query['limit']: The maximum number of items to be return from this query. Has a deployment-defined default and maximum value.
        :type query['limit']: float
        :param query['page']: The number of pages to skip when returning result to this query.
        :type query['page']: float
        :param query['includeDraft']: Configures the inclusion of _draft_ versions when selecting latest versions per name. By default, draft versions are only considered when no other versions are available. If set to `true`, draft versions are **included**. If set to `false`, draft versions are **excluded**.
        :type query['includeDraft']: bool
        :param query['includeDeprecated']: Configures the inclusion of _deprecated_ versions when selecting latest versions per name. By default, deprecated versions are only considered when no other versions are available. If set to `true`, deprecated versions are **included**. If set to `false`, deprecated versions are **excluded**.
        :type query['includeDeprecated']: bool
        :param query['deprecated']: Filter on the deprecation status of the function.
        :type query['deprecated']: bool
        :param query['draft']: Filter on the draft status of the function.
        :type query['draft']: bool
        :param query['nameVersion']: Filter on exact `{name}@{version}` functions. Using this filter implies a `latest=false` default, returning multiple versions of the same named versions if they are filtered.
        :type query['nameVersion']: List[str]
        :param query['version']: Filter on the version of the function (case-sensitive, supports wildcards).
        :type query['version']: str
        :param query['status']: Filter on the status of the plug. Filter values with a `-` postfix exclude the status. Use the `any` filter value to include all states. When not specified, a default `undeployed-` filter excludes _undeployed_ functions.
        :type query['status']: List[StatusFilter]
        :param query['runtimeVersion']: Filter on the runtime version.
        :type query['runtimeVersion']: SemanticVersionRange
        :param query['createdBy']: Filter on the user that create the plug. You can use the `@me` token to indicate your own plugs.
        :type query['createdBy']: str
        :param query['updatedBy']: Filter on the user that last updated the plug. You can use the `@me` token to indicate your own plugs.
        :type query['updatedBy']: str
        :param query['createdBefore']: Filter on funtions that were created before the given timestamp or age.
        :type query['createdBefore']: TimestampSpec
        :param query['createdAfter']: Filter on funtions that were created after the given timestamp or age.
        :type query['createdAfter']: TimestampSpec
        :param query['updatedBefore']: Filter on funtions that were updated before the given timestamp or age.
        :type query['updatedBefore']: TimestampSpec
        :param query['updatedAfter']: Filter on funtions that were updated after the given timestamp or age.
        :type query['updatedAfter']: TimestampSpec
        :param query['name']: Filter on the name of the function. This is case-insensitive and supports wild-cards `?` (any one character) and `*` (any sequence of characters).
        :type query['name']: str
        :param query['archiveFormat']: Filter on the archive format of the function.
        :type query['archiveFormat']: List[ArchiveFormat]
        :param query['runtime']: Filter on the runtime of the function.
        :type query['runtime']: List[str]
        :param query['latest']: When `true`, only the latest version per function name is returned. If set to `false`, multiple versions per named function can be returned. Defaults to `true`, except when specific versions are selected with the `nameVersion` filter.
        :type query['latest']: bool
        :param raw_response: If true, return the http Response object instead of returning an api model object, or throwing an ApiError.
        :param select_path: Denotes the json path applied to the response object before returning it.
                Set it to the empty string `""` to receive the full response object.
        :param headers: Header parameters for this request
        :type headers: dict, optional
        :param `**kwargs`: Additional parameters passed on to the http client.
            See below.
        :Keyword Arguments:
            * timeout: a single numeric timeout in seconds,
                or a tuple of _connect_, _read_, _write_ and _pool_ timeouts.
            * stream: if true, the response will be in streaming mode
            * cookies
            * extensions
            * auth
            * follow_redirects: bool

        :return: Returns the result object if the http request succeeded with status code '2XX'.
        :raises APIError: If the http request has a status code different from `2XX`. This
            object wraps both the http Response and any parsed data.
        """

        # set aside send args
        send_args = {}
        for key in ["stream", "follow_redirects", "auth"]:
            if key in kwargs:
                send_args[key] = kwargs.pop(key)
        # path parameters
        path_params: Dict[str, str] = {}

        ## named body parameters
        body_args: Dict[str, Any] = {}

        ## create httpx.Request
        api_request = self.api_client.build_request(
            method="GET",
            resource_path="/registry/v2/webscripts/",
            path_params=path_params,
            params=query,
            **body_args,
            headers=headers,
            **kwargs,
        )

        ## initiate http request
        response = await self.api_client.send(api_request, **send_args)

        ## render response
        if raw_response:
            return response
        response_types_map: Dict[str, Optional[Union[str, Any]]] = {
            "200": LatestWebscriptsResponseV2 if not select_path else Model,
        }
        stream = send_args.get("stream", False)
        return self.api_client.response_deserialize(
            response, response_types_map, select_path, stream=stream
        )

    @overload
    async def patch_metadata(
        self,
        name: Annotated[StrictStr, Field(description="The name of the function.")],
        version: Annotated[
            str, Field(strict=True, description="The version of the function.")
        ],
        *,
        json: Optional[FunctionMeta] = None,
        query: Optional[Union[PatchMetadataQuery, QueryParamTypes]] = None,
        raw_response: Literal[False] = False,
        select_path: Literal[""],
        headers: Optional[HeaderTypes] = None,
        **kwargs,
    ) -> GetWebscriptResponseV2: ...

    @overload
    async def patch_metadata(
        self,
        name: Annotated[StrictStr, Field(description="The name of the function.")],
        version: Annotated[
            str, Field(strict=True, description="The version of the function.")
        ],
        *,
        json: Optional[FunctionMeta] = None,
        query: Optional[Union[PatchMetadataQuery, QueryParamTypes]] = None,
        raw_response: Literal[True],
        select_path: Literal["_not_used_"] = "_not_used_",
        headers: Optional[HeaderTypes] = None,
        **kwargs,
    ) -> Response: ...

    # @validate_call
    async def patch_metadata(
        self,
        name: Annotated[StrictStr, Field(description="The name of the function.")],
        version: Annotated[
            str, Field(strict=True, description="The version of the function.")
        ],
        *,
        json: Optional[FunctionMeta] = None,
        query: Optional[Union[PatchMetadataQuery, QueryParamTypes]] = None,
        raw_response: StrictBool = False,
        select_path: str = "",
        headers: Optional[HeaderTypes] = None,
        **kwargs,
    ) -> Union[GetWebscriptResponseV2, Response, Model]:
        """Patch Webscript Metadata.

        Patch the metadata of a webscript version.
        :param name: The name of the function. (required)
        :type name: str
        :param version: The version of the function. (required)
        :type version: str
        :param json: The json request body.
        :type json: FunctionMeta, optional
        :param query: URL Query parameters.
        :type query: PatchMetadataQuery | QueryParamTypes, optional
        :param query['comment']: An optional user-specified comment corresponding to the operation.
        :type query['comment']: str
        :param raw_response: If true, return the http Response object instead of returning an api model object, or throwing an ApiError.
        :param select_path: Denotes the json path applied to the response object before returning it.
                Set it to the empty string `""` to receive the full response object.
        :param headers: Header parameters for this request
        :type headers: dict, optional
        :param `**kwargs`: Additional parameters passed on to the http client.
            See below.
        :Keyword Arguments:
            * timeout: a single numeric timeout in seconds,
                or a tuple of _connect_, _read_, _write_ and _pool_ timeouts.
            * stream: if true, the response will be in streaming mode
            * cookies
            * extensions
            * auth
            * follow_redirects: bool

        :return: Returns the result object if the http request succeeded with status code '2XX'.
        :raises APIError: If the http request has a status code different from `2XX`. This
            object wraps both the http Response and any parsed data.
        """

        # set aside send args
        send_args = {}
        for key in ["stream", "follow_redirects", "auth"]:
            if key in kwargs:
                send_args[key] = kwargs.pop(key)
        # path parameters
        path_params: Dict[str, str] = {
            "name": StringAdapter.validate_python(name),
            "version": StringAdapter.validate_python(version),
        }

        ## named body parameters
        body_args: Dict[str, Any] = {}
        body_args["json"] = json

        ## create httpx.Request
        api_request = self.api_client.build_request(
            method="PATCH",
            resource_path="/registry/v2/webscripts/{name}/versions/{version}/metadata",
            path_params=path_params,
            params=query,
            **body_args,
            headers=headers,
            **kwargs,
        )

        ## initiate http request
        response = await self.api_client.send(api_request, **send_args)

        ## render response
        if raw_response:
            return response
        response_types_map: Dict[str, Optional[Union[str, Any]]] = {
            "200": GetWebscriptResponseV2 if not select_path else Model,
        }
        stream = send_args.get("stream", False)
        return self.api_client.response_deserialize(
            response, response_types_map, select_path, stream=stream
        )

    @overload
    async def publish(
        self,
        name: Annotated[StrictStr, Field(description="The name of the function.")],
        version: Annotated[
            str, Field(strict=True, description="The version of the function.")
        ],
        *,
        query: Optional[Union[PublishQuery, QueryParamTypes]] = None,
        raw_response: Literal[False] = False,
        select_path: Literal[""],
        headers: Optional[HeaderTypes] = None,
        **kwargs,
    ) -> PostWebscriptJobSyncResponseV2: ...

    @overload
    async def publish(
        self,
        name: Annotated[StrictStr, Field(description="The name of the function.")],
        version: Annotated[
            str, Field(strict=True, description="The version of the function.")
        ],
        *,
        query: Optional[Union[PublishQuery, QueryParamTypes]] = None,
        raw_response: Literal[True],
        select_path: Literal["_not_used_"] = "_not_used_",
        headers: Optional[HeaderTypes] = None,
        **kwargs,
    ) -> Response: ...

    # @validate_call
    async def publish(
        self,
        name: Annotated[StrictStr, Field(description="The name of the function.")],
        version: Annotated[
            str, Field(strict=True, description="The version of the function.")
        ],
        *,
        query: Optional[Union[PublishQuery, QueryParamTypes]] = None,
        raw_response: StrictBool = False,
        select_path: str = "",
        headers: Optional[HeaderTypes] = None,
        **kwargs,
    ) -> Union[PostWebscriptJobSyncResponseV2, Response, Model]:
        """Publish Draft Webscript.

        Mark the <em>webscript</em> to be ready and stable, taking it out of draft mode.,    Typically, the <em>webscript</em> should be in the <code>running</code> status,    such that publishing becomes a simple operation where the existing deployment can be re-used.   In other statuses, plug-registry may need to initiate a new build and deployment procedure.
        :param name: The name of the function. (required)
        :type name: str
        :param version: The version of the function. (required)
        :type version: str
        :param query: URL Query parameters.
        :type query: PublishQuery | QueryParamTypes, optional
        :param query['comment']: An optional user-specified comment corresponding to the operation.
        :type query['comment']: str
        :param query['deprecatePrevious']: Set the cleanup policy used to automatically deprecate/delete previous versions.
        :type query['deprecatePrevious']: DeprecatePreviousPolicy
        :param query['async']: Unless this is set to <code>false</code>, the server will start the required job actions asynchronously and return a <code>202</code> <em>Accepted</em> response. If <code>false</code> the request will block until the job actions are completed, or a timeout occurs.
        :type query['async']: bool
        :param raw_response: If true, return the http Response object instead of returning an api model object, or throwing an ApiError.
        :param select_path: Denotes the json path applied to the response object before returning it.
                Set it to the empty string `""` to receive the full response object.
        :param headers: Header parameters for this request
        :type headers: dict, optional
        :param `**kwargs`: Additional parameters passed on to the http client.
            See below.
        :Keyword Arguments:
            * timeout: a single numeric timeout in seconds,
                or a tuple of _connect_, _read_, _write_ and _pool_ timeouts.
            * stream: if true, the response will be in streaming mode
            * cookies
            * extensions
            * auth
            * follow_redirects: bool

        :return: Returns the result object if the http request succeeded with status code '2XX'.
        :raises APIError: If the http request has a status code different from `2XX`. This
            object wraps both the http Response and any parsed data.
        """

        # set aside send args
        send_args = {}
        for key in ["stream", "follow_redirects", "auth"]:
            if key in kwargs:
                send_args[key] = kwargs.pop(key)
        # path parameters
        path_params: Dict[str, str] = {
            "name": StringAdapter.validate_python(name),
            "version": StringAdapter.validate_python(version),
        }

        ## named body parameters
        body_args: Dict[str, Any] = {}

        ## create httpx.Request
        api_request = self.api_client.build_request(
            method="POST",
            resource_path="/registry/v2/webscripts/{name}/versions/{version}/publish",
            path_params=path_params,
            params=query,
            **body_args,
            headers=headers,
            **kwargs,
        )

        ## initiate http request
        response = await self.api_client.send(api_request, **send_args)

        ## render response
        if raw_response:
            return response
        response_types_map: Dict[str, Optional[Union[str, Any]]] = {
            "201": PostWebscriptJobSyncResponseV2 if not select_path else Model,
            "202": PostWebscriptJobAsyncResponseV2 if not select_path else Model,
        }
        stream = send_args.get("stream", False)
        return self.api_client.response_deserialize(
            response, response_types_map, select_path, stream=stream
        )

    @overload
    async def rebuild(
        self,
        name: Annotated[StrictStr, Field(description="The name of the function.")],
        version: Annotated[
            str, Field(strict=True, description="The version of the function.")
        ],
        *,
        query: Optional[Union[RebuildQuery, QueryParamTypes]] = None,
        raw_response: Literal[False] = False,
        select_path: Literal[""],
        headers: Optional[HeaderTypes] = None,
        **kwargs,
    ) -> RebuildWebscriptSyncResponseV2: ...

    @overload
    async def rebuild(
        self,
        name: Annotated[StrictStr, Field(description="The name of the function.")],
        version: Annotated[
            str, Field(strict=True, description="The version of the function.")
        ],
        *,
        query: Optional[Union[RebuildQuery, QueryParamTypes]] = None,
        raw_response: Literal[True],
        select_path: Literal["_not_used_"] = "_not_used_",
        headers: Optional[HeaderTypes] = None,
        **kwargs,
    ) -> Response: ...

    # @validate_call
    async def rebuild(
        self,
        name: Annotated[StrictStr, Field(description="The name of the function.")],
        version: Annotated[
            str, Field(strict=True, description="The version of the function.")
        ],
        *,
        query: Optional[Union[RebuildQuery, QueryParamTypes]] = None,
        raw_response: StrictBool = False,
        select_path: str = "",
        headers: Optional[HeaderTypes] = None,
        **kwargs,
    ) -> Union[RebuildWebscriptSyncResponseV2, Response, Model]:
        """Rebuild Webscript.

        Rebuild and deploy a webscript with the original or updated base image.
        :param name: The name of the function. (required)
        :type name: str
        :param version: The version of the function. (required)
        :type version: str
        :param query: URL Query parameters.
        :type query: RebuildQuery | QueryParamTypes, optional
        :param query['comment']: An optional user-specified comment corresponding to the operation.
        :type query['comment']: str
        :param query['dryRun']: If set to <code>true</code>, checks whether rebuild jobs are needed, but do not start any jobs.
        :type query['dryRun']: bool
        :param query['async']: Unless this is set to <code>false</code>, the server will start the required job actions asynchronously and return a <code>202</code> <em>Accepted</em> response. If <code>false</code> the request will block until the job actions are completed, or a timeout occurs.
        :type query['async']: bool
        :param query['upgrade']: If set, force a rebuild with the given <em>runtime</em> version selection policy. <ul>  <li><code>same</code> <b>patch</b> version.   This should only include backward compatible upgrades.  </li>  <li><code>minor</code> <b>major</b> version.   This might include an upgrade of e.g. the language runtime and/or provided   dependencies that could break compatiblity with the function. .</li> </ul>
        :type query['upgrade']: RebuildPolicy
        :param query['forceVersion']: If set, force a rebuild with the given runtime version (including downgrades). This parameter is mutually exclusive to the `upgrade` parameter.
        :type query['forceVersion']: str
        :param query['ignoreChecks']: If set to true, checks that normally prevent a rebuild are overriden. These checks include: * function state in `pending`, `running`, `failed` or `undeployed` * backoff period due to recent failures * usage of deprecated dependencies * running jobs on entity * the `dryRun` option
        :type query['ignoreChecks']: bool
        :param query['scaleToZero']: Indicates whether the function needs to be scaled down after successful (re-)deployment. If not set, the function is scaled to zero only if it was not active before this command.
        :type query['scaleToZero']: bool
        :param query['skipRebuild']: If set, the function will not be rebuild. Always uses the current runtime version when re-deploying/re-verifying the function.
        :type query['skipRebuild']: bool
        :param raw_response: If true, return the http Response object instead of returning an api model object, or throwing an ApiError.
        :param select_path: Denotes the json path applied to the response object before returning it.
                Set it to the empty string `""` to receive the full response object.
        :param headers: Header parameters for this request
        :type headers: dict, optional
        :param `**kwargs`: Additional parameters passed on to the http client.
            See below.
        :Keyword Arguments:
            * timeout: a single numeric timeout in seconds,
                or a tuple of _connect_, _read_, _write_ and _pool_ timeouts.
            * stream: if true, the response will be in streaming mode
            * cookies
            * extensions
            * auth
            * follow_redirects: bool

        :return: Returns the result object if the http request succeeded with status code '2XX'.
        :raises APIError: If the http request has a status code different from `2XX`. This
            object wraps both the http Response and any parsed data.
        """

        # set aside send args
        send_args = {}
        for key in ["stream", "follow_redirects", "auth"]:
            if key in kwargs:
                send_args[key] = kwargs.pop(key)
        # path parameters
        path_params: Dict[str, str] = {
            "name": StringAdapter.validate_python(name),
            "version": StringAdapter.validate_python(version),
        }

        ## named body parameters
        body_args: Dict[str, Any] = {}

        ## create httpx.Request
        api_request = self.api_client.build_request(
            method="POST",
            resource_path="/registry/v2/webscripts/{name}/versions/{version}/rebuild",
            path_params=path_params,
            params=query,
            **body_args,
            headers=headers,
            **kwargs,
        )

        ## initiate http request
        response = await self.api_client.send(api_request, **send_args)

        ## render response
        if raw_response:
            return response
        response_types_map: Dict[str, Optional[Union[str, Any]]] = {
            "200": RebuildWebscriptSyncResponseV2 if not select_path else Model,
            "202": RebuildWebscriptAsyncResponseV2 if not select_path else Model,
        }
        stream = send_args.get("stream", False)
        return self.api_client.response_deserialize(
            response, response_types_map, select_path, stream=stream
        )

    @overload
    async def remove_version(
        self,
        name: Annotated[StrictStr, Field(description="The name of the function.")],
        version: Annotated[
            str, Field(strict=True, description="The version of the function.")
        ],
        *,
        query: Optional[Union[RemoveVersionQuery, QueryParamTypes]] = None,
        raw_response: Literal[False] = False,
        select_path: Literal[""],
        headers: Optional[HeaderTypes] = None,
        **kwargs,
    ) -> UndeployedResponseV2: ...

    @overload
    async def remove_version(
        self,
        name: Annotated[StrictStr, Field(description="The name of the function.")],
        version: Annotated[
            str, Field(strict=True, description="The version of the function.")
        ],
        *,
        query: Optional[Union[RemoveVersionQuery, QueryParamTypes]] = None,
        raw_response: Literal[True],
        select_path: Literal["_not_used_"] = "_not_used_",
        headers: Optional[HeaderTypes] = None,
        **kwargs,
    ) -> Response: ...

    # @validate_call
    async def remove_version(
        self,
        name: Annotated[StrictStr, Field(description="The name of the function.")],
        version: Annotated[
            str, Field(strict=True, description="The version of the function.")
        ],
        *,
        query: Optional[Union[RemoveVersionQuery, QueryParamTypes]] = None,
        raw_response: StrictBool = False,
        select_path: str = "",
        headers: Optional[HeaderTypes] = None,
        **kwargs,
    ) -> Union[UndeployedResponseV2, Response, Model]:
        """Remove Webscript Version.

        Deprecate, undeploy and/or remove a <em>webscript</em> version.    By default, a `DELETE`    * _deprecates_ the webscript version(s): they are no longer included in listings by default.   * _undeploys_ the webscript version(s) with delay: the function can no longer be invoked, the small delay allows     other services to discover the removal.   * _removes_ the version(s) from the plug registry.    Use `?force=true` to immediately _undeploy_ and _remove_ without delay.    Use `?undeploy=true` to undeploy, but keep the webscript version registered in a `undeployed` state.   An `undeployed` version can later be restored by a _rebuild_ action.
        :param name: The name of the function. (required)
        :type name: str
        :param version: The version of the function. (required)
        :type version: str
        :param query: URL Query parameters.
        :type query: RemoveVersionQuery | QueryParamTypes, optional
        :param query['comment']: An optional user-specified comment corresponding to the operation.
        :type query['comment']: str
        :param query['async']: Unless this is set to <code>false</code>, the server will start the required job actions asynchronously and return a <code>202</code> <em>Accepted</em> response. If <code>false</code> the request will block until the job actions are completed, or a timeout occurs.
        :type query['async']: bool
        :param query['force']: If <code>true</code>, the function version will be immediately undeployed and removed.  Otherwise, the removal will be delayed to allow current invocations to end. During that period, the function is marked _deprecated_.
        :type query['force']: bool
        :param query['undeploy']: If `true`, the `DELETE` operation * undeploys the (openfaas) function: it becomes no longer available for invocation. * does NOT remove the function from registry: it stays in an `undeployed` status.  All assets and definitions are retained, so the version can be restored later with a  _rebuild_ action.  If `false`, the `DELETE` operation * _only_ marks the plug function as _deprecated_, the function remains active but is removed from the default listings.   This also applies to _draft_ versions.  This parameter is incompatible with `force=true`.  If not set the default behaviour applies: * _draft_ versions are _undeployed_ and _removed_ from registry. * non-_draft_ versions are marked _deprecated_ only.
        :type query['undeploy']: bool
        :param raw_response: If true, return the http Response object instead of returning an api model object, or throwing an ApiError.
        :param select_path: Denotes the json path applied to the response object before returning it.
                Set it to the empty string `""` to receive the full response object.
        :param headers: Header parameters for this request
        :type headers: dict, optional
        :param `**kwargs`: Additional parameters passed on to the http client.
            See below.
        :Keyword Arguments:
            * timeout: a single numeric timeout in seconds,
                or a tuple of _connect_, _read_, _write_ and _pool_ timeouts.
            * stream: if true, the response will be in streaming mode
            * cookies
            * extensions
            * auth
            * follow_redirects: bool

        :return: Returns the result object if the http request succeeded with status code '2XX'.
        :raises APIError: If the http request has a status code different from `2XX`. This
            object wraps both the http Response and any parsed data.
        """

        # set aside send args
        send_args = {}
        for key in ["stream", "follow_redirects", "auth"]:
            if key in kwargs:
                send_args[key] = kwargs.pop(key)
        # path parameters
        path_params: Dict[str, str] = {
            "name": StringAdapter.validate_python(name),
            "version": StringAdapter.validate_python(version),
        }

        ## named body parameters
        body_args: Dict[str, Any] = {}

        ## create httpx.Request
        api_request = self.api_client.build_request(
            method="DELETE",
            resource_path="/registry/v2/webscripts/{name}/versions/{version}",
            path_params=path_params,
            params=query,
            **body_args,
            headers=headers,
            **kwargs,
        )

        ## initiate http request
        response = await self.api_client.send(api_request, **send_args)

        ## render response
        if raw_response:
            return response
        response_types_map: Dict[str, Optional[Union[str, Any]]] = {
            "200": UndeployedResponseV2 if not select_path else Model,
            "202": UndeploySubmittedResponseV2 if not select_path else Model,
        }
        stream = send_args.get("stream", False)
        return self.api_client.response_deserialize(
            response, response_types_map, select_path, stream=stream
        )

    @overload
    async def remove_versions(
        self,
        name: Annotated[StrictStr, Field(description="The name of the function.")],
        *,
        query: Optional[Union[RemoveVersionsQuery, QueryParamTypes]] = None,
        raw_response: Literal[False] = False,
        select_path: Literal[""],
        headers: Optional[HeaderTypes] = None,
        **kwargs,
    ) -> UndeployedResponseV2: ...

    @overload
    async def remove_versions(
        self,
        name: Annotated[StrictStr, Field(description="The name of the function.")],
        *,
        query: Optional[Union[RemoveVersionsQuery, QueryParamTypes]] = None,
        raw_response: Literal[True],
        select_path: Literal["_not_used_"] = "_not_used_",
        headers: Optional[HeaderTypes] = None,
        **kwargs,
    ) -> Response: ...

    # @validate_call
    async def remove_versions(
        self,
        name: Annotated[StrictStr, Field(description="The name of the function.")],
        *,
        query: Optional[Union[RemoveVersionsQuery, QueryParamTypes]] = None,
        raw_response: StrictBool = False,
        select_path: str = "",
        headers: Optional[HeaderTypes] = None,
        **kwargs,
    ) -> Union[UndeployedResponseV2, Response, Model]:
        """Remove Webscript.

        Deprecate, undeploy and/or remove all versions of this named <em>webscript</em>.    By default, a `DELETE`    * _deprecates_ the webscript version(s): they are no longer included in listings by default.   * _undeploys_ the webscript version(s) with delay: the function can no longer be invoked, the small delay allows     other services to discover the removal.   * _removes_ the version(s) from the plug registry.    Use `?force=true` to immediately _undeploy_ and _remove_ without delay.    Use `?undeploy=true` to undeploy, but keep the webscript version registered in a `undeployed` state.   An `undeployed` version can later be restored by a _rebuild_ action.
        :param name: The name of the function. (required)
        :type name: str
        :param query: URL Query parameters.
        :type query: RemoveVersionsQuery | QueryParamTypes, optional
        :param query['comment']: An optional user-specified comment corresponding to the operation.
        :type query['comment']: str
        :param query['async']: Unless this is set to <code>false</code>, the server will start the required job actions asynchronously and return a <code>202</code> <em>Accepted</em> response. If <code>false</code> the request will block until the job actions are completed, or a timeout occurs.
        :type query['async']: bool
        :param query['force']: If <code>true</code>, the function version will be immediately undeployed and removed.  Otherwise, the removal will be delayed to allow current invocations to end. During that period, the function is marked _deprecated_.
        :type query['force']: bool
        :param query['undeploy']: If `true`, the `DELETE` operation * undeploys the (openfaas) function: it becomes no longer available for invocation. * does NOT remove the function from registry: it stays in an `undeployed` status.  All assets and definitions are retained, so the version can be restored later with a  _rebuild_ action.  If `false`, the `DELETE` operation * _only_ marks the plug function as _deprecated_, the function remains active but is removed from the default listings.   This also applies to _draft_ versions.  This parameter is incompatible with `force=true`.  If not set the default behaviour applies: * _draft_ versions are _undeployed_ and _removed_ from registry. * non-_draft_ versions are marked _deprecated_ only.
        :type query['undeploy']: bool
        :param raw_response: If true, return the http Response object instead of returning an api model object, or throwing an ApiError.
        :param select_path: Denotes the json path applied to the response object before returning it.
                Set it to the empty string `""` to receive the full response object.
        :param headers: Header parameters for this request
        :type headers: dict, optional
        :param `**kwargs`: Additional parameters passed on to the http client.
            See below.
        :Keyword Arguments:
            * timeout: a single numeric timeout in seconds,
                or a tuple of _connect_, _read_, _write_ and _pool_ timeouts.
            * stream: if true, the response will be in streaming mode
            * cookies
            * extensions
            * auth
            * follow_redirects: bool

        :return: Returns the result object if the http request succeeded with status code '2XX'.
        :raises APIError: If the http request has a status code different from `2XX`. This
            object wraps both the http Response and any parsed data.
        """

        # set aside send args
        send_args = {}
        for key in ["stream", "follow_redirects", "auth"]:
            if key in kwargs:
                send_args[key] = kwargs.pop(key)
        # path parameters
        path_params: Dict[str, str] = {
            "name": StringAdapter.validate_python(name),
        }

        ## named body parameters
        body_args: Dict[str, Any] = {}

        ## create httpx.Request
        api_request = self.api_client.build_request(
            method="DELETE",
            resource_path="/registry/v2/webscripts/{name}",
            path_params=path_params,
            params=query,
            **body_args,
            headers=headers,
            **kwargs,
        )

        ## initiate http request
        response = await self.api_client.send(api_request, **send_args)

        ## render response
        if raw_response:
            return response
        response_types_map: Dict[str, Optional[Union[str, Any]]] = {
            "200": UndeployedResponseV2 if not select_path else Model,
            "202": UndeploySubmittedResponseV2 if not select_path else Model,
        }
        stream = send_args.get("stream", False)
        return self.api_client.response_deserialize(
            response, response_types_map, select_path, stream=stream
        )

    @overload
    async def update_asset(
        self,
        name: Annotated[StrictStr, Field(description="The name of the function.")],
        version: Annotated[
            str, Field(strict=True, description="The version of the function.")
        ],
        wildcard: Annotated[
            StrictStr,
            Field(
                description="Full path or path prefix of the asset within the archive"
            ),
        ],
        *,
        content: Annotated[
            Optional[RequestContent], Field(description="A single asset file.")
        ] = None,
        query: Optional[Union[UpdateAssetQuery, QueryParamTypes]] = None,
        raw_response: Literal[False] = False,
        select_path: Literal[""],
        headers: Optional[HeaderTypes] = None,
        **kwargs,
    ) -> PostWebscriptJobSyncResponseV2: ...

    @overload
    async def update_asset(
        self,
        name: Annotated[StrictStr, Field(description="The name of the function.")],
        version: Annotated[
            str, Field(strict=True, description="The version of the function.")
        ],
        wildcard: Annotated[
            StrictStr,
            Field(
                description="Full path or path prefix of the asset within the archive"
            ),
        ],
        *,
        content: Annotated[
            Optional[RequestContent], Field(description="A single asset file.")
        ] = None,
        query: Optional[Union[UpdateAssetQuery, QueryParamTypes]] = None,
        raw_response: Literal[True],
        select_path: Literal["_not_used_"] = "_not_used_",
        headers: Optional[HeaderTypes] = None,
        **kwargs,
    ) -> Response: ...

    # @validate_call
    async def update_asset(
        self,
        name: Annotated[StrictStr, Field(description="The name of the function.")],
        version: Annotated[
            str, Field(strict=True, description="The version of the function.")
        ],
        wildcard: Annotated[
            StrictStr,
            Field(
                description="Full path or path prefix of the asset within the archive"
            ),
        ],
        *,
        content: Annotated[
            Optional[RequestContent], Field(description="A single asset file.")
        ] = None,
        query: Optional[Union[UpdateAssetQuery, QueryParamTypes]] = None,
        raw_response: StrictBool = False,
        select_path: str = "",
        headers: Optional[HeaderTypes] = None,
        **kwargs,
    ) -> Union[PostWebscriptJobSyncResponseV2, Response, Model]:
        """Update Webscript Asset.

        The provided asset will be added to the <em>webscript</em> function's collection of existing assets,   replacing any existing asset with the same name.    Please note that it is not allowed to update the webscript.json json file with a changed value for any of the     <code>name</code>, <code>version</code> and/or <code>runtime</code> attributes.    For each <em>runtime</em> other files are supported.
        :param name: The name of the function. (required)
        :type name: str
        :param version: The version of the function. (required)
        :type version: str
        :param wildcard: Full path or path prefix of the asset within the archive (required)
        :type wildcard: str
        :param content: A single asset file.
        :type content: ContentRequest, optional
        :param query: URL Query parameters.
        :type query: UpdateAssetQuery | QueryParamTypes, optional
        :param query['comment']: An optional user-specified comment corresponding to the operation.
        :type query['comment']: str
        :param query['async']: Unless this is set to <code>false</code>, the server will start the required job actions asynchronously and return a <code>202</code> <em>Accepted</em> response. If <code>false</code> the request will block until the job actions are completed, or a timeout occurs.
        :type query['async']: bool
        :param query['chown']: If set, ownership of the draft function is transferred to the current user. (required)
        :type query['chown']: bool
        :param raw_response: If true, return the http Response object instead of returning an api model object, or throwing an ApiError.
        :param select_path: Denotes the json path applied to the response object before returning it.
                Set it to the empty string `""` to receive the full response object.
        :param headers: Header parameters for this request
        :type headers: dict, optional
        :param `**kwargs`: Additional parameters passed on to the http client.
            See below.
        :Keyword Arguments:
            * timeout: a single numeric timeout in seconds,
                or a tuple of _connect_, _read_, _write_ and _pool_ timeouts.
            * stream: if true, the response will be in streaming mode
            * cookies
            * extensions
            * auth
            * follow_redirects: bool

        :return: Returns the result object if the http request succeeded with status code '2XX'.
        :raises APIError: If the http request has a status code different from `2XX`. This
            object wraps both the http Response and any parsed data.
        """

        # set aside send args
        send_args = {}
        for key in ["stream", "follow_redirects", "auth"]:
            if key in kwargs:
                send_args[key] = kwargs.pop(key)
        # path parameters
        path_params: Dict[str, str] = {
            "name": StringAdapter.validate_python(name),
            "version": StringAdapter.validate_python(version),
            "wildcard": StringAdapter.validate_python(wildcard),
        }

        ## named body parameters
        body_args: Dict[str, Any] = {}
        body_args["content"] = content

        ## create httpx.Request
        api_request = self.api_client.build_request(
            method="PUT",
            resource_path="/registry/v2/webscripts/{name}/versions/{version}/content/{wildcard}",
            path_params=path_params,
            params=query,
            **body_args,
            headers=headers,
            **kwargs,
        )

        ## initiate http request
        response = await self.api_client.send(api_request, **send_args)

        ## render response
        if raw_response:
            return response
        response_types_map: Dict[str, Optional[Union[str, Any]]] = {
            "201": PostWebscriptJobSyncResponseV2 if not select_path else Model,
            "202": PostWebscriptJobAsyncResponseV2 if not select_path else Model,
        }
        stream = send_args.get("stream", False)
        return self.api_client.response_deserialize(
            response, response_types_map, select_path, stream=stream
        )

    @overload
    async def update_assets(
        self,
        name: Annotated[StrictStr, Field(description="The name of the function.")],
        version: Annotated[
            str, Field(strict=True, description="The version of the function.")
        ],
        *,
        content: Annotated[
            Optional[RequestContent],
            Field(
                description="The assets for a <em>webscript</em> function can be provided as either   <ul>     <li>a single <em>tar</em> archive (optionally compressed), with one of the content types      <code>application/octet-stream</code>, <code>application/tar+gzip</code>, <code>application/x-gzip</code>, <code>application/x-tar</code>, <code>application/gzip</code></li>     <li>separate files in a <code>multipart/form-data</code> request</li>   </ul>    The provided assets will be added to the <em>webscript</em> function's collection of existing assets,   replacing any existing assets with the same name.    Please note that it is not allowed to update the webscript.json</code> json file with a changed value for any of the    <code>name</code>, <code>version</code> and/or <code>runtime</code> attributes.    For each <em>runtime</em> other files are supported. "
            ),
        ] = None,
        files: Annotated[
            Optional[RequestFiles], Field(description="Multipart file upload")
        ] = None,
        query: Optional[Union[UpdateAssetsQuery, QueryParamTypes]] = None,
        raw_response: Literal[False] = False,
        select_path: Literal[""],
        headers: Optional[HeaderTypes] = None,
        **kwargs,
    ) -> PostWebscriptJobSyncResponseV2: ...

    @overload
    async def update_assets(
        self,
        name: Annotated[StrictStr, Field(description="The name of the function.")],
        version: Annotated[
            str, Field(strict=True, description="The version of the function.")
        ],
        *,
        content: Annotated[
            Optional[RequestContent],
            Field(
                description="The assets for a <em>webscript</em> function can be provided as either   <ul>     <li>a single <em>tar</em> archive (optionally compressed), with one of the content types      <code>application/octet-stream</code>, <code>application/tar+gzip</code>, <code>application/x-gzip</code>, <code>application/x-tar</code>, <code>application/gzip</code></li>     <li>separate files in a <code>multipart/form-data</code> request</li>   </ul>    The provided assets will be added to the <em>webscript</em> function's collection of existing assets,   replacing any existing assets with the same name.    Please note that it is not allowed to update the webscript.json</code> json file with a changed value for any of the    <code>name</code>, <code>version</code> and/or <code>runtime</code> attributes.    For each <em>runtime</em> other files are supported. "
            ),
        ] = None,
        files: Annotated[
            Optional[RequestFiles], Field(description="Multipart file upload")
        ] = None,
        query: Optional[Union[UpdateAssetsQuery, QueryParamTypes]] = None,
        raw_response: Literal[True],
        select_path: Literal["_not_used_"] = "_not_used_",
        headers: Optional[HeaderTypes] = None,
        **kwargs,
    ) -> Response: ...

    # @validate_call
    async def update_assets(
        self,
        name: Annotated[StrictStr, Field(description="The name of the function.")],
        version: Annotated[
            str, Field(strict=True, description="The version of the function.")
        ],
        *,
        content: Annotated[
            Optional[RequestContent],
            Field(
                description="The assets for a <em>webscript</em> function can be provided as either   <ul>     <li>a single <em>tar</em> archive (optionally compressed), with one of the content types      <code>application/octet-stream</code>, <code>application/tar+gzip</code>, <code>application/x-gzip</code>, <code>application/x-tar</code>, <code>application/gzip</code></li>     <li>separate files in a <code>multipart/form-data</code> request</li>   </ul>    The provided assets will be added to the <em>webscript</em> function's collection of existing assets,   replacing any existing assets with the same name.    Please note that it is not allowed to update the webscript.json</code> json file with a changed value for any of the    <code>name</code>, <code>version</code> and/or <code>runtime</code> attributes.    For each <em>runtime</em> other files are supported. "
            ),
        ] = None,
        files: Annotated[
            Optional[RequestFiles], Field(description="Multipart file upload")
        ] = None,
        query: Optional[Union[UpdateAssetsQuery, QueryParamTypes]] = None,
        raw_response: StrictBool = False,
        select_path: str = "",
        headers: Optional[HeaderTypes] = None,
        **kwargs,
    ) -> Union[PostWebscriptJobSyncResponseV2, Response, Model]:
        """Update Webscript Assets.

        Update a draft <em>webscript</em> function by updating its assets.      The assets for a <em>webscript</em> function can be provided as either   <ul>     <li>a single <em>tar</em> archive (optionally compressed), with one of the content types      <code>application/octet-stream</code>, <code>application/tar+gzip</code>, <code>application/x-gzip</code>, <code>application/x-tar</code>, <code>application/gzip</code></li>     <li>separate files in a <code>multipart/form-data</code> request</li>   </ul>    The provided assets will be added to the <em>webscript</em> function's collection of existing assets,   replacing any existing assets with the same name.    Please note that it is not allowed to update the webscript.json</code> json file with a changed value for any of the    <code>name</code>, <code>version</code> and/or <code>runtime</code> attributes.    For each <em>runtime</em> other files are supported.
        :param name: The name of the function. (required)
        :type name: str
        :param version: The version of the function. (required)
        :type version: str
        :param content: The assets for a <em>webscript</em> function can be provided as either   <ul>     <li>a single <em>tar</em> archive (optionally compressed), with one of the content types      <code>application/octet-stream</code>, <code>application/tar+gzip</code>, <code>application/x-gzip</code>, <code>application/x-tar</code>, <code>application/gzip</code></li>     <li>separate files in a <code>multipart/form-data</code> request</li>   </ul>    The provided assets will be added to the <em>webscript</em> function's collection of existing assets,   replacing any existing assets with the same name.    Please note that it is not allowed to update the webscript.json</code> json file with a changed value for any of the    <code>name</code>, <code>version</code> and/or <code>runtime</code> attributes.    For each <em>runtime</em> other files are supported.
        :type content: ContentRequest, optional
        :param files: The files of a `content-type: multipart/form-data` request.
        :type files: FilesRequest, optional
        :param query: URL Query parameters.
        :type query: UpdateAssetsQuery | QueryParamTypes, optional
        :param query['comment']: An optional user-specified comment corresponding to the operation.
        :type query['comment']: str
        :param query['async']: Unless this is set to <code>false</code>, the server will start the required job actions asynchronously and return a <code>202</code> <em>Accepted</em> response. If <code>false</code> the request will block until the job actions are completed, or a timeout occurs.
        :type query['async']: bool
        :param query['chown']: If set, ownership of the draft function is transferred to the current user. (required)
        :type query['chown']: bool
        :param raw_response: If true, return the http Response object instead of returning an api model object, or throwing an ApiError.
        :param select_path: Denotes the json path applied to the response object before returning it.
                Set it to the empty string `""` to receive the full response object.
        :param headers: Header parameters for this request
        :type headers: dict, optional
        :param `**kwargs`: Additional parameters passed on to the http client.
            See below.
        :Keyword Arguments:
            * timeout: a single numeric timeout in seconds,
                or a tuple of _connect_, _read_, _write_ and _pool_ timeouts.
            * stream: if true, the response will be in streaming mode
            * cookies
            * extensions
            * auth
            * follow_redirects: bool

        :return: Returns the result object if the http request succeeded with status code '2XX'.
        :raises APIError: If the http request has a status code different from `2XX`. This
            object wraps both the http Response and any parsed data.
        """

        # set aside send args
        send_args = {}
        for key in ["stream", "follow_redirects", "auth"]:
            if key in kwargs:
                send_args[key] = kwargs.pop(key)
        # path parameters
        path_params: Dict[str, str] = {
            "name": StringAdapter.validate_python(name),
            "version": StringAdapter.validate_python(version),
        }

        ## named body parameters
        body_args: Dict[str, Any] = {}
        body_args["content"] = content
        body_args["files"] = files

        ## create httpx.Request
        api_request = self.api_client.build_request(
            method="PUT",
            resource_path="/registry/v2/webscripts/{name}/versions/{version}/content",
            path_params=path_params,
            params=query,
            **body_args,
            headers=headers,
            **kwargs,
        )

        ## initiate http request
        response = await self.api_client.send(api_request, **send_args)

        ## render response
        if raw_response:
            return response
        response_types_map: Dict[str, Optional[Union[str, Any]]] = {
            "201": PostWebscriptJobSyncResponseV2 if not select_path else Model,
            "202": PostWebscriptJobAsyncResponseV2 if not select_path else Model,
        }
        stream = send_args.get("stream", False)
        return self.api_client.response_deserialize(
            response, response_types_map, select_path, stream=stream
        )

    @overload
    async def verify(
        self,
        name: Annotated[StrictStr, Field(description="The name of the function.")],
        version: Annotated[
            str, Field(strict=True, description="The version of the function.")
        ],
        *,
        query: Optional[Union[VerifyQuery, QueryParamTypes]] = None,
        raw_response: Literal[False] = False,
        select_path: Literal[""],
        headers: Optional[HeaderTypes] = None,
        **kwargs,
    ) -> VerifyWebscriptSyncResponseV2: ...

    @overload
    async def verify(
        self,
        name: Annotated[StrictStr, Field(description="The name of the function.")],
        version: Annotated[
            str, Field(strict=True, description="The version of the function.")
        ],
        *,
        query: Optional[Union[VerifyQuery, QueryParamTypes]] = None,
        raw_response: Literal[True],
        select_path: Literal["_not_used_"] = "_not_used_",
        headers: Optional[HeaderTypes] = None,
        **kwargs,
    ) -> Response: ...

    # @validate_call
    async def verify(
        self,
        name: Annotated[StrictStr, Field(description="The name of the function.")],
        version: Annotated[
            str, Field(strict=True, description="The version of the function.")
        ],
        *,
        query: Optional[Union[VerifyQuery, QueryParamTypes]] = None,
        raw_response: StrictBool = False,
        select_path: str = "",
        headers: Optional[HeaderTypes] = None,
        **kwargs,
    ) -> Union[VerifyWebscriptSyncResponseV2, Response, Model]:
        """Verify Health Of Webscript.

        Verify health of webscript deployed on openfaas.
        :param name: The name of the function. (required)
        :type name: str
        :param version: The version of the function. (required)
        :type version: str
        :param query: URL Query parameters.
        :type query: VerifyQuery | QueryParamTypes, optional
        :param query['comment']: An optional user-specified comment corresponding to the operation.
        :type query['comment']: str
        :param query['async']: Unless this is set to <code>false</code>, the server will start the required job actions asynchronously and return a <code>202</code> <em>Accepted</em> response. If <code>false</code> the request will block until the job actions are completed, or a timeout occurs.
        :type query['async']: bool
        :param query['scaleToZero']: Indicates whether the function needs to be scaled down after successful verification. If not set, the function is scaled to zero only if it was not active before this command.
        :type query['scaleToZero']: bool
        :param raw_response: If true, return the http Response object instead of returning an api model object, or throwing an ApiError.
        :param select_path: Denotes the json path applied to the response object before returning it.
                Set it to the empty string `""` to receive the full response object.
        :param headers: Header parameters for this request
        :type headers: dict, optional
        :param `**kwargs`: Additional parameters passed on to the http client.
            See below.
        :Keyword Arguments:
            * timeout: a single numeric timeout in seconds,
                or a tuple of _connect_, _read_, _write_ and _pool_ timeouts.
            * stream: if true, the response will be in streaming mode
            * cookies
            * extensions
            * auth
            * follow_redirects: bool

        :return: Returns the result object if the http request succeeded with status code '2XX'.
        :raises APIError: If the http request has a status code different from `2XX`. This
            object wraps both the http Response and any parsed data.
        """

        # set aside send args
        send_args = {}
        for key in ["stream", "follow_redirects", "auth"]:
            if key in kwargs:
                send_args[key] = kwargs.pop(key)
        # path parameters
        path_params: Dict[str, str] = {
            "name": StringAdapter.validate_python(name),
            "version": StringAdapter.validate_python(version),
        }

        ## named body parameters
        body_args: Dict[str, Any] = {}

        ## create httpx.Request
        api_request = self.api_client.build_request(
            method="POST",
            resource_path="/registry/v2/webscripts/{name}/versions/{version}/verify",
            path_params=path_params,
            params=query,
            **body_args,
            headers=headers,
            **kwargs,
        )

        ## initiate http request
        response = await self.api_client.send(api_request, **send_args)

        ## render response
        if raw_response:
            return response
        response_types_map: Dict[str, Optional[Union[str, Any]]] = {
            "200": VerifyWebscriptSyncResponseV2 if not select_path else Model,
            "202": PostWebscriptJobAsyncResponseV2 if not select_path else Model,
        }
        stream = send_args.get("stream", False)
        return self.api_client.response_deserialize(
            response, response_types_map, select_path, stream=stream
        )
