# coding: utf-8
"""Waylay Function Registry api.

This code was generated from the OpenAPI documentation of 'Waylay Function Registry'

Generated by OpenAPI Generator (https://openapi-generator.tech)

Do not edit the class manually.
"""


from __future__ import annotations  # for Python 3.7â€“3.9

import enum
from pydantic import validate_call, Field, StrictStr, StrictBool
from typing import Dict, Literal, Optional, Union, Any, overload, TYPE_CHECKING


try:
    from typing import Annotated
except ImportError:
    from typing_extensions import Annotated  # type: ignore # noqa: F401

if TYPE_CHECKING:
    from waylay.services.registry.models import SemanticVersionRange
    from waylay.services.registry.models import SemanticVersionRange
    from waylay.services.registry.models import SemanticVersionRange

    from waylay.services.registry.queries.runtimes_api import ExampleArchiveQuery
    from waylay.services.registry.queries.runtimes_api import GetExampleAssetQuery
    from waylay.services.registry.queries.runtimes_api import GetLatestQuery
    from waylay.services.registry.queries.runtimes_api import GetQuery
    from waylay.services.registry.queries.runtimes_api import ListQuery
    from waylay.services.registry.queries.runtimes_api import ListVersionsQuery

    from waylay.services.registry.models import RuntimeVersionResponse

    from waylay.services.registry.models import RuntimeVersionResponse

    from waylay.services.registry.models import RuntimeSummaryResponse

    from waylay.services.registry.models import RuntimeSummaryResponse


try:
    from waylay.services.registry.models import SemanticVersionRange
    from waylay.services.registry.models import SemanticVersionRange
    from waylay.services.registry.models import SemanticVersionRange

    from waylay.services.registry.queries.runtimes_api import ExampleArchiveQuery
    from waylay.services.registry.queries.runtimes_api import GetExampleAssetQuery
    from waylay.services.registry.queries.runtimes_api import GetLatestQuery
    from waylay.services.registry.queries.runtimes_api import GetQuery
    from waylay.services.registry.queries.runtimes_api import ListQuery
    from waylay.services.registry.queries.runtimes_api import ListVersionsQuery

    from waylay.services.registry.models import RuntimeVersionResponse

    from waylay.services.registry.models import RuntimeVersionResponse

    from waylay.services.registry.models import RuntimeSummaryResponse

    from waylay.services.registry.models import RuntimeSummaryResponse

    types_available = True
except ImportError:
    types_available = False

    if not TYPE_CHECKING:
        SemanticVersionRange = str
        SemanticVersionRange = str
        SemanticVersionRange = str

        ExampleArchiveQuery = Dict
        GetExampleAssetQuery = Dict
        GetLatestQuery = Dict
        GetQuery = Dict
        ListQuery = Dict
        ListVersionsQuery = Dict

        RuntimeVersionResponse = Any

        RuntimeVersionResponse = Any

        RuntimeSummaryResponse = Any

        RuntimeSummaryResponse = Any


from waylay.sdk.api import ApiClient, ApiResponse, RESTTimeout


class RuntimesApi:
    """RuntimesApi service methods.

    NOTE: This class is auto generated by OpenAPI Generator
    Ref: https://openapi-generator.tech

    Do not edit the class manually.
    """

    def __init__(self, api_client: ApiClient) -> None:
        """Create a RuntimesApi instance."""
        self._api_client: ApiClient = api_client

    @overload
    async def example_archive(
        self,
        name: Annotated[StrictStr, Field(description="The name of a <em>runtime</em>")],
        version: Annotated[
            Any, Field(description="A version range for a <em>runtime</em>")
        ],
        *,
        query: Optional[ExampleArchiveQuery] = None,
        _request_timeout: Optional[RESTTimeout] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        with_http_info: Literal[False] = False,
    ) -> bytearray:
        ...

    @overload
    async def example_archive(
        self,
        name: Annotated[StrictStr, Field(description="The name of a <em>runtime</em>")],
        version: Annotated[
            Any, Field(description="A version range for a <em>runtime</em>")
        ],
        *,
        query: Optional[ExampleArchiveQuery] = None,
        _request_timeout: Optional[RESTTimeout] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        with_http_info: Literal[True],
    ) -> ApiResponse[bytearray]:
        ...

    @validate_call
    async def example_archive(
        self,
        name: Annotated[StrictStr, Field(description="The name of a <em>runtime</em>")],
        version: Annotated[
            Any, Field(description="A version range for a <em>runtime</em>")
        ],
        *,
        query: Optional[ExampleArchiveQuery] = None,
        _request_timeout: Optional[RESTTimeout] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        with_http_info: StrictBool = False,
    ) -> Union[bytearray, ApiResponse[bytearray]]:
        """Get Runtime Example Archive.

        Get an example of the specification archive of the runtime.

        :param name: The name of a <em>runtime</em> (required)
        :type name: str
        :param version: A version range for a <em>runtime</em> (required)
        :type version: SemanticVersionRange
        :param query: Supported query params. (optional)
        :type query: TypedDict, optional:
            :param query.ls: If set to `true`, the result will be a listing of the files in the asset, annotated with metadata and validation report from the asset conditions of the functions runtime.
            :type query.ls: bool
            :param query.include_deprecated: If set to `true`, deprecated runtimes will be included in the query.
            :type query.include_deprecated: bool
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :return: Returns the result object.
        """

        _request_params = self._example_archive_serialize(
            name=name,
            version=version,
            body=None,
            files=None,
            query=query,
            _headers=_headers,
        )

        _response_types_map: Dict[str, Optional[str]] = {
            "200": "bytearray",
        }
        response_data = await self._api_client.call_api(
            **_request_params, _request_timeout=_request_timeout
        )
        result = self._api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )
        return result if with_http_info else result.data

    def _example_archive_serialize(
        self,
        name,
        version,
        body,
        files,
        query,
        _headers,
    ) -> dict[str, Any]:
        _path_params: Dict[str, str] = {}
        _query_params: Dict[str, Any] = {}
        _header_params: Dict[str, Optional[str]] = (
            {k.lower(): v for k, v in _headers.items()} if _headers else {}
        )
        _form_params: Dict[str, str] = {}
        _files: Dict[str, str] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if name is not None:
            _path_params["name"] = name
        if version is not None:
            _path_params["version"] = version
        # process the query parameters
        if query is not None:
            query_param = query.get("ls", None)
            if query_param is not None:
                _query_params["ls"] = query_param

            query_param = query.get("include_deprecated", None)
            if query_param is not None:
                _query_params["includeDeprecated"] = query_param

        # process the form parameters
        # process the body parameter

        return self._api_client.param_serialize(
            method="GET",
            resource_path="/registry/v2/runtimes/{name}/versions/{version}/example",
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            files=_files,
        )

    @overload
    async def get_example_asset(
        self,
        name: Annotated[StrictStr, Field(description="The name of a <em>runtime</em>")],
        version: Annotated[
            Any, Field(description="A version range for a <em>runtime</em>")
        ],
        wildcard: Annotated[
            StrictStr,
            Field(
                description="Full path or path prefix of the asset within the archive"
            ),
        ],
        *,
        query: Optional[GetExampleAssetQuery] = None,
        _request_timeout: Optional[RESTTimeout] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        with_http_info: Literal[False] = False,
    ) -> bytearray:
        ...

    @overload
    async def get_example_asset(
        self,
        name: Annotated[StrictStr, Field(description="The name of a <em>runtime</em>")],
        version: Annotated[
            Any, Field(description="A version range for a <em>runtime</em>")
        ],
        wildcard: Annotated[
            StrictStr,
            Field(
                description="Full path or path prefix of the asset within the archive"
            ),
        ],
        *,
        query: Optional[GetExampleAssetQuery] = None,
        _request_timeout: Optional[RESTTimeout] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        with_http_info: Literal[True],
    ) -> ApiResponse[bytearray]:
        ...

    @validate_call
    async def get_example_asset(
        self,
        name: Annotated[StrictStr, Field(description="The name of a <em>runtime</em>")],
        version: Annotated[
            Any, Field(description="A version range for a <em>runtime</em>")
        ],
        wildcard: Annotated[
            StrictStr,
            Field(
                description="Full path or path prefix of the asset within the archive"
            ),
        ],
        *,
        query: Optional[GetExampleAssetQuery] = None,
        _request_timeout: Optional[RESTTimeout] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        with_http_info: StrictBool = False,
    ) -> Union[bytearray, ApiResponse[bytearray]]:
        """Get File From Runtime Example Archive.

        Get a file from the example specification archive of the runtime.

        :param name: The name of a <em>runtime</em> (required)
        :type name: str
        :param version: A version range for a <em>runtime</em> (required)
        :type version: SemanticVersionRange
        :param wildcard: Full path or path prefix of the asset within the archive (required)
        :type wildcard: str
        :param query: Supported query params. (optional)
        :type query: TypedDict, optional:
            :param query.ls: If set to `true`, the result will be a listing of the files in the asset, annotated with metadata and validation report from the asset conditions of the functions runtime.
            :type query.ls: bool
            :param query.include_deprecated: If set to `true`, deprecated runtimes will be included in the query.
            :type query.include_deprecated: bool
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :return: Returns the result object.
        """

        _request_params = self._get_example_asset_serialize(
            name=name,
            version=version,
            wildcard=wildcard,
            body=None,
            files=None,
            query=query,
            _headers=_headers,
        )

        _response_types_map: Dict[str, Optional[str]] = {
            "200": "bytearray",
        }
        response_data = await self._api_client.call_api(
            **_request_params, _request_timeout=_request_timeout
        )
        result = self._api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )
        return result if with_http_info else result.data

    def _get_example_asset_serialize(
        self,
        name,
        version,
        wildcard,
        body,
        files,
        query,
        _headers,
    ) -> dict[str, Any]:
        _path_params: Dict[str, str] = {}
        _query_params: Dict[str, Any] = {}
        _header_params: Dict[str, Optional[str]] = (
            {k.lower(): v for k, v in _headers.items()} if _headers else {}
        )
        _form_params: Dict[str, str] = {}
        _files: Dict[str, str] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if name is not None:
            _path_params["name"] = name
        if version is not None:
            _path_params["version"] = version
        if wildcard is not None:
            _path_params["wildcard"] = wildcard
        # process the query parameters
        if query is not None:
            query_param = query.get("ls", None)
            if query_param is not None:
                _query_params["ls"] = query_param

            query_param = query.get("include_deprecated", None)
            if query_param is not None:
                _query_params["includeDeprecated"] = query_param

        # process the form parameters
        # process the body parameter

        return self._api_client.param_serialize(
            method="GET",
            resource_path="/registry/v2/runtimes/{name}/versions/{version}/example/{wildcard}",
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            files=_files,
        )

    @overload
    async def get_latest(
        self,
        name: Annotated[StrictStr, Field(description="The name of a <em>runtime</em>")],
        *,
        query: Optional[GetLatestQuery] = None,
        _request_timeout: Optional[RESTTimeout] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        with_http_info: Literal[False] = False,
    ) -> RuntimeVersionResponse:
        ...

    @overload
    async def get_latest(
        self,
        name: Annotated[StrictStr, Field(description="The name of a <em>runtime</em>")],
        *,
        query: Optional[GetLatestQuery] = None,
        _request_timeout: Optional[RESTTimeout] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        with_http_info: Literal[True],
    ) -> ApiResponse[RuntimeVersionResponse]:
        ...

    @validate_call
    async def get_latest(
        self,
        name: Annotated[StrictStr, Field(description="The name of a <em>runtime</em>")],
        *,
        query: Optional[GetLatestQuery] = None,
        _request_timeout: Optional[RESTTimeout] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        with_http_info: StrictBool = False,
    ) -> Union[RuntimeVersionResponse, ApiResponse[RuntimeVersionResponse]]:
        """Get Latest Runtime Version.

        Get a representation of the default runtime version by name.

        :param name: The name of a <em>runtime</em> (required)
        :type name: str
        :param query: Supported query params. (optional)
        :type query: TypedDict, optional:
            :param query.version: If set, filters on the <code>version</code> of a runtime. Supports [version ranges](https://devhints.io/semver).
            :type query.version: SemanticVersionRange
            :param query.include_deprecated: If set to `true`, deprecated runtimes will be included in the query.
            :type query.include_deprecated: bool
            :param query.function_type: If set, filters on the <code>functionType</code> of a runtime. Uses an exact match.
            :type query.function_type: List[FunctionType]
            :param query.archive_format: If set, filters on the <code>archiveFormat</code> of a runtime. Uses an exact match.
            :type query.archive_format: List[ArchiveFormat]
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :return: Returns the result object.
        """

        _request_params = self._get_latest_serialize(
            name=name,
            body=None,
            files=None,
            query=query,
            _headers=_headers,
        )

        _response_types_map: Dict[str, Optional[str]] = {
            "200": "waylay.services.registry.models.RuntimeVersionResponse",
        }
        response_data = await self._api_client.call_api(
            **_request_params, _request_timeout=_request_timeout
        )
        result = self._api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )
        return result if with_http_info else result.data

    def _get_latest_serialize(
        self,
        name,
        body,
        files,
        query,
        _headers,
    ) -> dict[str, Any]:
        _path_params: Dict[str, str] = {}
        _query_params: Dict[str, Any] = {}
        _header_params: Dict[str, Optional[str]] = (
            {k.lower(): v for k, v in _headers.items()} if _headers else {}
        )
        _form_params: Dict[str, str] = {}
        _files: Dict[str, str] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if name is not None:
            _path_params["name"] = name
        # process the query parameters
        if query is not None:
            query_param = query.get("version", None)
            if query_param is not None:
                _query_params["version"] = query_param

            query_param = query.get("include_deprecated", None)
            if query_param is not None:
                _query_params["includeDeprecated"] = query_param

            query_param = query.get("function_type", None)
            if query_param is not None:
                _query_params["functionType"] = [
                    v.value if isinstance(v, enum.Enum) else v for v in query_param
                ]

            query_param = query.get("archive_format", None)
            if query_param is not None:
                _query_params["archiveFormat"] = [
                    v.value if isinstance(v, enum.Enum) else v for v in query_param
                ]

        # process the form parameters
        # process the body parameter

        return self._api_client.param_serialize(
            method="GET",
            resource_path="/registry/v2/runtimes/{name}",
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            files=_files,
        )

    @overload
    async def get(
        self,
        name: Annotated[StrictStr, Field(description="The name of a <em>runtime</em>")],
        version: Annotated[
            Any, Field(description="A version range for a <em>runtime</em>")
        ],
        *,
        query: Optional[GetQuery] = None,
        _request_timeout: Optional[RESTTimeout] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        with_http_info: Literal[False] = False,
    ) -> RuntimeVersionResponse:
        ...

    @overload
    async def get(
        self,
        name: Annotated[StrictStr, Field(description="The name of a <em>runtime</em>")],
        version: Annotated[
            Any, Field(description="A version range for a <em>runtime</em>")
        ],
        *,
        query: Optional[GetQuery] = None,
        _request_timeout: Optional[RESTTimeout] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        with_http_info: Literal[True],
    ) -> ApiResponse[RuntimeVersionResponse]:
        ...

    @validate_call
    async def get(
        self,
        name: Annotated[StrictStr, Field(description="The name of a <em>runtime</em>")],
        version: Annotated[
            Any, Field(description="A version range for a <em>runtime</em>")
        ],
        *,
        query: Optional[GetQuery] = None,
        _request_timeout: Optional[RESTTimeout] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        with_http_info: StrictBool = False,
    ) -> Union[RuntimeVersionResponse, ApiResponse[RuntimeVersionResponse]]:
        """Get Runtime Version.

        Get a representation of the default runtime version by name.

        :param name: The name of a <em>runtime</em> (required)
        :type name: str
        :param version: A version range for a <em>runtime</em> (required)
        :type version: SemanticVersionRange
        :param query: Supported query params. (optional)
        :type query: TypedDict, optional:
            :param query.include_deprecated: If set to `true`, deprecated runtimes will be included in the query.
            :type query.include_deprecated: bool
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :return: Returns the result object.
        """

        _request_params = self._get_serialize(
            name=name,
            version=version,
            body=None,
            files=None,
            query=query,
            _headers=_headers,
        )

        _response_types_map: Dict[str, Optional[str]] = {
            "200": "waylay.services.registry.models.RuntimeVersionResponse",
        }
        response_data = await self._api_client.call_api(
            **_request_params, _request_timeout=_request_timeout
        )
        result = self._api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )
        return result if with_http_info else result.data

    def _get_serialize(
        self,
        name,
        version,
        body,
        files,
        query,
        _headers,
    ) -> dict[str, Any]:
        _path_params: Dict[str, str] = {}
        _query_params: Dict[str, Any] = {}
        _header_params: Dict[str, Optional[str]] = (
            {k.lower(): v for k, v in _headers.items()} if _headers else {}
        )
        _form_params: Dict[str, str] = {}
        _files: Dict[str, str] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if name is not None:
            _path_params["name"] = name
        if version is not None:
            _path_params["version"] = version
        # process the query parameters
        if query is not None:
            query_param = query.get("include_deprecated", None)
            if query_param is not None:
                _query_params["includeDeprecated"] = query_param

        # process the form parameters
        # process the body parameter

        return self._api_client.param_serialize(
            method="GET",
            resource_path="/registry/v2/runtimes/{name}/versions/{version}",
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            files=_files,
        )

    @overload
    async def list(
        self,
        *,
        query: Optional[ListQuery] = None,
        _request_timeout: Optional[RESTTimeout] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        with_http_info: Literal[False] = False,
    ) -> RuntimeSummaryResponse:
        ...

    @overload
    async def list(
        self,
        *,
        query: Optional[ListQuery] = None,
        _request_timeout: Optional[RESTTimeout] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        with_http_info: Literal[True],
    ) -> ApiResponse[RuntimeSummaryResponse]:
        ...

    @validate_call
    async def list(
        self,
        *,
        query: Optional[ListQuery] = None,
        _request_timeout: Optional[RESTTimeout] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        with_http_info: StrictBool = False,
    ) -> Union[RuntimeSummaryResponse, ApiResponse[RuntimeSummaryResponse]]:
        """List Runtimes.

        List the runtimes that function registry supports.

        :param query: Supported query params. (optional)
        :type query: TypedDict, optional:
            :param query.version: If set, filters on the <code>version</code> of a runtime. Supports [version ranges](https://devhints.io/semver).
            :type query.version: SemanticVersionRange
            :param query.latest: If set, filters on the level of latest versions that will be included in the query. * `major`: include at most one latest version per name and major release. * `minor`: include at most one latest version per name and minor release. * `patch`: include each matching patch version. * `true`: include the latest matching version. * `false`: include any matching version (same as `patch`).  This filter is applied after all other selection criteria.
            :type query.latest: LatestVersionLevel
            :param query.include_deprecated: If set to `true`, deprecated runtimes will be included in the query.
            :type query.include_deprecated: bool
            :param query.name: If set, filters on the <code>name</code> of a runtime. Supports <code>*</code> and <code>?</code> wildcards and is case-insensitive.
            :type query.name: str
            :param query.function_type: If set, filters on the <code>functionType</code> of a runtime. Uses an exact match.
            :type query.function_type: List[FunctionType]
            :param query.archive_format: If set, filters on the <code>archiveFormat</code> of a runtime. Uses an exact match.
            :type query.archive_format: List[ArchiveFormat]
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :return: Returns the result object.
        """

        _request_params = self._list_serialize(
            body=None,
            files=None,
            query=query,
            _headers=_headers,
        )

        _response_types_map: Dict[str, Optional[str]] = {
            "200": "waylay.services.registry.models.RuntimeSummaryResponse",
        }
        response_data = await self._api_client.call_api(
            **_request_params, _request_timeout=_request_timeout
        )
        result = self._api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )
        return result if with_http_info else result.data

    def _list_serialize(
        self,
        body,
        files,
        query,
        _headers,
    ) -> dict[str, Any]:
        _path_params: Dict[str, str] = {}
        _query_params: Dict[str, Any] = {}
        _header_params: Dict[str, Optional[str]] = (
            {k.lower(): v for k, v in _headers.items()} if _headers else {}
        )
        _form_params: Dict[str, str] = {}
        _files: Dict[str, str] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        if query is not None:
            query_param = query.get("version", None)
            if query_param is not None:
                _query_params["version"] = query_param

            query_param = query.get("latest", None)
            if query_param is not None:
                _query_params["latest"] = query_param.value

            query_param = query.get("include_deprecated", None)
            if query_param is not None:
                _query_params["includeDeprecated"] = query_param

            query_param = query.get("name", None)
            if query_param is not None:
                _query_params["name"] = query_param

            query_param = query.get("function_type", None)
            if query_param is not None:
                _query_params["functionType"] = [
                    v.value if isinstance(v, enum.Enum) else v for v in query_param
                ]

            query_param = query.get("archive_format", None)
            if query_param is not None:
                _query_params["archiveFormat"] = [
                    v.value if isinstance(v, enum.Enum) else v for v in query_param
                ]

        # process the form parameters
        # process the body parameter

        return self._api_client.param_serialize(
            method="GET",
            resource_path="/registry/v2/runtimes/",
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            files=_files,
        )

    @overload
    async def list_versions(
        self,
        name: Annotated[StrictStr, Field(description="The name of a <em>runtime</em>")],
        *,
        query: Optional[ListVersionsQuery] = None,
        _request_timeout: Optional[RESTTimeout] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        with_http_info: Literal[False] = False,
    ) -> RuntimeSummaryResponse:
        ...

    @overload
    async def list_versions(
        self,
        name: Annotated[StrictStr, Field(description="The name of a <em>runtime</em>")],
        *,
        query: Optional[ListVersionsQuery] = None,
        _request_timeout: Optional[RESTTimeout] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        with_http_info: Literal[True],
    ) -> ApiResponse[RuntimeSummaryResponse]:
        ...

    @validate_call
    async def list_versions(
        self,
        name: Annotated[StrictStr, Field(description="The name of a <em>runtime</em>")],
        *,
        query: Optional[ListVersionsQuery] = None,
        _request_timeout: Optional[RESTTimeout] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        with_http_info: StrictBool = False,
    ) -> Union[RuntimeSummaryResponse, ApiResponse[RuntimeSummaryResponse]]:
        """List Runtime Versions.

        List the supported versions of a specific runtime.

        :param name: The name of a <em>runtime</em> (required)
        :type name: str
        :param query: Supported query params. (optional)
        :type query: TypedDict, optional:
            :param query.version: If set, filters on the <code>version</code> of a runtime. Supports [version ranges](https://devhints.io/semver).
            :type query.version: SemanticVersionRange
            :param query.latest: If set, filters on the level of latest versions that will be included in the query. * `major`: include at most one latest version per name and major release. * `minor`: include at most one latest version per name and minor release. * `patch`: include each matching patch version. * `true`: include the latest matching version. * `false`: include any matching version (same as `patch`).  This filter is applied after all other selection criteria.
            :type query.latest: LatestVersionLevel
            :param query.include_deprecated: If set to `true`, deprecated runtimes will be included in the query.
            :type query.include_deprecated: bool
            :param query.function_type: If set, filters on the <code>functionType</code> of a runtime. Uses an exact match.
            :type query.function_type: List[FunctionType]
            :param query.archive_format: If set, filters on the <code>archiveFormat</code> of a runtime. Uses an exact match.
            :type query.archive_format: List[ArchiveFormat]
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :return: Returns the result object.
        """

        _request_params = self._list_versions_serialize(
            name=name,
            body=None,
            files=None,
            query=query,
            _headers=_headers,
        )

        _response_types_map: Dict[str, Optional[str]] = {
            "200": "waylay.services.registry.models.RuntimeSummaryResponse",
        }
        response_data = await self._api_client.call_api(
            **_request_params, _request_timeout=_request_timeout
        )
        result = self._api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )
        return result if with_http_info else result.data

    def _list_versions_serialize(
        self,
        name,
        body,
        files,
        query,
        _headers,
    ) -> dict[str, Any]:
        _path_params: Dict[str, str] = {}
        _query_params: Dict[str, Any] = {}
        _header_params: Dict[str, Optional[str]] = (
            {k.lower(): v for k, v in _headers.items()} if _headers else {}
        )
        _form_params: Dict[str, str] = {}
        _files: Dict[str, str] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if name is not None:
            _path_params["name"] = name
        # process the query parameters
        if query is not None:
            query_param = query.get("version", None)
            if query_param is not None:
                _query_params["version"] = query_param

            query_param = query.get("latest", None)
            if query_param is not None:
                _query_params["latest"] = query_param.value

            query_param = query.get("include_deprecated", None)
            if query_param is not None:
                _query_params["includeDeprecated"] = query_param

            query_param = query.get("function_type", None)
            if query_param is not None:
                _query_params["functionType"] = [
                    v.value if isinstance(v, enum.Enum) else v for v in query_param
                ]

            query_param = query.get("archive_format", None)
            if query_param is not None:
                _query_params["archiveFormat"] = [
                    v.value if isinstance(v, enum.Enum) else v for v in query_param
                ]

        # process the form parameters
        # process the body parameter

        return self._api_client.param_serialize(
            method="GET",
            resource_path="/registry/v2/runtimes/{name}/versions",
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            files=_files,
        )
