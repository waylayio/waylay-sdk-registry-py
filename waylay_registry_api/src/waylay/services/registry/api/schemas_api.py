# coding: utf-8
"""Waylay Function Registry api.

This code was generated from the OpenAPI documentation of 'Waylay Function Registry'

Generated by OpenAPI Generator (https://openapi-generator.tech)

Do not edit the class manually.
"""

from __future__ import annotations  # for Python 3.7â€“3.9
import warnings

from pydantic import Field, StrictStr, StrictBool, TypeAdapter
from typing import (
    Dict,
    Literal,
    Optional,
    Union,
    Any,
    overload,
    TYPE_CHECKING,
)
from typing_extensions import (
    Annotated,  # >=3.9,
)

from waylay.sdk.plugin import WithApiClient
from waylay.sdk.api import (
    Response,
    HeaderTypes,
    QueryParamTypes,
)
from waylay.sdk.api._models import Model

if TYPE_CHECKING:
    from waylay.services.registry.models import FunctionType

    from waylay.services.registry.models import AssetRole

    from waylay.services.registry.queries.schemas_api import GetByRoleQuery

    from waylay.services.registry.queries.schemas_api import GetQuery


try:
    from waylay.services.registry.models import FunctionType

    from waylay.services.registry.models import AssetRole

    from waylay.services.registry.queries.schemas_api import GetByRoleQuery

    from waylay.services.registry.queries.schemas_api import GetQuery

    MODELS_AVAILABLE = True
except ImportError:
    MODELS_AVAILABLE = False

    if not TYPE_CHECKING:
        FunctionType = str

        AssetRole = str

        GetByRoleQuery = dict

        GetQuery = dict


class SchemasApi(WithApiClient):
    """SchemasApi service methods.

    NOTE: This class is auto generated by OpenAPI Generator
    Ref: https://openapi-generator.tech

    Do not edit the class manually.
    """

    @overload
    async def get_by_role(
        self,
        function_type: Annotated[FunctionType, Field(description="Function type")],
        role: Annotated[AssetRole, Field(description="Asset role")],
        *,
        query: Optional[Union[GetByRoleQuery, QueryParamTypes]] = None,
        raw_response: Literal[False] = False,
        select_path: Literal[""],
        headers: Optional[HeaderTypes] = None,
        **kwargs,
    ) -> Dict[str, object]: ...

    @overload
    async def get_by_role(
        self,
        function_type: Annotated[FunctionType, Field(description="Function type")],
        role: Annotated[AssetRole, Field(description="Asset role")],
        *,
        query: Optional[Union[GetByRoleQuery, QueryParamTypes]] = None,
        raw_response: Literal[True],
        select_path: Literal["_not_used_"] = "_not_used_",
        headers: Optional[HeaderTypes] = None,
        **kwargs,
    ) -> Response: ...

    async def get_by_role(
        self,
        function_type: Annotated[FunctionType, Field(description="Function type")],
        role: Annotated[AssetRole, Field(description="Asset role")],
        *,
        query: Optional[Union[GetByRoleQuery, QueryParamTypes]] = None,
        raw_response: StrictBool = False,
        select_path: str = "",
        headers: Optional[HeaderTypes] = None,
        **kwargs,
    ) -> Union[Dict[str, object], Response, Model]:
        """Get Asset Schema (Deprecated).

        Get the JSON schema that is used to validate the asset.
        :param function_type: Function type (required)
        :type function_type: FunctionType
        :param role: Asset role (required)
        :type role: AssetRole
        :param query: URL Query parameters.
        :type query: GetByRoleQuery | QueryParamTypes, optional
        :param raw_response: If true, return the http Response object instead of returning an api model object, or throwing an ApiError.
        :param select_path: Denotes the json path applied to the response object before returning it.
                Set it to the empty string `""` to receive the full response object.
        :param headers: Header parameters for this request
        :type headers: dict, optional
        :param `**kwargs`: Additional parameters passed on to the http client.
            See below.
        :Keyword Arguments:
            * timeout: a single numeric timeout in seconds,
                or a tuple of _connect_, _read_, _write_ and _pool_ timeouts.
            * stream: if true, the response will be in streaming mode
            * cookies
            * extensions
            * auth
            * follow_redirects: bool

        :return: Returns the result object if the http request succeeded with status code '2XX'.
        :raises APIError: If the http request has a status code different from `2XX`. This
            object wraps both the http Response and any parsed data.
        """

        warnings.warn(
            "GET /registry/v2/schemas/{functionType}/{role}/schema is deprecated.",
            DeprecationWarning,
        )
        should_validate = (
            MODELS_AVAILABLE and self.api_client.config.client_side_validation
        )

        # set aside send args
        send_args = {}
        for key in ["stream", "follow_redirects", "auth"]:
            if key in kwargs:
                send_args[key] = kwargs.pop(key)
        # path parameters
        path_params: Dict[str, str] = {
            "functionType": str(function_type),
            "role": str(role),
        }

        ## named body parameters
        body_args: Dict[str, Any] = {}

        # query parameters
        if query is not None and should_validate:
            query = TypeAdapter(GetByRoleQuery).validate_python(query)

        ## create httpx.Request
        api_request = self.api_client.build_request(
            method="GET",
            resource_path="/registry/v2/schemas/{functionType}/{role}/schema",
            path_params=path_params,
            params=query,
            **body_args,
            headers=headers,
            **kwargs,
        )

        ## initiate http request
        response = await self.api_client.send(api_request, **send_args)

        ## render response
        if raw_response:
            return response
        response_types_map: Dict[str, Optional[Union[str, Any]]] = {
            "200": Dict[str, object] if not select_path else Model,
        }
        stream = send_args.get("stream", False)
        return self.api_client.response_deserialize(
            response, response_types_map, select_path, stream=stream
        )

    @overload
    async def get(
        self,
        schema_id: Annotated[StrictStr, Field(description="Schema id")],
        *,
        query: Optional[Union[GetQuery, QueryParamTypes]] = None,
        raw_response: Literal[False] = False,
        select_path: Literal[""],
        headers: Optional[HeaderTypes] = None,
        **kwargs,
    ) -> Dict[str, object]: ...

    @overload
    async def get(
        self,
        schema_id: Annotated[StrictStr, Field(description="Schema id")],
        *,
        query: Optional[Union[GetQuery, QueryParamTypes]] = None,
        raw_response: Literal[True],
        select_path: Literal["_not_used_"] = "_not_used_",
        headers: Optional[HeaderTypes] = None,
        **kwargs,
    ) -> Response: ...

    async def get(
        self,
        schema_id: Annotated[StrictStr, Field(description="Schema id")],
        *,
        query: Optional[Union[GetQuery, QueryParamTypes]] = None,
        raw_response: StrictBool = False,
        select_path: str = "",
        headers: Optional[HeaderTypes] = None,
        **kwargs,
    ) -> Union[Dict[str, object], Response, Model]:
        """Get Asset Schema.

        Get the JSON schema that is used to validate an asset.
        :param schema_id: Schema id (required)
        :type schema_id: str
        :param query: URL Query parameters.
        :type query: GetQuery | QueryParamTypes, optional
        :param raw_response: If true, return the http Response object instead of returning an api model object, or throwing an ApiError.
        :param select_path: Denotes the json path applied to the response object before returning it.
                Set it to the empty string `""` to receive the full response object.
        :param headers: Header parameters for this request
        :type headers: dict, optional
        :param `**kwargs`: Additional parameters passed on to the http client.
            See below.
        :Keyword Arguments:
            * timeout: a single numeric timeout in seconds,
                or a tuple of _connect_, _read_, _write_ and _pool_ timeouts.
            * stream: if true, the response will be in streaming mode
            * cookies
            * extensions
            * auth
            * follow_redirects: bool

        :return: Returns the result object if the http request succeeded with status code '2XX'.
        :raises APIError: If the http request has a status code different from `2XX`. This
            object wraps both the http Response and any parsed data.
        """

        should_validate = (
            MODELS_AVAILABLE and self.api_client.config.client_side_validation
        )

        # set aside send args
        send_args = {}
        for key in ["stream", "follow_redirects", "auth"]:
            if key in kwargs:
                send_args[key] = kwargs.pop(key)
        # path parameters
        path_params: Dict[str, str] = {
            "schemaId": str(schema_id),
        }

        ## named body parameters
        body_args: Dict[str, Any] = {}

        # query parameters
        if query is not None and should_validate:
            query = TypeAdapter(GetQuery).validate_python(query)

        ## create httpx.Request
        api_request = self.api_client.build_request(
            method="GET",
            resource_path="/registry/v2/schemas/{schemaId}",
            path_params=path_params,
            params=query,
            **body_args,
            headers=headers,
            **kwargs,
        )

        ## initiate http request
        response = await self.api_client.send(api_request, **send_args)

        ## render response
        if raw_response:
            return response
        response_types_map: Dict[str, Optional[Union[str, Any]]] = {
            "200": Dict[str, object] if not select_path else Model,
        }
        stream = send_args.get("stream", False)
        return self.api_client.response_deserialize(
            response, response_types_map, select_path, stream=stream
        )
