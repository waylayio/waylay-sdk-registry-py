# coding: utf-8
"""Waylay Function Registry models.

This code was generated from the OpenAPI documentation of 'Waylay Function Registry'

Generated by OpenAPI Generator (https://openapi-generator.tech)

Do not edit the class manually.

"""


from __future__ import annotations
from inspect import getfullargspec
import json
import pprint
import re  # noqa: F401

from typing import Optional
from pydantic import BaseModel, Field, StrictStr, ValidationError, field_validator
from ..models.batch import Batch
from ..models.build1 import Build1
from ..models.deploy1 import Deploy1
from ..models.scale1 import Scale1
from ..models.undeploy1 import Undeploy1
from ..models.verify1 import Verify1

from typing import Union, Any, List, TYPE_CHECKING, Optional, Dict
from typing_extensions import Literal
from pydantic import StrictStr, Field
try:
    from typing import Self
except ImportError:
    from typing_extensions import Self

ANYJOBSTATUSSUMMARY_ANY_OF_SCHEMAS = ["Batch", "Build1", "Deploy1", "Scale1", "Undeploy1", "Verify1"]


class AnyJobStatusSummary(BaseModel):
    """AnyJobStatusSummary."""

    # data type: Build1
    anyof_schema_1_validator: Optional[Build1] = None
    # data type: Deploy1
    anyof_schema_2_validator: Optional[Deploy1] = None
    # data type: Verify1
    anyof_schema_3_validator: Optional[Verify1] = None
    # data type: Undeploy1
    anyof_schema_4_validator: Optional[Undeploy1] = None
    # data type: Scale1
    anyof_schema_5_validator: Optional[Scale1] = None
    # data type: Batch
    anyof_schema_6_validator: Optional[Batch] = None
    if TYPE_CHECKING:
        actual_instance: Optional[Union[Batch, Build1, Deploy1, Scale1, Undeploy1, Verify1]] = None
    else:
        actual_instance: Any = None
    any_of_schemas: List[str] = ANYJOBSTATUSSUMMARY_ANY_OF_SCHEMAS

    model_config = {
        "validate_assignment": True,
        "protected_namespaces": (),
    }

    def __init__(self, *args, **kwargs) -> None:
        """Create a AnyJobStatusSummary model instance."""
        if args:
            if len(args) > 1:
                raise ValueError("If a position argument is used, only 1 is allowed to set `actual_instance`")
            if kwargs:
                raise ValueError("If a position argument is used, keyword arguments cannot be used.")
            super().__init__(actual_instance=args[0])
        else:
            super().__init__(**kwargs)

    @field_validator('actual_instance')
    @classmethod
    def actual_instance_must_validate_anyof(cls, v):
        """Validate the actual instance on deserialisation."""
        instance = AnyJobStatusSummary.model_construct()
        error_messages = []
        # validate data type: Build1
        if not isinstance(v, Build1):
            error_messages.append(f"Error! Input type `{type(v)}` is not `Build1`")
        else:
            return v

        # validate data type: Deploy1
        if not isinstance(v, Deploy1):
            error_messages.append(f"Error! Input type `{type(v)}` is not `Deploy1`")
        else:
            return v

        # validate data type: Verify1
        if not isinstance(v, Verify1):
            error_messages.append(f"Error! Input type `{type(v)}` is not `Verify1`")
        else:
            return v

        # validate data type: Undeploy1
        if not isinstance(v, Undeploy1):
            error_messages.append(f"Error! Input type `{type(v)}` is not `Undeploy1`")
        else:
            return v

        # validate data type: Scale1
        if not isinstance(v, Scale1):
            error_messages.append(f"Error! Input type `{type(v)}` is not `Scale1`")
        else:
            return v

        # validate data type: Batch
        if not isinstance(v, Batch):
            error_messages.append(f"Error! Input type `{type(v)}` is not `Batch`")
        else:
            return v

        if error_messages:
            # no match
            raise ValueError("No match found when setting the actual_instance in AnyJobStatusSummary with anyOf schemas: Batch, Build1, Deploy1, Scale1, Undeploy1, Verify1. Details: " + ", ".join(error_messages))
        else:
            return v

    @classmethod
    def from_dict(cls, obj: dict) -> Self:
        """Get a dict representation of an object."""
        return cls.from_json(json.dumps(obj, default=str))

    @classmethod
    def from_json(cls, json_str: str) -> Self:
        """Get the object represented by the JSON string."""
        instance = cls.model_construct()
        error_messages = []
        # anyof_schema_1_validator: Optional[Build1] = None
        try:
            instance.actual_instance = Build1.from_json(json_str)
            return instance
        except (ValidationError, ValueError) as e:
            error_messages.append(str(e))
        # anyof_schema_2_validator: Optional[Deploy1] = None
        try:
            instance.actual_instance = Deploy1.from_json(json_str)
            return instance
        except (ValidationError, ValueError) as e:
            error_messages.append(str(e))
        # anyof_schema_3_validator: Optional[Verify1] = None
        try:
            instance.actual_instance = Verify1.from_json(json_str)
            return instance
        except (ValidationError, ValueError) as e:
            error_messages.append(str(e))
        # anyof_schema_4_validator: Optional[Undeploy1] = None
        try:
            instance.actual_instance = Undeploy1.from_json(json_str)
            return instance
        except (ValidationError, ValueError) as e:
            error_messages.append(str(e))
        # anyof_schema_5_validator: Optional[Scale1] = None
        try:
            instance.actual_instance = Scale1.from_json(json_str)
            return instance
        except (ValidationError, ValueError) as e:
            error_messages.append(str(e))
        # anyof_schema_6_validator: Optional[Batch] = None
        try:
            instance.actual_instance = Batch.from_json(json_str)
            return instance
        except (ValidationError, ValueError) as e:
            error_messages.append(str(e))

        if error_messages:
            # no match
            raise ValueError("No match found when deserializing the JSON string into AnyJobStatusSummary with anyOf schemas: Batch, Build1, Deploy1, Scale1, Undeploy1, Verify1. Details: " + ", ".join(error_messages))
        else:
            return instance

    def to_json(self) -> str:
        """Get the JSON representation of the actual instance."""
        if self.actual_instance is None:
            return "null"

        to_json = getattr(self.actual_instance, "to_json", None)
        if callable(to_json):
            return self.actual_instance.to_json()  # type: ignore
        else:
            return json.dumps(self.actual_instance, default=str)

    def to_dict(self) -> Optional[Dict]:
        """Get the dict representation of the actual instance."""
        if self.actual_instance is None:
            return None

        to_dict = getattr(self.actual_instance, "to_dict", None)
        if callable(to_dict):
            return self.actual_instance.to_dict()  # type: ignore
        else:
            return json.dumps(self.actual_instance, default=str)  # type: ignore

    def to_str(self) -> str:
        """Get the string representation of the actual instance."""
        return pprint.pformat(self.model_dump())
