# coding: utf-8
"""Waylay Function Registry api tests.

This code was generated from the OpenAPI documentation of 'Waylay Function Registry'

Generated by OpenAPI Generator (https://openapi-generator.tech)

Do not edit the class manually.
"""


import pytest
from typing import Dict, List
from pytest_httpx import HTTPXMock
import json
from waylay.sdk import ApiClient, WaylayClient
from waylay.services.registry.api import PlugFunctionsApi
from waylay.services.registry.service import RegistryService


from ..types.multipart_file_upload_stub import MultipartFileUploadStub


from ..types.post_plug_job_sync_response_v2_stub import PostPlugJobSyncResponseV2Stub
from waylay.services.registry.models import PostPlugJobSyncResponseV2


from ..types.post_plug_job_sync_response_v2_stub import PostPlugJobSyncResponseV2Stub
from waylay.services.registry.models import PostPlugJobSyncResponseV2


from ..types.get_plug_response_v2_stub import GetPlugResponseV2Stub
from waylay.services.registry.models import GetPlugResponseV2


from ..types.get_plug_response_v2_stub import GetPlugResponseV2Stub
from waylay.services.registry.models import GetPlugResponseV2


from ..types.jobs_for_plug_response_v2_stub import JobsForPlugResponseV2Stub
from waylay.services.registry.models import JobsForPlugResponseV2


from ..types.latest_plugs_response_v2_stub import LatestPlugsResponseV2Stub
from waylay.services.registry.models import LatestPlugsResponseV2


from ..types.plug_versions_response_v2_stub import PlugVersionsResponseV2Stub
from waylay.services.registry.models import PlugVersionsResponseV2


from ..types.documentation_stub import DocumentationStub


from ..types.get_plug_response_v2_stub import GetPlugResponseV2Stub
from waylay.services.registry.models import GetPlugResponseV2


from ..types.update_metadata_request_v2_stub import UpdateMetadataRequestV2Stub


from ..types.get_plug_response_v2_stub import GetPlugResponseV2Stub
from waylay.services.registry.models import GetPlugResponseV2


from ..types.post_plug_job_sync_response_v2_stub import PostPlugJobSyncResponseV2Stub
from waylay.services.registry.models import PostPlugJobSyncResponseV2


from ..types.rebuild_plug_sync_response_v2_stub import RebuildPlugSyncResponseV2Stub
from waylay.services.registry.models import RebuildPlugSyncResponseV2


from ..types.undeployed_response_v2_stub import UndeployedResponseV2Stub
from waylay.services.registry.models import UndeployedResponseV2


from ..types.undeployed_response_v2_stub import UndeployedResponseV2Stub
from waylay.services.registry.models import UndeployedResponseV2


from ..types.file_upload_stub import FileUploadStub


from ..types.post_plug_job_sync_response_v2_stub import PostPlugJobSyncResponseV2Stub
from waylay.services.registry.models import PostPlugJobSyncResponseV2


from ..types.multipart_file_upload_stub import MultipartFileUploadStub


from ..types.post_plug_job_sync_response_v2_stub import PostPlugJobSyncResponseV2Stub
from waylay.services.registry.models import PostPlugJobSyncResponseV2


from ..types.verify_plug_sync_response_v2_stub import VerifyPlugSyncResponseV2Stub
from waylay.services.registry.models import VerifyPlugSyncResponseV2


# some mappings that are needed for some <example> interpolations
null, true, false = None, True, False


@pytest.fixture
def plug_functions_api(waylay_api_client: ApiClient) -> PlugFunctionsApi:
    return PlugFunctionsApi(waylay_api_client)


def test_registered(waylay_client: WaylayClient):
    """Test that PlugFunctionsApi api is registered in the sdk client."""
    assert isinstance(waylay_client.registry.plug_functions, PlugFunctionsApi)


@pytest.mark.asyncio
async def test_create(service: RegistryService, gateway_url: str, httpx_mock: HTTPXMock):
    """Test case for create
        Create Plug
    """
    # set path params
    # set files param
    files = {
        'myFile1': b'...first file content...',
        'myFile2': b'...second file content...',
    }

    mock_response = PostPlugJobSyncResponseV2Stub.create_instance().to_dict()
    httpx_mock_kwargs = {
        "method": "POST",
        "url": gateway_url + f"/registry/v2/plugs/",
        "content": json.dumps(mock_response, default=str),
        "status_code": 201,
    }
    httpx_mock.add_response(**httpx_mock_kwargs)
    kwargs = {
        'files': files,

    }
    resp = await service.plug_functions.create(**kwargs)
    assert isinstance(resp, PostPlugJobSyncResponseV2)


@pytest.mark.asyncio
async def test_delete_asset(service: RegistryService, gateway_url: str, httpx_mock: HTTPXMock):
    """Test case for delete_asset
        Delete Plug Asset
    """
    # set path params
    name = 'name_example'

    version = 'version_example'

    wildcard = 'wildcard_example'

    mock_response = PostPlugJobSyncResponseV2Stub.create_instance().to_dict()
    httpx_mock_kwargs = {
        "method": "DELETE",
        "url": gateway_url + f"/registry/v2/plugs/{name}/versions/{version}/content/{wildcard}",
        "content": json.dumps(mock_response, default=str),
        "status_code": 201,
    }
    httpx_mock.add_response(**httpx_mock_kwargs)
    kwargs = {
        'name': name,
        'version': version,
        'wildcard': wildcard,

    }
    resp = await service.plug_functions.delete_asset(**kwargs)
    assert isinstance(resp, PostPlugJobSyncResponseV2)


@pytest.mark.asyncio
async def test_get_archive(service: RegistryService, gateway_url: str, httpx_mock: HTTPXMock):
    """Test case for get_archive
        Get Plug Archive
    """
    # set path params
    name = 'name_example'

    version = 'version_example'

    mock_response = bytes(b'blah')
    httpx_mock_kwargs = {
        "method": "GET",
        "url": gateway_url + f"/registry/v2/plugs/{name}/versions/{version}/content",
        "content": json.dumps(mock_response, default=str),
        "status_code": 200,
    }
    httpx_mock.add_response(**httpx_mock_kwargs)
    kwargs = {
        'name': name,
        'version': version,

    }
    resp = await service.plug_functions.get_archive(**kwargs)
    assert isinstance(resp, bytes)


@pytest.mark.asyncio
async def test_get_asset(service: RegistryService, gateway_url: str, httpx_mock: HTTPXMock):
    """Test case for get_asset
        Get File From Plug Archive
    """
    # set path params
    name = 'name_example'

    version = 'version_example'

    wildcard = 'wildcard_example'

    mock_response = bytes(b'blah')
    httpx_mock_kwargs = {
        "method": "GET",
        "url": gateway_url + f"/registry/v2/plugs/{name}/versions/{version}/content/{wildcard}",
        "content": json.dumps(mock_response, default=str),
        "status_code": 200,
    }
    httpx_mock.add_response(**httpx_mock_kwargs)
    kwargs = {
        'name': name,
        'version': version,
        'wildcard': wildcard,

    }
    resp = await service.plug_functions.get_asset(**kwargs)
    assert isinstance(resp, bytes)


@pytest.mark.asyncio
async def test_get_latest_version(service: RegistryService, gateway_url: str, httpx_mock: HTTPXMock):
    """Test case for get_latest_version
        Get Latest Plug Version
    """
    # set path params
    name = 'name_example'

    mock_response = GetPlugResponseV2Stub.create_instance().to_dict()
    httpx_mock_kwargs = {
        "method": "GET",
        "url": gateway_url + f"/registry/v2/plugs/{name}",
        "content": json.dumps(mock_response, default=str),
        "status_code": 200,
    }
    httpx_mock.add_response(**httpx_mock_kwargs)
    kwargs = {
        'name': name,

    }
    resp = await service.plug_functions.get_latest_version(**kwargs)
    assert isinstance(resp, GetPlugResponseV2)


@pytest.mark.asyncio
async def test_get_version(service: RegistryService, gateway_url: str, httpx_mock: HTTPXMock):
    """Test case for get_version
        Get Plug Version
    """
    # set path params
    name = 'name_example'

    version = 'version_example'

    mock_response = GetPlugResponseV2Stub.create_instance().to_dict()
    httpx_mock_kwargs = {
        "method": "GET",
        "url": gateway_url + f"/registry/v2/plugs/{name}/versions/{version}",
        "content": json.dumps(mock_response, default=str),
        "status_code": 200,
    }
    httpx_mock.add_response(**httpx_mock_kwargs)
    kwargs = {
        'name': name,
        'version': version,

    }
    resp = await service.plug_functions.get_version(**kwargs)
    assert isinstance(resp, GetPlugResponseV2)


@pytest.mark.asyncio
async def test_jobs(service: RegistryService, gateway_url: str, httpx_mock: HTTPXMock):
    """Test case for jobs
        List Plug Jobs
    """
    # set path params
    name = 'name_example'

    version = 'version_example'

    mock_response = JobsForPlugResponseV2Stub.create_instance().to_dict()
    httpx_mock_kwargs = {
        "method": "GET",
        "url": gateway_url + f"/registry/v2/plugs/{name}/versions/{version}/jobs",
        "content": json.dumps(mock_response, default=str),
        "status_code": 200,
    }
    httpx_mock.add_response(**httpx_mock_kwargs)
    kwargs = {
        'name': name,
        'version': version,

    }
    resp = await service.plug_functions.jobs(**kwargs)
    assert isinstance(resp, JobsForPlugResponseV2)


@pytest.mark.asyncio
async def test_list_all(service: RegistryService, gateway_url: str, httpx_mock: HTTPXMock):
    """Test case for list_all
        List Plugs
    """
    # set path params

    mock_response = LatestPlugsResponseV2Stub.create_instance().to_dict()
    httpx_mock_kwargs = {
        "method": "GET",
        "url": gateway_url + f"/registry/v2/plugs/",
        "content": json.dumps(mock_response, default=str),
        "status_code": 200,
    }
    httpx_mock.add_response(**httpx_mock_kwargs)
    kwargs = {

    }
    resp = await service.plug_functions.list_all(**kwargs)
    assert isinstance(resp, LatestPlugsResponseV2)


@pytest.mark.asyncio
async def test_list_versions(service: RegistryService, gateway_url: str, httpx_mock: HTTPXMock):
    """Test case for list_versions
        List Plug Versions
    """
    # set path params
    name = 'name_example'

    mock_response = PlugVersionsResponseV2Stub.create_instance().to_dict()
    httpx_mock_kwargs = {
        "method": "GET",
        "url": gateway_url + f"/registry/v2/plugs/{name}/versions",
        "content": json.dumps(mock_response, default=str),
        "status_code": 200,
    }
    httpx_mock.add_response(**httpx_mock_kwargs)
    kwargs = {
        'name': name,

    }
    resp = await service.plug_functions.list_versions(**kwargs)
    assert isinstance(resp, PlugVersionsResponseV2)


@pytest.mark.asyncio
async def test_patch_interface(service: RegistryService, gateway_url: str, httpx_mock: HTTPXMock):
    """Test case for patch_interface
        Patch Plug Interface
    """
    # set path params
    name = 'name_example'

    version = 'version_example'

    # set body param
    body = DocumentationStub.create_instance()
    content_type = None
    # content_type = 'application/json'

    mock_response = GetPlugResponseV2Stub.create_instance().to_dict()
    httpx_mock_kwargs = {
        "method": "PATCH",
        "url": gateway_url + f"/registry/v2/plugs/{name}/versions/{version}/interface",
        "content": json.dumps(mock_response, default=str),
        "status_code": 200,
    }
    httpx_mock.add_response(**httpx_mock_kwargs)
    kwargs = {
        'name': name,
        'version': version,

        'body': body,
        '_headers': {'content-type': content_type} if content_type else None,

    }
    resp = await service.plug_functions.patch_interface(**kwargs)
    assert isinstance(resp, GetPlugResponseV2)


@pytest.mark.asyncio
async def test_patch_metadata(service: RegistryService, gateway_url: str, httpx_mock: HTTPXMock):
    """Test case for patch_metadata
        Patch Plug Metadata
    """
    # set path params
    name = 'name_example'

    version = 'version_example'

    # set body param
    body = UpdateMetadataRequestV2Stub.create_instance()
    content_type = None
    # content_type = 'application/json'

    mock_response = GetPlugResponseV2Stub.create_instance().to_dict()
    httpx_mock_kwargs = {
        "method": "PATCH",
        "url": gateway_url + f"/registry/v2/plugs/{name}/versions/{version}/metadata",
        "content": json.dumps(mock_response, default=str),
        "status_code": 200,
    }
    httpx_mock.add_response(**httpx_mock_kwargs)
    kwargs = {
        'name': name,
        'version': version,

        'body': body,
        '_headers': {'content-type': content_type} if content_type else None,

    }
    resp = await service.plug_functions.patch_metadata(**kwargs)
    assert isinstance(resp, GetPlugResponseV2)


@pytest.mark.asyncio
async def test_publish(service: RegistryService, gateway_url: str, httpx_mock: HTTPXMock):
    """Test case for publish
        Publish Draft Plug
    """
    # set path params
    name = 'name_example'

    version = 'version_example'

    mock_response = PostPlugJobSyncResponseV2Stub.create_instance().to_dict()
    httpx_mock_kwargs = {
        "method": "POST",
        "url": gateway_url + f"/registry/v2/plugs/{name}/versions/{version}/publish",
        "content": json.dumps(mock_response, default=str),
        "status_code": 201,
    }
    httpx_mock.add_response(**httpx_mock_kwargs)
    kwargs = {
        'name': name,
        'version': version,

    }
    resp = await service.plug_functions.publish(**kwargs)
    assert isinstance(resp, PostPlugJobSyncResponseV2)


@pytest.mark.asyncio
async def test_rebuild(service: RegistryService, gateway_url: str, httpx_mock: HTTPXMock):
    """Test case for rebuild
        Rebuild Plug
    """
    # set path params
    name = 'name_example'

    version = 'version_example'

    mock_response = RebuildPlugSyncResponseV2Stub.create_instance().to_dict()
    httpx_mock_kwargs = {
        "method": "POST",
        "url": gateway_url + f"/registry/v2/plugs/{name}/versions/{version}/rebuild",
        "content": json.dumps(mock_response, default=str),
        "status_code": 200,
    }
    httpx_mock.add_response(**httpx_mock_kwargs)
    kwargs = {
        'name': name,
        'version': version,

    }
    resp = await service.plug_functions.rebuild(**kwargs)
    assert isinstance(resp, RebuildPlugSyncResponseV2)


@pytest.mark.asyncio
async def test_remove_version(service: RegistryService, gateway_url: str, httpx_mock: HTTPXMock):
    """Test case for remove_version
        Remove Plug Version
    """
    # set path params
    name = 'name_example'

    version = 'version_example'

    mock_response = UndeployedResponseV2Stub.create_instance().to_dict()
    httpx_mock_kwargs = {
        "method": "DELETE",
        "url": gateway_url + f"/registry/v2/plugs/{name}/versions/{version}",
        "content": json.dumps(mock_response, default=str),
        "status_code": 200,
    }
    httpx_mock.add_response(**httpx_mock_kwargs)
    kwargs = {
        'name': name,
        'version': version,

    }
    resp = await service.plug_functions.remove_version(**kwargs)
    assert isinstance(resp, UndeployedResponseV2)


@pytest.mark.asyncio
async def test_remove_versions(service: RegistryService, gateway_url: str, httpx_mock: HTTPXMock):
    """Test case for remove_versions
        Remove Plug
    """
    # set path params
    name = 'name_example'

    mock_response = UndeployedResponseV2Stub.create_instance().to_dict()
    httpx_mock_kwargs = {
        "method": "DELETE",
        "url": gateway_url + f"/registry/v2/plugs/{name}",
        "content": json.dumps(mock_response, default=str),
        "status_code": 200,
    }
    httpx_mock.add_response(**httpx_mock_kwargs)
    kwargs = {
        'name': name,

    }
    resp = await service.plug_functions.remove_versions(**kwargs)
    assert isinstance(resp, UndeployedResponseV2)


@pytest.mark.asyncio
async def test_update_asset(service: RegistryService, gateway_url: str, httpx_mock: HTTPXMock):
    """Test case for update_asset
        Update Plug Asset
    """
    # set path params
    name = 'name_example'

    version = 'version_example'

    wildcard = 'wildcard_example'

    # set body param
    body = FileUploadStub.create_instance()
    content_type = None
    # content_type = 'application/octet-stream'

    mock_response = PostPlugJobSyncResponseV2Stub.create_instance().to_dict()
    httpx_mock_kwargs = {
        "method": "PUT",
        "url": gateway_url + f"/registry/v2/plugs/{name}/versions/{version}/content/{wildcard}",
        "content": json.dumps(mock_response, default=str),
        "status_code": 201,
    }
    httpx_mock.add_response(**httpx_mock_kwargs)
    kwargs = {
        'name': name,
        'version': version,
        'wildcard': wildcard,

        'body': body,
        '_headers': {'content-type': content_type} if content_type else None,

    }
    resp = await service.plug_functions.update_asset(**kwargs)
    assert isinstance(resp, PostPlugJobSyncResponseV2)


@pytest.mark.asyncio
async def test_update_assets(service: RegistryService, gateway_url: str, httpx_mock: HTTPXMock):
    """Test case for update_assets
        Update Plug Assets
    """
    # set path params
    name = 'name_example'

    version = 'version_example'

    # set files param
    files = {
        'myFile1': b'...first file content...',
        'myFile2': b'...second file content...',
    }

    mock_response = PostPlugJobSyncResponseV2Stub.create_instance().to_dict()
    httpx_mock_kwargs = {
        "method": "PUT",
        "url": gateway_url + f"/registry/v2/plugs/{name}/versions/{version}/content",
        "content": json.dumps(mock_response, default=str),
        "status_code": 201,
    }
    httpx_mock.add_response(**httpx_mock_kwargs)
    kwargs = {
        'name': name,
        'version': version,
        'files': files,

    }
    resp = await service.plug_functions.update_assets(**kwargs)
    assert isinstance(resp, PostPlugJobSyncResponseV2)


@pytest.mark.asyncio
async def test_verify(service: RegistryService, gateway_url: str, httpx_mock: HTTPXMock):
    """Test case for verify
        Verify Health Of Plug
    """
    # set path params
    name = 'name_example'

    version = 'version_example'

    mock_response = VerifyPlugSyncResponseV2Stub.create_instance().to_dict()
    httpx_mock_kwargs = {
        "method": "POST",
        "url": gateway_url + f"/registry/v2/plugs/{name}/versions/{version}/verify",
        "content": json.dumps(mock_response, default=str),
        "status_code": 200,
    }
    httpx_mock.add_response(**httpx_mock_kwargs)
    kwargs = {
        'name': name,
        'version': version,

    }
    resp = await service.plug_functions.verify(**kwargs)
    assert isinstance(resp, VerifyPlugSyncResponseV2)
