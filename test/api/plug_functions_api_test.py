# coding: utf-8
"""Waylay Function Registry api tests.

This code was generated from the OpenAPI documentation of 'Waylay Function Registry'

Generated by OpenAPI Generator (https://openapi-generator.tech)

Do not edit the class manually.
"""

import pytest
from typing import Dict, List, get_args, Union
from typeguard import check_type
from pytest_httpx import HTTPXMock
import json
import sys
import re
from unittest.mock import patch
from importlib import reload
from importlib.util import find_spec
from urllib.parse import quote

from waylay.sdk import ApiClient, WaylayClient
from waylay.sdk.api._models import Model
from waylay.services.registry.api import PlugFunctionsApi
from waylay.services.registry.service import RegistryService

from ..types.deprecate_previous_policy_stub import DeprecatePreviousPolicyStub

from ..types.semantic_version_range_stub import SemanticVersionRangeStub

from ..types.create_webscript_functions_copy_parameter_stub import (
    CreateWebscriptFunctionsCopyParameterStub,
)

from ..types.post_plug_job_sync_response_v2_stub import PostPlugJobSyncResponseV2Stub

from ..types.post_plug_job_async_response_v2_stub import PostPlugJobAsyncResponseV2Stub

from ..types.post_plug_job_sync_response_v2_stub import PostPlugJobSyncResponseV2Stub

from ..types.post_plug_job_async_response_v2_stub import PostPlugJobAsyncResponseV2Stub

from ..types.registry_error_response_stub import RegistryErrorResponseStub


from ..types.plug_type_stub import PlugTypeStub

from ..types.get_plug_response_v2_stub import GetPlugResponseV2Stub

from ..types.get_plug_response_v2_stub import GetPlugResponseV2Stub

from ..types.job_type_schema_stub import JobTypeSchemaStub


from ..types.job_state_result_stub import JobStateResultStub


from ..types.function_type_stub import FunctionTypeStub


from ..types.timestamp_spec_stub import TimestampSpecStub

from ..types.timestamp_spec_stub import TimestampSpecStub

from ..types.jobs_for_plug_response_v2_stub import JobsForPlugResponseV2Stub

from ..types.tags_filter_stub import TagsFilterStub

from ..types.plug_type_stub import PlugTypeStub


from ..types.status_filter_stub import StatusFilterStub


from ..types.semantic_version_range_stub import SemanticVersionRangeStub

from ..types.timestamp_spec_stub import TimestampSpecStub

from ..types.timestamp_spec_stub import TimestampSpecStub

from ..types.timestamp_spec_stub import TimestampSpecStub

from ..types.timestamp_spec_stub import TimestampSpecStub

from ..types.archive_format_stub import ArchiveFormatStub


from ..types.show_related_type_stub import ShowRelatedTypeStub

from ..types.latest_plugs_response_v2_stub import LatestPlugsResponseV2Stub

from ..types.tags_filter_stub import TagsFilterStub

from ..types.status_filter_stub import StatusFilterStub


from ..types.semantic_version_range_stub import SemanticVersionRangeStub

from ..types.timestamp_spec_stub import TimestampSpecStub

from ..types.timestamp_spec_stub import TimestampSpecStub

from ..types.timestamp_spec_stub import TimestampSpecStub

from ..types.timestamp_spec_stub import TimestampSpecStub

from ..types.archive_format_stub import ArchiveFormatStub


from ..types.plug_versions_response_v2_stub import PlugVersionsResponseV2Stub

from ..types.documentation_stub import DocumentationStub

from ..types.get_plug_response_v2_stub import GetPlugResponseV2Stub

from ..types.update_metadata_request_v2_stub import UpdateMetadataRequestV2Stub

from ..types.get_plug_response_v2_stub import GetPlugResponseV2Stub

from ..types.deprecate_previous_policy_stub import DeprecatePreviousPolicyStub

from ..types.post_plug_job_sync_response_v2_stub import PostPlugJobSyncResponseV2Stub

from ..types.post_plug_job_async_response_v2_stub import PostPlugJobAsyncResponseV2Stub

from ..types.rebuild_policy_stub import RebuildPolicyStub

from ..types.rebuild_plug_sync_response_v2_stub import RebuildPlugSyncResponseV2Stub

from ..types.rebuild_plug_async_response_v2_stub import RebuildPlugAsyncResponseV2Stub

from ..types.undeployed_response_v2_stub import UndeployedResponseV2Stub

from ..types.undeploy_submitted_response_v2_stub import UndeploySubmittedResponseV2Stub

from ..types.undeployed_response_v2_stub import UndeployedResponseV2Stub

from ..types.undeploy_submitted_response_v2_stub import UndeploySubmittedResponseV2Stub

from ..types.file_upload_stub import FileUploadStub

from ..types.post_plug_job_sync_response_v2_stub import PostPlugJobSyncResponseV2Stub

from ..types.post_plug_job_async_response_v2_stub import PostPlugJobAsyncResponseV2Stub

from ..types.registry_error_response_stub import RegistryErrorResponseStub

from ..types.post_plug_job_sync_response_v2_stub import PostPlugJobSyncResponseV2Stub

from ..types.post_plug_job_async_response_v2_stub import PostPlugJobAsyncResponseV2Stub

from ..types.registry_error_response_stub import RegistryErrorResponseStub

from ..types.verify_plug_sync_response_v2_stub import VerifyPlugSyncResponseV2Stub

from ..types.post_plug_job_async_response_v2_stub import PostPlugJobAsyncResponseV2Stub


try:
    from waylay.services.registry.queries.plug_functions_api import CreateQuery
    from waylay.services.registry.models import PostPlugJobSyncResponseV2

    from waylay.services.registry.models import PostPlugJobAsyncResponseV2

    from waylay.services.registry.queries.plug_functions_api import DeleteAssetQuery
    from waylay.services.registry.models import PostPlugJobSyncResponseV2

    from waylay.services.registry.models import PostPlugJobAsyncResponseV2

    from waylay.services.registry.models import RegistryErrorResponse

    from waylay.services.registry.queries.plug_functions_api import GetArchiveQuery

    from waylay.services.registry.queries.plug_functions_api import GetAssetQuery

    from waylay.services.registry.queries.plug_functions_api import GetLatestQuery
    from waylay.services.registry.models import GetPlugResponseV2

    from waylay.services.registry.models import GetPlugResponseV2

    from waylay.services.registry.queries.plug_functions_api import JobsQuery
    from waylay.services.registry.models import JobsForPlugResponseV2

    from waylay.services.registry.queries.plug_functions_api import ListQuery
    from waylay.services.registry.models import LatestPlugsResponseV2

    from waylay.services.registry.queries.plug_functions_api import ListVersionsQuery
    from waylay.services.registry.models import PlugVersionsResponseV2

    from waylay.services.registry.queries.plug_functions_api import PatchInterfaceQuery
    from waylay.services.registry.models import GetPlugResponseV2

    from waylay.services.registry.queries.plug_functions_api import PatchMetadataQuery
    from waylay.services.registry.models import GetPlugResponseV2

    from waylay.services.registry.queries.plug_functions_api import PublishQuery
    from waylay.services.registry.models import PostPlugJobSyncResponseV2

    from waylay.services.registry.models import PostPlugJobAsyncResponseV2

    from waylay.services.registry.queries.plug_functions_api import RebuildQuery
    from waylay.services.registry.models import RebuildPlugSyncResponseV2

    from waylay.services.registry.models import RebuildPlugAsyncResponseV2

    from waylay.services.registry.queries.plug_functions_api import RemoveVersionQuery
    from waylay.services.registry.models import UndeployedResponseV2

    from waylay.services.registry.models import UndeploySubmittedResponseV2

    from waylay.services.registry.queries.plug_functions_api import RemoveVersionsQuery
    from waylay.services.registry.models import UndeployedResponseV2

    from waylay.services.registry.models import UndeploySubmittedResponseV2

    from waylay.services.registry.queries.plug_functions_api import UpdateAssetQuery
    from waylay.services.registry.models import PostPlugJobSyncResponseV2

    from waylay.services.registry.models import PostPlugJobAsyncResponseV2

    from waylay.services.registry.models import RegistryErrorResponse

    from waylay.services.registry.queries.plug_functions_api import UpdateAssetsQuery
    from waylay.services.registry.models import PostPlugJobSyncResponseV2

    from waylay.services.registry.models import PostPlugJobAsyncResponseV2

    from waylay.services.registry.models import RegistryErrorResponse

    from waylay.services.registry.queries.plug_functions_api import VerifyQuery
    from waylay.services.registry.models import VerifyPlugSyncResponseV2

    from waylay.services.registry.models import PostPlugJobAsyncResponseV2

    MODELS_AVAILABLE = find_spec("waylay.services.registry.models") is not None
except ImportError:
    MODELS_AVAILABLE = False


# some mappings that are needed for some <example> interpolations
null, true, false = None, True, False


@pytest.fixture
def plug_functions_api(waylay_api_client: ApiClient) -> PlugFunctionsApi:
    return PlugFunctionsApi(waylay_api_client)


def test_registered(waylay_client: WaylayClient):
    """Test that PlugFunctionsApi api is registered in the sdk client."""
    assert isinstance(waylay_client.registry.plug_functions, PlugFunctionsApi)


def _create_set_mock_response(httpx_mock: HTTPXMock, gateway_url: str):
    mock_response = PostPlugJobSyncResponseV2Stub.create_json()
    httpx_mock_kwargs = {
        "method": "POST",
        "url": re.compile(f"^{gateway_url}/registry/v2/plugs/(\\?.*)?"),
        "content": json.dumps(mock_response, default=str),
        "status_code": 201,
    }
    httpx_mock.add_response(**httpx_mock_kwargs)


@pytest.mark.asyncio
@pytest.mark.skipif(not MODELS_AVAILABLE, reason="Types not installed.")
async def test_create(
    service: RegistryService, gateway_url: str, httpx_mock: HTTPXMock
):
    """Test case for create
    Create Plug
    """
    # set path params
    kwargs = {
        # optionally use CreateQuery to validate and reuse parameters
        "query": CreateQuery(
            author="author_example",
            comment="comment_example",
            deprecate_previous="none",
            dry_run=True,
            var_async=True,
            scale_to_zero=False,
            version=SemanticVersionRangeStub.create_json(),
            name="name_example",
            draft=False,
            runtime="runtime_example",
            copy_from=CreateWebscriptFunctionsCopyParameterStub.create_json(),
        ),
        "json": None,
        "content": b"some_binary_content",
        "headers": {"content-type": "application/octet-stream"},
        "files": {
            "myFile1": b"...first file content...",
            "myFile2": b"...second file content...",
        },
    }
    _create_set_mock_response(httpx_mock, gateway_url)
    resp = await service.plug_functions.create(**kwargs)
    check_type(
        resp,
        Union[
            PostPlugJobSyncResponseV2,
            PostPlugJobAsyncResponseV2,
        ],
    )


@pytest.mark.asyncio
@pytest.mark.skipif(MODELS_AVAILABLE, reason="Types installed.")
async def test_create_without_types(
    service: RegistryService, gateway_url: str, httpx_mock: HTTPXMock
):
    """Test case for create with models not installed
    Create Plug
    """
    # set path params
    kwargs = {
        "query": {
            "author": "author_example",
            "comment": "comment_example",
            "deprecatePrevious": "none",
            "dryRun": True,
            "async": True,
            "scaleToZero": False,
            "version": SemanticVersionRangeStub.create_json(),
            "name": "name_example",
            "draft": False,
            "runtime": "runtime_example",
            "copy": CreateWebscriptFunctionsCopyParameterStub.create_json(),
        },
        "files": {
            "myFile1": b"...first file content...",
            "myFile2": b"...second file content...",
        },
        "json": None,
        "content": b"some_binary_content",
        "headers": {"content-type": "application/octet-stream"},
    }
    _create_set_mock_response(httpx_mock, gateway_url)
    resp = await service.plug_functions.create(**kwargs)
    check_type(resp, Model)


def _delete_asset_set_mock_response(
    httpx_mock: HTTPXMock, gateway_url: str, name: str, version: str, wildcard: str
):
    mock_response = PostPlugJobSyncResponseV2Stub.create_json()
    httpx_mock_kwargs = {
        "method": "DELETE",
        "url": re.compile(
            f"^{gateway_url}/registry/v2/plugs/{name}/versions/{version}/content/{wildcard}(\\?.*)?"
        ),
        "content": json.dumps(mock_response, default=str),
        "status_code": 201,
    }
    httpx_mock.add_response(**httpx_mock_kwargs)


@pytest.mark.asyncio
@pytest.mark.skipif(not MODELS_AVAILABLE, reason="Types not installed.")
async def test_delete_asset(
    service: RegistryService, gateway_url: str, httpx_mock: HTTPXMock
):
    """Test case for delete_asset
    Delete Plug Asset
    """
    # set path params
    name = "name_example"

    version = "version_example"

    wildcard = "wildcard_example"

    kwargs = {
        # optionally use DeleteAssetQuery to validate and reuse parameters
        "query": DeleteAssetQuery(
            comment="comment_example",
            author="author_example",
            var_async=True,
            chown=False,
        ),
    }
    _delete_asset_set_mock_response(
        httpx_mock,
        gateway_url,
        quote(str(name)),
        quote(str(version)),
        quote(str(wildcard)),
    )
    resp = await service.plug_functions.delete_asset(name, version, wildcard, **kwargs)
    check_type(
        resp,
        Union[
            PostPlugJobSyncResponseV2,
            PostPlugJobAsyncResponseV2,
        ],
    )


@pytest.mark.asyncio
@pytest.mark.skipif(MODELS_AVAILABLE, reason="Types installed.")
async def test_delete_asset_without_types(
    service: RegistryService, gateway_url: str, httpx_mock: HTTPXMock
):
    """Test case for delete_asset with models not installed
    Delete Plug Asset
    """
    # set path params
    name = "name_example"

    version = "version_example"

    wildcard = "wildcard_example"

    kwargs = {
        "query": {
            "comment": "comment_example",
            "author": "author_example",
            "async": True,
            "chown": False,
        },
    }
    _delete_asset_set_mock_response(
        httpx_mock,
        gateway_url,
        quote(str(name)),
        quote(str(version)),
        quote(str(wildcard)),
    )
    resp = await service.plug_functions.delete_asset(name, version, wildcard, **kwargs)
    check_type(resp, Model)


def _get_archive_set_mock_response(
    httpx_mock: HTTPXMock, gateway_url: str, name: str, version: str
):
    mock_response = bytes(b"blah")
    httpx_mock_kwargs = {
        "method": "GET",
        "url": re.compile(
            f"^{gateway_url}/registry/v2/plugs/{name}/versions/{version}/content(\\?.*)?"
        ),
        "content": json.dumps(mock_response, default=str),
        "status_code": 200,
    }
    httpx_mock.add_response(**httpx_mock_kwargs)


@pytest.mark.asyncio
@pytest.mark.skipif(not MODELS_AVAILABLE, reason="Types not installed.")
async def test_get_archive(
    service: RegistryService, gateway_url: str, httpx_mock: HTTPXMock
):
    """Test case for get_archive
    Get Plug Archive
    """
    # set path params
    name = "name_example"

    version = "version_example"

    kwargs = {
        # optionally use GetArchiveQuery to validate and reuse parameters
        "query": GetArchiveQuery(
            ls=False,
        ),
    }
    _get_archive_set_mock_response(
        httpx_mock, gateway_url, quote(str(name)), quote(str(version))
    )
    resp = await service.plug_functions.get_archive(name, version, **kwargs)
    check_type(resp, bytes)


@pytest.mark.asyncio
@pytest.mark.skipif(MODELS_AVAILABLE, reason="Types installed.")
async def test_get_archive_without_types(
    service: RegistryService, gateway_url: str, httpx_mock: HTTPXMock
):
    """Test case for get_archive with models not installed
    Get Plug Archive
    """
    # set path params
    name = "name_example"

    version = "version_example"

    kwargs = {
        "query": {
            "ls": False,
        },
    }
    _get_archive_set_mock_response(
        httpx_mock, gateway_url, quote(str(name)), quote(str(version))
    )
    resp = await service.plug_functions.get_archive(name, version, **kwargs)
    check_type(resp, bytes)


def _get_asset_set_mock_response(
    httpx_mock: HTTPXMock, gateway_url: str, name: str, version: str, wildcard: str
):
    mock_response = bytes(b"blah")
    httpx_mock_kwargs = {
        "method": "GET",
        "url": re.compile(
            f"^{gateway_url}/registry/v2/plugs/{name}/versions/{version}/content/{wildcard}(\\?.*)?"
        ),
        "content": json.dumps(mock_response, default=str),
        "status_code": 200,
    }
    httpx_mock.add_response(**httpx_mock_kwargs)


@pytest.mark.asyncio
@pytest.mark.skipif(not MODELS_AVAILABLE, reason="Types not installed.")
async def test_get_asset(
    service: RegistryService, gateway_url: str, httpx_mock: HTTPXMock
):
    """Test case for get_asset
    Get File From Plug Archive
    """
    # set path params
    name = "name_example"

    version = "version_example"

    wildcard = "wildcard_example"

    kwargs = {
        # optionally use GetAssetQuery to validate and reuse parameters
        "query": GetAssetQuery(
            ls=False,
        ),
    }
    _get_asset_set_mock_response(
        httpx_mock,
        gateway_url,
        quote(str(name)),
        quote(str(version)),
        quote(str(wildcard)),
    )
    resp = await service.plug_functions.get_asset(name, version, wildcard, **kwargs)
    check_type(resp, bytes)


@pytest.mark.asyncio
@pytest.mark.skipif(MODELS_AVAILABLE, reason="Types installed.")
async def test_get_asset_without_types(
    service: RegistryService, gateway_url: str, httpx_mock: HTTPXMock
):
    """Test case for get_asset with models not installed
    Get File From Plug Archive
    """
    # set path params
    name = "name_example"

    version = "version_example"

    wildcard = "wildcard_example"

    kwargs = {
        "query": {
            "ls": False,
        },
    }
    _get_asset_set_mock_response(
        httpx_mock,
        gateway_url,
        quote(str(name)),
        quote(str(version)),
        quote(str(wildcard)),
    )
    resp = await service.plug_functions.get_asset(name, version, wildcard, **kwargs)
    check_type(resp, bytes)


def _get_latest_set_mock_response(httpx_mock: HTTPXMock, gateway_url: str, name: str):
    mock_response = GetPlugResponseV2Stub.create_json()
    httpx_mock_kwargs = {
        "method": "GET",
        "url": re.compile(f"^{gateway_url}/registry/v2/plugs/{name}(\\?.*)?"),
        "content": json.dumps(mock_response, default=str),
        "status_code": 200,
    }
    httpx_mock.add_response(**httpx_mock_kwargs)


@pytest.mark.asyncio
@pytest.mark.skipif(not MODELS_AVAILABLE, reason="Types not installed.")
async def test_get_latest(
    service: RegistryService, gateway_url: str, httpx_mock: HTTPXMock
):
    """Test case for get_latest
    Get Latest Plug Version
    """
    # set path params
    name = "name_example"

    kwargs = {
        # optionally use GetLatestQuery to validate and reuse parameters
        "query": GetLatestQuery(
            type="sensor",
            include_draft=True,
            include_deprecated=True,
        ),
    }
    _get_latest_set_mock_response(httpx_mock, gateway_url, quote(str(name)))
    resp = await service.plug_functions.get_latest(name, **kwargs)
    check_type(resp, Union[GetPlugResponseV2,])


@pytest.mark.asyncio
@pytest.mark.skipif(MODELS_AVAILABLE, reason="Types installed.")
async def test_get_latest_without_types(
    service: RegistryService, gateway_url: str, httpx_mock: HTTPXMock
):
    """Test case for get_latest with models not installed
    Get Latest Plug Version
    """
    # set path params
    name = "name_example"

    kwargs = {
        "query": {
            "type": "sensor",
            "includeDraft": True,
            "includeDeprecated": True,
        },
    }
    _get_latest_set_mock_response(httpx_mock, gateway_url, quote(str(name)))
    resp = await service.plug_functions.get_latest(name, **kwargs)
    check_type(resp, Model)


def _get_set_mock_response(
    httpx_mock: HTTPXMock, gateway_url: str, name: str, version: str
):
    mock_response = GetPlugResponseV2Stub.create_json()
    httpx_mock_kwargs = {
        "method": "GET",
        "url": re.compile(
            f"^{gateway_url}/registry/v2/plugs/{name}/versions/{version}(\\?.*)?"
        ),
        "content": json.dumps(mock_response, default=str),
        "status_code": 200,
    }
    httpx_mock.add_response(**httpx_mock_kwargs)


@pytest.mark.asyncio
@pytest.mark.skipif(not MODELS_AVAILABLE, reason="Types not installed.")
async def test_get(service: RegistryService, gateway_url: str, httpx_mock: HTTPXMock):
    """Test case for get
    Get Plug Version
    """
    # set path params
    name = "name_example"

    version = "version_example"

    kwargs = {}
    _get_set_mock_response(
        httpx_mock, gateway_url, quote(str(name)), quote(str(version))
    )
    resp = await service.plug_functions.get(name, version, **kwargs)
    check_type(resp, Union[GetPlugResponseV2,])


@pytest.mark.asyncio
@pytest.mark.skipif(MODELS_AVAILABLE, reason="Types installed.")
async def test_get_without_types(
    service: RegistryService, gateway_url: str, httpx_mock: HTTPXMock
):
    """Test case for get with models not installed
    Get Plug Version
    """
    # set path params
    name = "name_example"

    version = "version_example"

    kwargs = {}
    _get_set_mock_response(
        httpx_mock, gateway_url, quote(str(name)), quote(str(version))
    )
    resp = await service.plug_functions.get(name, version, **kwargs)
    check_type(resp, Model)


def _jobs_set_mock_response(
    httpx_mock: HTTPXMock, gateway_url: str, name: str, version: str
):
    mock_response = JobsForPlugResponseV2Stub.create_json()
    httpx_mock_kwargs = {
        "method": "GET",
        "url": re.compile(
            f"^{gateway_url}/registry/v2/plugs/{name}/versions/{version}/jobs(\\?.*)?"
        ),
        "content": json.dumps(mock_response, default=str),
        "status_code": 200,
    }
    httpx_mock.add_response(**httpx_mock_kwargs)


@pytest.mark.asyncio
@pytest.mark.skipif(not MODELS_AVAILABLE, reason="Types not installed.")
async def test_jobs(service: RegistryService, gateway_url: str, httpx_mock: HTTPXMock):
    """Test case for jobs
    List Plug Jobs
    """
    # set path params
    name = "name_example"

    version = "version_example"

    kwargs = {
        # optionally use JobsQuery to validate and reuse parameters
        "query": JobsQuery(
            limit=3.4,
            type=[],
            state=[],
            function_type=[],
            created_before=TimestampSpecStub.create_json(),
            created_after=TimestampSpecStub.create_json(),
        ),
    }
    _jobs_set_mock_response(
        httpx_mock, gateway_url, quote(str(name)), quote(str(version))
    )
    resp = await service.plug_functions.jobs(name, version, **kwargs)
    check_type(resp, Union[JobsForPlugResponseV2,])


@pytest.mark.asyncio
@pytest.mark.skipif(MODELS_AVAILABLE, reason="Types installed.")
async def test_jobs_without_types(
    service: RegistryService, gateway_url: str, httpx_mock: HTTPXMock
):
    """Test case for jobs with models not installed
    List Plug Jobs
    """
    # set path params
    name = "name_example"

    version = "version_example"

    kwargs = {
        "query": {
            "limit": 3.4,
            "type": [],
            "state": [],
            "functionType": [],
            "createdBefore": TimestampSpecStub.create_json(),
            "createdAfter": TimestampSpecStub.create_json(),
        },
    }
    _jobs_set_mock_response(
        httpx_mock, gateway_url, quote(str(name)), quote(str(version))
    )
    resp = await service.plug_functions.jobs(name, version, **kwargs)
    check_type(resp, Model)


def _list_set_mock_response(httpx_mock: HTTPXMock, gateway_url: str):
    mock_response = LatestPlugsResponseV2Stub.create_json()
    httpx_mock_kwargs = {
        "method": "GET",
        "url": re.compile(f"^{gateway_url}/registry/v2/plugs/(\\?.*)?"),
        "content": json.dumps(mock_response, default=str),
        "status_code": 200,
    }
    httpx_mock.add_response(**httpx_mock_kwargs)


@pytest.mark.asyncio
@pytest.mark.skipif(not MODELS_AVAILABLE, reason="Types not installed.")
async def test_list(service: RegistryService, gateway_url: str, httpx_mock: HTTPXMock):
    """Test case for list
    List Plugs
    """
    # set path params
    kwargs = {
        # optionally use ListQuery to validate and reuse parameters
        "query": ListQuery(
            tags=TagsFilterStub.create_json(),
            type="sensor",
            limit=3.4,
            page=3.4,
            include_draft=True,
            include_deprecated=True,
            deprecated=True,
            draft=True,
            name_version=[],
            version="version_example",
            status=[],
            runtime_version=SemanticVersionRangeStub.create_json(),
            created_by="@me",
            updated_by="@me",
            created_before=TimestampSpecStub.create_json(),
            created_after=TimestampSpecStub.create_json(),
            updated_before=TimestampSpecStub.create_json(),
            updated_after=TimestampSpecStub.create_json(),
            name="name_example",
            archive_format=[],
            runtime=[],
            latest=True,
            show_related="embed",
        ),
    }
    _list_set_mock_response(httpx_mock, gateway_url)
    resp = await service.plug_functions.list(**kwargs)
    check_type(resp, Union[LatestPlugsResponseV2,])


@pytest.mark.asyncio
@pytest.mark.skipif(MODELS_AVAILABLE, reason="Types installed.")
async def test_list_without_types(
    service: RegistryService, gateway_url: str, httpx_mock: HTTPXMock
):
    """Test case for list with models not installed
    List Plugs
    """
    # set path params
    kwargs = {
        "query": {
            "tags": TagsFilterStub.create_json(),
            "type": "sensor",
            "limit": 3.4,
            "page": 3.4,
            "includeDraft": True,
            "includeDeprecated": True,
            "deprecated": True,
            "draft": True,
            "nameVersion": [],
            "version": "version_example",
            "status": [],
            "runtimeVersion": SemanticVersionRangeStub.create_json(),
            "createdBy": "@me",
            "updatedBy": "@me",
            "createdBefore": TimestampSpecStub.create_json(),
            "createdAfter": TimestampSpecStub.create_json(),
            "updatedBefore": TimestampSpecStub.create_json(),
            "updatedAfter": TimestampSpecStub.create_json(),
            "name": "name_example",
            "archiveFormat": [],
            "runtime": [],
            "latest": True,
            "showRelated": "embed",
        },
    }
    _list_set_mock_response(httpx_mock, gateway_url)
    resp = await service.plug_functions.list(**kwargs)
    check_type(resp, Model)


def _list_versions_set_mock_response(
    httpx_mock: HTTPXMock, gateway_url: str, name: str
):
    mock_response = PlugVersionsResponseV2Stub.create_json()
    httpx_mock_kwargs = {
        "method": "GET",
        "url": re.compile(f"^{gateway_url}/registry/v2/plugs/{name}/versions(\\?.*)?"),
        "content": json.dumps(mock_response, default=str),
        "status_code": 200,
    }
    httpx_mock.add_response(**httpx_mock_kwargs)


@pytest.mark.asyncio
@pytest.mark.skipif(not MODELS_AVAILABLE, reason="Types not installed.")
async def test_list_versions(
    service: RegistryService, gateway_url: str, httpx_mock: HTTPXMock
):
    """Test case for list_versions
    List Plug Versions
    """
    # set path params
    name = "name_example"

    kwargs = {
        # optionally use ListVersionsQuery to validate and reuse parameters
        "query": ListVersionsQuery(
            tags=TagsFilterStub.create_json(),
            limit=3.4,
            page=3.4,
            deprecated=True,
            draft=True,
            version="version_example",
            status=[],
            runtime_version=SemanticVersionRangeStub.create_json(),
            created_by="@me",
            updated_by="@me",
            created_before=TimestampSpecStub.create_json(),
            created_after=TimestampSpecStub.create_json(),
            updated_before=TimestampSpecStub.create_json(),
            updated_after=TimestampSpecStub.create_json(),
            archive_format=[],
            runtime=[],
        ),
    }
    _list_versions_set_mock_response(httpx_mock, gateway_url, quote(str(name)))
    resp = await service.plug_functions.list_versions(name, **kwargs)
    check_type(resp, Union[PlugVersionsResponseV2,])


@pytest.mark.asyncio
@pytest.mark.skipif(MODELS_AVAILABLE, reason="Types installed.")
async def test_list_versions_without_types(
    service: RegistryService, gateway_url: str, httpx_mock: HTTPXMock
):
    """Test case for list_versions with models not installed
    List Plug Versions
    """
    # set path params
    name = "name_example"

    kwargs = {
        "query": {
            "tags": TagsFilterStub.create_json(),
            "limit": 3.4,
            "page": 3.4,
            "deprecated": True,
            "draft": True,
            "version": "version_example",
            "status": [],
            "runtimeVersion": SemanticVersionRangeStub.create_json(),
            "createdBy": "@me",
            "updatedBy": "@me",
            "createdBefore": TimestampSpecStub.create_json(),
            "createdAfter": TimestampSpecStub.create_json(),
            "updatedBefore": TimestampSpecStub.create_json(),
            "updatedAfter": TimestampSpecStub.create_json(),
            "archiveFormat": [],
            "runtime": [],
        },
    }
    _list_versions_set_mock_response(httpx_mock, gateway_url, quote(str(name)))
    resp = await service.plug_functions.list_versions(name, **kwargs)
    check_type(resp, Model)


def _patch_interface_set_mock_response(
    httpx_mock: HTTPXMock, gateway_url: str, name: str, version: str
):
    mock_response = GetPlugResponseV2Stub.create_json()
    httpx_mock_kwargs = {
        "method": "PATCH",
        "url": re.compile(
            f"^{gateway_url}/registry/v2/plugs/{name}/versions/{version}/interface(\\?.*)?"
        ),
        "content": json.dumps(mock_response, default=str),
        "status_code": 200,
    }
    httpx_mock.add_response(**httpx_mock_kwargs)


@pytest.mark.asyncio
@pytest.mark.skipif(not MODELS_AVAILABLE, reason="Types not installed.")
async def test_patch_interface(
    service: RegistryService, gateway_url: str, httpx_mock: HTTPXMock
):
    """Test case for patch_interface
    Patch Plug Interface
    """
    # set path params
    name = "name_example"

    version = "version_example"

    kwargs = {
        # optionally use PatchInterfaceQuery to validate and reuse parameters
        "query": PatchInterfaceQuery(
            comment="comment_example",
        ),
        "json": DocumentationStub.create_instance(),
    }
    _patch_interface_set_mock_response(
        httpx_mock, gateway_url, quote(str(name)), quote(str(version))
    )
    resp = await service.plug_functions.patch_interface(name, version, **kwargs)
    check_type(resp, Union[GetPlugResponseV2,])


@pytest.mark.asyncio
@pytest.mark.skipif(MODELS_AVAILABLE, reason="Types installed.")
async def test_patch_interface_without_types(
    service: RegistryService, gateway_url: str, httpx_mock: HTTPXMock
):
    """Test case for patch_interface with models not installed
    Patch Plug Interface
    """
    # set path params
    name = "name_example"

    version = "version_example"

    kwargs = {
        "query": {
            "comment": "comment_example",
        },
        "json": DocumentationStub.create_json(),
    }
    _patch_interface_set_mock_response(
        httpx_mock, gateway_url, quote(str(name)), quote(str(version))
    )
    resp = await service.plug_functions.patch_interface(name, version, **kwargs)
    check_type(resp, Model)


def _patch_metadata_set_mock_response(
    httpx_mock: HTTPXMock, gateway_url: str, name: str, version: str
):
    mock_response = GetPlugResponseV2Stub.create_json()
    httpx_mock_kwargs = {
        "method": "PATCH",
        "url": re.compile(
            f"^{gateway_url}/registry/v2/plugs/{name}/versions/{version}/metadata(\\?.*)?"
        ),
        "content": json.dumps(mock_response, default=str),
        "status_code": 200,
    }
    httpx_mock.add_response(**httpx_mock_kwargs)


@pytest.mark.asyncio
@pytest.mark.skipif(not MODELS_AVAILABLE, reason="Types not installed.")
async def test_patch_metadata(
    service: RegistryService, gateway_url: str, httpx_mock: HTTPXMock
):
    """Test case for patch_metadata
    Patch Plug Metadata
    """
    # set path params
    name = "name_example"

    version = "version_example"

    kwargs = {
        # optionally use PatchMetadataQuery to validate and reuse parameters
        "query": PatchMetadataQuery(
            comment="comment_example",
        ),
        "json": UpdateMetadataRequestV2Stub.create_instance(),
    }
    _patch_metadata_set_mock_response(
        httpx_mock, gateway_url, quote(str(name)), quote(str(version))
    )
    resp = await service.plug_functions.patch_metadata(name, version, **kwargs)
    check_type(resp, Union[GetPlugResponseV2,])


@pytest.mark.asyncio
@pytest.mark.skipif(MODELS_AVAILABLE, reason="Types installed.")
async def test_patch_metadata_without_types(
    service: RegistryService, gateway_url: str, httpx_mock: HTTPXMock
):
    """Test case for patch_metadata with models not installed
    Patch Plug Metadata
    """
    # set path params
    name = "name_example"

    version = "version_example"

    kwargs = {
        "query": {
            "comment": "comment_example",
        },
        "json": UpdateMetadataRequestV2Stub.create_json(),
    }
    _patch_metadata_set_mock_response(
        httpx_mock, gateway_url, quote(str(name)), quote(str(version))
    )
    resp = await service.plug_functions.patch_metadata(name, version, **kwargs)
    check_type(resp, Model)


def _publish_set_mock_response(
    httpx_mock: HTTPXMock, gateway_url: str, name: str, version: str
):
    mock_response = PostPlugJobSyncResponseV2Stub.create_json()
    httpx_mock_kwargs = {
        "method": "POST",
        "url": re.compile(
            f"^{gateway_url}/registry/v2/plugs/{name}/versions/{version}/publish(\\?.*)?"
        ),
        "content": json.dumps(mock_response, default=str),
        "status_code": 201,
    }
    httpx_mock.add_response(**httpx_mock_kwargs)


@pytest.mark.asyncio
@pytest.mark.skipif(not MODELS_AVAILABLE, reason="Types not installed.")
async def test_publish(
    service: RegistryService, gateway_url: str, httpx_mock: HTTPXMock
):
    """Test case for publish
    Publish Draft Plug
    """
    # set path params
    name = "name_example"

    version = "version_example"

    kwargs = {
        # optionally use PublishQuery to validate and reuse parameters
        "query": PublishQuery(
            comment="comment_example",
            author="author_example",
            deprecate_previous="none",
            var_async=True,
        ),
    }
    _publish_set_mock_response(
        httpx_mock, gateway_url, quote(str(name)), quote(str(version))
    )
    resp = await service.plug_functions.publish(name, version, **kwargs)
    check_type(
        resp,
        Union[
            PostPlugJobSyncResponseV2,
            PostPlugJobAsyncResponseV2,
        ],
    )


@pytest.mark.asyncio
@pytest.mark.skipif(MODELS_AVAILABLE, reason="Types installed.")
async def test_publish_without_types(
    service: RegistryService, gateway_url: str, httpx_mock: HTTPXMock
):
    """Test case for publish with models not installed
    Publish Draft Plug
    """
    # set path params
    name = "name_example"

    version = "version_example"

    kwargs = {
        "query": {
            "comment": "comment_example",
            "author": "author_example",
            "deprecatePrevious": "none",
            "async": True,
        },
    }
    _publish_set_mock_response(
        httpx_mock, gateway_url, quote(str(name)), quote(str(version))
    )
    resp = await service.plug_functions.publish(name, version, **kwargs)
    check_type(resp, Model)


def _rebuild_set_mock_response(
    httpx_mock: HTTPXMock, gateway_url: str, name: str, version: str
):
    mock_response = RebuildPlugSyncResponseV2Stub.create_json()
    httpx_mock_kwargs = {
        "method": "POST",
        "url": re.compile(
            f"^{gateway_url}/registry/v2/plugs/{name}/versions/{version}/rebuild(\\?.*)?"
        ),
        "content": json.dumps(mock_response, default=str),
        "status_code": 200,
    }
    httpx_mock.add_response(**httpx_mock_kwargs)


@pytest.mark.asyncio
@pytest.mark.skipif(not MODELS_AVAILABLE, reason="Types not installed.")
async def test_rebuild(
    service: RegistryService, gateway_url: str, httpx_mock: HTTPXMock
):
    """Test case for rebuild
    Rebuild Plug
    """
    # set path params
    name = "name_example"

    version = "version_example"

    kwargs = {
        # optionally use RebuildQuery to validate and reuse parameters
        "query": RebuildQuery(
            comment="comment_example",
            dry_run=True,
            var_async=True,
            upgrade="patch",
            force_version="force_version_example",
            ignore_checks=True,
            scale_to_zero=True,
            skip_rebuild=True,
        ),
    }
    _rebuild_set_mock_response(
        httpx_mock, gateway_url, quote(str(name)), quote(str(version))
    )
    resp = await service.plug_functions.rebuild(name, version, **kwargs)
    check_type(
        resp,
        Union[
            RebuildPlugSyncResponseV2,
            RebuildPlugAsyncResponseV2,
        ],
    )


@pytest.mark.asyncio
@pytest.mark.skipif(MODELS_AVAILABLE, reason="Types installed.")
async def test_rebuild_without_types(
    service: RegistryService, gateway_url: str, httpx_mock: HTTPXMock
):
    """Test case for rebuild with models not installed
    Rebuild Plug
    """
    # set path params
    name = "name_example"

    version = "version_example"

    kwargs = {
        "query": {
            "comment": "comment_example",
            "dryRun": True,
            "async": True,
            "upgrade": "patch",
            "forceVersion": "force_version_example",
            "ignoreChecks": True,
            "scaleToZero": True,
            "skipRebuild": True,
        },
    }
    _rebuild_set_mock_response(
        httpx_mock, gateway_url, quote(str(name)), quote(str(version))
    )
    resp = await service.plug_functions.rebuild(name, version, **kwargs)
    check_type(resp, Model)


def _remove_version_set_mock_response(
    httpx_mock: HTTPXMock, gateway_url: str, name: str, version: str
):
    mock_response = UndeployedResponseV2Stub.create_json()
    httpx_mock_kwargs = {
        "method": "DELETE",
        "url": re.compile(
            f"^{gateway_url}/registry/v2/plugs/{name}/versions/{version}(\\?.*)?"
        ),
        "content": json.dumps(mock_response, default=str),
        "status_code": 200,
    }
    httpx_mock.add_response(**httpx_mock_kwargs)


@pytest.mark.asyncio
@pytest.mark.skipif(not MODELS_AVAILABLE, reason="Types not installed.")
async def test_remove_version(
    service: RegistryService, gateway_url: str, httpx_mock: HTTPXMock
):
    """Test case for remove_version
    Remove Plug Version
    """
    # set path params
    name = "name_example"

    version = "version_example"

    kwargs = {
        # optionally use RemoveVersionQuery to validate and reuse parameters
        "query": RemoveVersionQuery(
            comment="comment_example",
            var_async=True,
            force=True,
            undeploy=True,
        ),
    }
    _remove_version_set_mock_response(
        httpx_mock, gateway_url, quote(str(name)), quote(str(version))
    )
    resp = await service.plug_functions.remove_version(name, version, **kwargs)
    check_type(
        resp,
        Union[
            UndeployedResponseV2,
            UndeploySubmittedResponseV2,
        ],
    )


@pytest.mark.asyncio
@pytest.mark.skipif(MODELS_AVAILABLE, reason="Types installed.")
async def test_remove_version_without_types(
    service: RegistryService, gateway_url: str, httpx_mock: HTTPXMock
):
    """Test case for remove_version with models not installed
    Remove Plug Version
    """
    # set path params
    name = "name_example"

    version = "version_example"

    kwargs = {
        "query": {
            "comment": "comment_example",
            "async": True,
            "force": True,
            "undeploy": True,
        },
    }
    _remove_version_set_mock_response(
        httpx_mock, gateway_url, quote(str(name)), quote(str(version))
    )
    resp = await service.plug_functions.remove_version(name, version, **kwargs)
    check_type(resp, Model)


def _remove_versions_set_mock_response(
    httpx_mock: HTTPXMock, gateway_url: str, name: str
):
    mock_response = UndeployedResponseV2Stub.create_json()
    httpx_mock_kwargs = {
        "method": "DELETE",
        "url": re.compile(f"^{gateway_url}/registry/v2/plugs/{name}(\\?.*)?"),
        "content": json.dumps(mock_response, default=str),
        "status_code": 200,
    }
    httpx_mock.add_response(**httpx_mock_kwargs)


@pytest.mark.asyncio
@pytest.mark.skipif(not MODELS_AVAILABLE, reason="Types not installed.")
async def test_remove_versions(
    service: RegistryService, gateway_url: str, httpx_mock: HTTPXMock
):
    """Test case for remove_versions
    Remove Plug
    """
    # set path params
    name = "name_example"

    kwargs = {
        # optionally use RemoveVersionsQuery to validate and reuse parameters
        "query": RemoveVersionsQuery(
            comment="comment_example",
            var_async=True,
            force=True,
            undeploy=True,
        ),
    }
    _remove_versions_set_mock_response(httpx_mock, gateway_url, quote(str(name)))
    resp = await service.plug_functions.remove_versions(name, **kwargs)
    check_type(
        resp,
        Union[
            UndeployedResponseV2,
            UndeploySubmittedResponseV2,
        ],
    )


@pytest.mark.asyncio
@pytest.mark.skipif(MODELS_AVAILABLE, reason="Types installed.")
async def test_remove_versions_without_types(
    service: RegistryService, gateway_url: str, httpx_mock: HTTPXMock
):
    """Test case for remove_versions with models not installed
    Remove Plug
    """
    # set path params
    name = "name_example"

    kwargs = {
        "query": {
            "comment": "comment_example",
            "async": True,
            "force": True,
            "undeploy": True,
        },
    }
    _remove_versions_set_mock_response(httpx_mock, gateway_url, quote(str(name)))
    resp = await service.plug_functions.remove_versions(name, **kwargs)
    check_type(resp, Model)


def _update_asset_set_mock_response(
    httpx_mock: HTTPXMock, gateway_url: str, name: str, version: str, wildcard: str
):
    mock_response = PostPlugJobSyncResponseV2Stub.create_json()
    httpx_mock_kwargs = {
        "method": "PUT",
        "url": re.compile(
            f"^{gateway_url}/registry/v2/plugs/{name}/versions/{version}/content/{wildcard}(\\?.*)?"
        ),
        "content": json.dumps(mock_response, default=str),
        "status_code": 201,
    }
    httpx_mock.add_response(**httpx_mock_kwargs)


@pytest.mark.asyncio
@pytest.mark.skipif(not MODELS_AVAILABLE, reason="Types not installed.")
async def test_update_asset(
    service: RegistryService, gateway_url: str, httpx_mock: HTTPXMock
):
    """Test case for update_asset
    Update Plug Asset
    """
    # set path params
    name = "name_example"

    version = "version_example"

    wildcard = "wildcard_example"

    kwargs = {
        # optionally use UpdateAssetQuery to validate and reuse parameters
        "query": UpdateAssetQuery(
            comment="comment_example",
            author="author_example",
            var_async=True,
            chown=False,
        ),
        "content": b"some_binary_content",
        "headers": {"content-type": "application/octet-stream"},
    }
    _update_asset_set_mock_response(
        httpx_mock,
        gateway_url,
        quote(str(name)),
        quote(str(version)),
        quote(str(wildcard)),
    )
    resp = await service.plug_functions.update_asset(name, version, wildcard, **kwargs)
    check_type(
        resp,
        Union[
            PostPlugJobSyncResponseV2,
            PostPlugJobAsyncResponseV2,
        ],
    )


@pytest.mark.asyncio
@pytest.mark.skipif(MODELS_AVAILABLE, reason="Types installed.")
async def test_update_asset_without_types(
    service: RegistryService, gateway_url: str, httpx_mock: HTTPXMock
):
    """Test case for update_asset with models not installed
    Update Plug Asset
    """
    # set path params
    name = "name_example"

    version = "version_example"

    wildcard = "wildcard_example"

    kwargs = {
        "query": {
            "comment": "comment_example",
            "author": "author_example",
            "async": True,
            "chown": False,
        },
        "content": b"some_binary_content",
        "headers": {"content-type": "application/octet-stream"},
    }
    _update_asset_set_mock_response(
        httpx_mock,
        gateway_url,
        quote(str(name)),
        quote(str(version)),
        quote(str(wildcard)),
    )
    resp = await service.plug_functions.update_asset(name, version, wildcard, **kwargs)
    check_type(resp, Model)


def _update_assets_set_mock_response(
    httpx_mock: HTTPXMock, gateway_url: str, name: str, version: str
):
    mock_response = PostPlugJobSyncResponseV2Stub.create_json()
    httpx_mock_kwargs = {
        "method": "PUT",
        "url": re.compile(
            f"^{gateway_url}/registry/v2/plugs/{name}/versions/{version}/content(\\?.*)?"
        ),
        "content": json.dumps(mock_response, default=str),
        "status_code": 201,
    }
    httpx_mock.add_response(**httpx_mock_kwargs)


@pytest.mark.asyncio
@pytest.mark.skipif(not MODELS_AVAILABLE, reason="Types not installed.")
async def test_update_assets(
    service: RegistryService, gateway_url: str, httpx_mock: HTTPXMock
):
    """Test case for update_assets
    Update Plug Assets
    """
    # set path params
    name = "name_example"

    version = "version_example"

    kwargs = {
        # optionally use UpdateAssetsQuery to validate and reuse parameters
        "query": UpdateAssetsQuery(
            comment="comment_example",
            author="author_example",
            var_async=True,
            chown=False,
        ),
        "content": b"some_binary_content",
        "headers": {"content-type": "application/octet-stream"},
        "files": {
            "myFile1": b"...first file content...",
            "myFile2": b"...second file content...",
        },
    }
    _update_assets_set_mock_response(
        httpx_mock, gateway_url, quote(str(name)), quote(str(version))
    )
    resp = await service.plug_functions.update_assets(name, version, **kwargs)
    check_type(
        resp,
        Union[
            PostPlugJobSyncResponseV2,
            PostPlugJobAsyncResponseV2,
        ],
    )


@pytest.mark.asyncio
@pytest.mark.skipif(MODELS_AVAILABLE, reason="Types installed.")
async def test_update_assets_without_types(
    service: RegistryService, gateway_url: str, httpx_mock: HTTPXMock
):
    """Test case for update_assets with models not installed
    Update Plug Assets
    """
    # set path params
    name = "name_example"

    version = "version_example"

    kwargs = {
        "query": {
            "comment": "comment_example",
            "author": "author_example",
            "async": True,
            "chown": False,
        },
        "files": {
            "myFile1": b"...first file content...",
            "myFile2": b"...second file content...",
        },
        "content": b"some_binary_content",
        "headers": {"content-type": "application/octet-stream"},
    }
    _update_assets_set_mock_response(
        httpx_mock, gateway_url, quote(str(name)), quote(str(version))
    )
    resp = await service.plug_functions.update_assets(name, version, **kwargs)
    check_type(resp, Model)


def _verify_set_mock_response(
    httpx_mock: HTTPXMock, gateway_url: str, name: str, version: str
):
    mock_response = VerifyPlugSyncResponseV2Stub.create_json()
    httpx_mock_kwargs = {
        "method": "POST",
        "url": re.compile(
            f"^{gateway_url}/registry/v2/plugs/{name}/versions/{version}/verify(\\?.*)?"
        ),
        "content": json.dumps(mock_response, default=str),
        "status_code": 200,
    }
    httpx_mock.add_response(**httpx_mock_kwargs)


@pytest.mark.asyncio
@pytest.mark.skipif(not MODELS_AVAILABLE, reason="Types not installed.")
async def test_verify(
    service: RegistryService, gateway_url: str, httpx_mock: HTTPXMock
):
    """Test case for verify
    Verify Health Of Plug
    """
    # set path params
    name = "name_example"

    version = "version_example"

    kwargs = {
        # optionally use VerifyQuery to validate and reuse parameters
        "query": VerifyQuery(
            var_async=True,
            scale_to_zero=True,
        ),
    }
    _verify_set_mock_response(
        httpx_mock, gateway_url, quote(str(name)), quote(str(version))
    )
    resp = await service.plug_functions.verify(name, version, **kwargs)
    check_type(
        resp,
        Union[
            VerifyPlugSyncResponseV2,
            PostPlugJobAsyncResponseV2,
        ],
    )


@pytest.mark.asyncio
@pytest.mark.skipif(MODELS_AVAILABLE, reason="Types installed.")
async def test_verify_without_types(
    service: RegistryService, gateway_url: str, httpx_mock: HTTPXMock
):
    """Test case for verify with models not installed
    Verify Health Of Plug
    """
    # set path params
    name = "name_example"

    version = "version_example"

    kwargs = {
        "query": {
            "async": True,
            "scaleToZero": True,
        },
    }
    _verify_set_mock_response(
        httpx_mock, gateway_url, quote(str(name)), quote(str(version))
    )
    resp = await service.plug_functions.verify(name, version, **kwargs)
    check_type(resp, Model)
