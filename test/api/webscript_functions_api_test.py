# coding: utf-8
"""Waylay Function Registry api tests.

This code was generated from the OpenAPI documentation of 'Waylay Function Registry'

Generated by OpenAPI Generator (https://openapi-generator.tech)

Do not edit the class manually.
"""

import pytest
from typeguard import check_type
from pytest_httpx import HTTPXMock
import json
import re
from importlib.util import find_spec
from urllib.parse import quote

from waylay.sdk import ApiClient, WaylayClient
from waylay.sdk.api._models import Model
from waylay.services.registry.api import WebscriptFunctionsApi
from waylay.services.registry.service import RegistryService


from ..types.semantic_version_range_stub import SemanticVersionRangeStub


from ..types.post_webscript_job_sync_response_v2_stub import (
    PostWebscriptJobSyncResponseV2Stub,
)

from ..types.post_webscript_job_sync_response_v2_stub import (
    PostWebscriptJobSyncResponseV2Stub,
)


from ..types.get_webscript_response_v2_stub import GetWebscriptResponseV2Stub

from ..types.get_webscript_response_v2_stub import GetWebscriptResponseV2Stub


from ..types.timestamp_spec_stub import TimestampSpecStub

from ..types.timestamp_spec_stub import TimestampSpecStub

from ..types.jobs_for_webscript_response_v2_stub import JobsForWebscriptResponseV2Stub


from ..types.semantic_version_range_stub import SemanticVersionRangeStub

from ..types.timestamp_spec_stub import TimestampSpecStub

from ..types.timestamp_spec_stub import TimestampSpecStub

from ..types.timestamp_spec_stub import TimestampSpecStub

from ..types.timestamp_spec_stub import TimestampSpecStub


from ..types.webscript_versions_response_v2_stub import WebscriptVersionsResponseV2Stub


from ..types.semantic_version_range_stub import SemanticVersionRangeStub

from ..types.timestamp_spec_stub import TimestampSpecStub

from ..types.timestamp_spec_stub import TimestampSpecStub

from ..types.timestamp_spec_stub import TimestampSpecStub

from ..types.timestamp_spec_stub import TimestampSpecStub


from ..types.latest_webscripts_response_v2_stub import LatestWebscriptsResponseV2Stub

from ..types.function_meta_stub import FunctionMetaStub

from ..types.get_webscript_response_v2_stub import GetWebscriptResponseV2Stub


from ..types.post_webscript_job_sync_response_v2_stub import (
    PostWebscriptJobSyncResponseV2Stub,
)


from ..types.rebuild_webscript_sync_response_v2_stub import (
    RebuildWebscriptSyncResponseV2Stub,
)

from ..types.undeployed_response_v2_stub import UndeployedResponseV2Stub

from ..types.undeployed_response_v2_stub import UndeployedResponseV2Stub


from ..types.post_webscript_job_sync_response_v2_stub import (
    PostWebscriptJobSyncResponseV2Stub,
)


from ..types.post_webscript_job_sync_response_v2_stub import (
    PostWebscriptJobSyncResponseV2Stub,
)

from ..types.verify_webscript_sync_response_v2_stub import (
    VerifyWebscriptSyncResponseV2Stub,
)


try:
    from waylay.services.registry.models import PostWebscriptJobSyncResponseV2
    from waylay.services.registry.models import PostWebscriptJobSyncResponseV2

    from waylay.services.registry.models import GetWebscriptResponseV2
    from waylay.services.registry.models import GetWebscriptResponseV2
    from waylay.services.registry.models import JobsForWebscriptResponseV2
    from waylay.services.registry.models import WebscriptVersionsResponseV2
    from waylay.services.registry.models import LatestWebscriptsResponseV2
    from waylay.services.registry.models import GetWebscriptResponseV2
    from waylay.services.registry.models import PostWebscriptJobSyncResponseV2
    from waylay.services.registry.models import RebuildWebscriptSyncResponseV2
    from waylay.services.registry.models import UndeployedResponseV2
    from waylay.services.registry.models import UndeployedResponseV2
    from waylay.services.registry.models import PostWebscriptJobSyncResponseV2
    from waylay.services.registry.models import PostWebscriptJobSyncResponseV2
    from waylay.services.registry.models import VerifyWebscriptSyncResponseV2

    MODELS_AVAILABLE = find_spec("waylay.services.registry.models") is not None
except ImportError:
    MODELS_AVAILABLE = False


# some mappings that are needed for some <example> interpolations
null, true, false = None, True, False


@pytest.fixture
def webscript_functions_api(waylay_api_client: ApiClient) -> WebscriptFunctionsApi:
    return WebscriptFunctionsApi(waylay_api_client)


def test_registered(waylay_client: WaylayClient):
    """Test that WebscriptFunctionsApi api is registered in the sdk client."""
    assert isinstance(waylay_client.registry.webscript_functions, WebscriptFunctionsApi)


def _create_set_mock_response(httpx_mock: HTTPXMock, gateway_url: str):
    mock_response = PostWebscriptJobSyncResponseV2Stub.create_json()
    httpx_mock_kwargs = {
        "method": "POST",
        "url": re.compile(f"^{gateway_url}/registry/v2/webscripts/(\\?.*)?"),
        "content": json.dumps(mock_response, default=str),
        "status_code": 201,
    }
    httpx_mock.add_response(**httpx_mock_kwargs)


@pytest.mark.asyncio
@pytest.mark.skipif(not MODELS_AVAILABLE, reason="Types not installed.")
async def test_create(
    service: RegistryService, gateway_url: str, httpx_mock: HTTPXMock
):
    """Test case for create
    Create Webscript Version
    """
    # set path params
    kwargs = {
        "query": {
            "deprecatePrevious": "none",
            "dryRun": True,
            "async": True,
            "scaleToZero": False,
            "version": SemanticVersionRangeStub.create_json(),
            "name": "name_example",
            "draft": False,
        },
        "content": b"some_binary_content",
        "headers": {"content-type": "application/octet-stream"},
        "files": {
            "myFile1": b"...first file content...",
            "myFile2": b"...second file content...",
        },
    }
    _create_set_mock_response(httpx_mock, gateway_url)
    resp = await service.webscript_functions.create(**kwargs)
    check_type(resp, PostWebscriptJobSyncResponseV2)


@pytest.mark.asyncio
@pytest.mark.skipif(MODELS_AVAILABLE, reason="Types installed.")
async def test_create_without_types(
    service: RegistryService, gateway_url: str, httpx_mock: HTTPXMock
):
    """Test case for create with models not installed
    Create Webscript Version
    """
    # set path params
    kwargs = {
        "query": {
            "deprecatePrevious": "none",
            "dryRun": True,
            "async": True,
            "scaleToZero": False,
            "version": SemanticVersionRangeStub.create_json(),
            "name": "name_example",
            "draft": False,
        },
        "files": {
            "myFile1": b"...first file content...",
            "myFile2": b"...second file content...",
        },
        "content": b"some_binary_content",
        "headers": {"content-type": "application/octet-stream"},
    }
    _create_set_mock_response(httpx_mock, gateway_url)
    resp = await service.webscript_functions.create(**kwargs)
    check_type(resp, Model)


def _delete_asset_set_mock_response(
    httpx_mock: HTTPXMock, gateway_url: str, name: str, version: str, wildcard: str
):
    mock_response = PostWebscriptJobSyncResponseV2Stub.create_json()
    httpx_mock_kwargs = {
        "method": "DELETE",
        "url": re.compile(
            f"^{gateway_url}/registry/v2/webscripts/{name}/versions/{version}/content/{wildcard}(\\?.*)?"
        ),
        "content": json.dumps(mock_response, default=str),
        "status_code": 201,
    }
    httpx_mock.add_response(**httpx_mock_kwargs)


@pytest.mark.asyncio
@pytest.mark.skipif(not MODELS_AVAILABLE, reason="Types not installed.")
async def test_delete_asset(
    service: RegistryService, gateway_url: str, httpx_mock: HTTPXMock
):
    """Test case for delete_asset
    Delete Webscript Asset
    """
    # set path params
    name = "name_example"

    version = "version_example"

    wildcard = "wildcard_example"

    kwargs = {
        "query": {
            "comment": "comment_example",
            "async": True,
            "chown": False,
        },
    }
    _delete_asset_set_mock_response(
        httpx_mock,
        gateway_url,
        quote(str(name)),
        quote(str(version)),
        quote(str(wildcard)),
    )
    resp = await service.webscript_functions.delete_asset(
        name, version, wildcard, **kwargs
    )
    check_type(resp, PostWebscriptJobSyncResponseV2)


@pytest.mark.asyncio
@pytest.mark.skipif(MODELS_AVAILABLE, reason="Types installed.")
async def test_delete_asset_without_types(
    service: RegistryService, gateway_url: str, httpx_mock: HTTPXMock
):
    """Test case for delete_asset with models not installed
    Delete Webscript Asset
    """
    # set path params
    name = "name_example"

    version = "version_example"

    wildcard = "wildcard_example"

    kwargs = {
        "query": {
            "comment": "comment_example",
            "async": True,
            "chown": False,
        },
    }
    _delete_asset_set_mock_response(
        httpx_mock,
        gateway_url,
        quote(str(name)),
        quote(str(version)),
        quote(str(wildcard)),
    )
    resp = await service.webscript_functions.delete_asset(
        name, version, wildcard, **kwargs
    )
    check_type(resp, Model)


def _get_archive_set_mock_response(
    httpx_mock: HTTPXMock, gateway_url: str, name: str, version: str
):
    mock_response = bytes(b"blah")
    httpx_mock_kwargs = {
        "method": "GET",
        "url": re.compile(
            f"^{gateway_url}/registry/v2/webscripts/{name}/versions/{version}/content(\\?.*)?"
        ),
        "content": json.dumps(mock_response, default=str),
        "status_code": 200,
    }
    httpx_mock.add_response(**httpx_mock_kwargs)


@pytest.mark.asyncio
@pytest.mark.skipif(not MODELS_AVAILABLE, reason="Types not installed.")
async def test_get_archive(
    service: RegistryService, gateway_url: str, httpx_mock: HTTPXMock
):
    """Test case for get_archive
    Get Webscript Archive
    """
    # set path params
    name = "name_example"

    version = "version_example"

    kwargs = {
        "query": {
            "ls": False,
        },
    }
    _get_archive_set_mock_response(
        httpx_mock, gateway_url, quote(str(name)), quote(str(version))
    )
    resp = await service.webscript_functions.get_archive(name, version, **kwargs)
    check_type(resp, bytes)


@pytest.mark.asyncio
@pytest.mark.skipif(MODELS_AVAILABLE, reason="Types installed.")
async def test_get_archive_without_types(
    service: RegistryService, gateway_url: str, httpx_mock: HTTPXMock
):
    """Test case for get_archive with models not installed
    Get Webscript Archive
    """
    # set path params
    name = "name_example"

    version = "version_example"

    kwargs = {
        "query": {
            "ls": False,
        },
    }
    _get_archive_set_mock_response(
        httpx_mock, gateway_url, quote(str(name)), quote(str(version))
    )
    resp = await service.webscript_functions.get_archive(name, version, **kwargs)
    check_type(resp, bytes)


def _get_asset_set_mock_response(
    httpx_mock: HTTPXMock, gateway_url: str, name: str, version: str, wildcard: str
):
    mock_response = bytes(b"blah")
    httpx_mock_kwargs = {
        "method": "GET",
        "url": re.compile(
            f"^{gateway_url}/registry/v2/webscripts/{name}/versions/{version}/content/{wildcard}(\\?.*)?"
        ),
        "content": json.dumps(mock_response, default=str),
        "status_code": 200,
    }
    httpx_mock.add_response(**httpx_mock_kwargs)


@pytest.mark.asyncio
@pytest.mark.skipif(not MODELS_AVAILABLE, reason="Types not installed.")
async def test_get_asset(
    service: RegistryService, gateway_url: str, httpx_mock: HTTPXMock
):
    """Test case for get_asset
    Get File From Webscript Archive
    """
    # set path params
    name = "name_example"

    version = "version_example"

    wildcard = "wildcard_example"

    kwargs = {
        "query": {
            "ls": False,
        },
    }
    _get_asset_set_mock_response(
        httpx_mock,
        gateway_url,
        quote(str(name)),
        quote(str(version)),
        quote(str(wildcard)),
    )
    resp = await service.webscript_functions.get_asset(
        name, version, wildcard, **kwargs
    )
    check_type(resp, bytes)


@pytest.mark.asyncio
@pytest.mark.skipif(MODELS_AVAILABLE, reason="Types installed.")
async def test_get_asset_without_types(
    service: RegistryService, gateway_url: str, httpx_mock: HTTPXMock
):
    """Test case for get_asset with models not installed
    Get File From Webscript Archive
    """
    # set path params
    name = "name_example"

    version = "version_example"

    wildcard = "wildcard_example"

    kwargs = {
        "query": {
            "ls": False,
        },
    }
    _get_asset_set_mock_response(
        httpx_mock,
        gateway_url,
        quote(str(name)),
        quote(str(version)),
        quote(str(wildcard)),
    )
    resp = await service.webscript_functions.get_asset(
        name, version, wildcard, **kwargs
    )
    check_type(resp, bytes)


def _get_latest_set_mock_response(httpx_mock: HTTPXMock, gateway_url: str, name: str):
    mock_response = GetWebscriptResponseV2Stub.create_json()
    httpx_mock_kwargs = {
        "method": "GET",
        "url": re.compile(f"^{gateway_url}/registry/v2/webscripts/{name}(\\?.*)?"),
        "content": json.dumps(mock_response, default=str),
        "status_code": 200,
    }
    httpx_mock.add_response(**httpx_mock_kwargs)


@pytest.mark.asyncio
@pytest.mark.skipif(not MODELS_AVAILABLE, reason="Types not installed.")
async def test_get_latest(
    service: RegistryService, gateway_url: str, httpx_mock: HTTPXMock
):
    """Test case for get_latest
    Get Latest Webscript Version
    """
    # set path params
    name = "name_example"

    kwargs = {
        "query": {
            "includeDraft": True,
            "includeDeprecated": True,
        },
    }
    _get_latest_set_mock_response(httpx_mock, gateway_url, quote(str(name)))
    resp = await service.webscript_functions.get_latest(name, **kwargs)
    check_type(resp, GetWebscriptResponseV2)


@pytest.mark.asyncio
@pytest.mark.skipif(MODELS_AVAILABLE, reason="Types installed.")
async def test_get_latest_without_types(
    service: RegistryService, gateway_url: str, httpx_mock: HTTPXMock
):
    """Test case for get_latest with models not installed
    Get Latest Webscript Version
    """
    # set path params
    name = "name_example"

    kwargs = {
        "query": {
            "includeDraft": True,
            "includeDeprecated": True,
        },
    }
    _get_latest_set_mock_response(httpx_mock, gateway_url, quote(str(name)))
    resp = await service.webscript_functions.get_latest(name, **kwargs)
    check_type(resp, Model)


def _get_set_mock_response(
    httpx_mock: HTTPXMock, gateway_url: str, name: str, version: str
):
    mock_response = GetWebscriptResponseV2Stub.create_json()
    httpx_mock_kwargs = {
        "method": "GET",
        "url": re.compile(
            f"^{gateway_url}/registry/v2/webscripts/{name}/versions/{version}(\\?.*)?"
        ),
        "content": json.dumps(mock_response, default=str),
        "status_code": 200,
    }
    httpx_mock.add_response(**httpx_mock_kwargs)


@pytest.mark.asyncio
@pytest.mark.skipif(not MODELS_AVAILABLE, reason="Types not installed.")
async def test_get(service: RegistryService, gateway_url: str, httpx_mock: HTTPXMock):
    """Test case for get
    Get Webscript Version
    """
    # set path params
    name = "name_example"

    version = "version_example"

    kwargs = {}
    _get_set_mock_response(
        httpx_mock, gateway_url, quote(str(name)), quote(str(version))
    )
    resp = await service.webscript_functions.get(name, version, **kwargs)
    check_type(resp, GetWebscriptResponseV2)


@pytest.mark.asyncio
@pytest.mark.skipif(MODELS_AVAILABLE, reason="Types installed.")
async def test_get_without_types(
    service: RegistryService, gateway_url: str, httpx_mock: HTTPXMock
):
    """Test case for get with models not installed
    Get Webscript Version
    """
    # set path params
    name = "name_example"

    version = "version_example"

    kwargs = {}
    _get_set_mock_response(
        httpx_mock, gateway_url, quote(str(name)), quote(str(version))
    )
    resp = await service.webscript_functions.get(name, version, **kwargs)
    check_type(resp, Model)


def _jobs_set_mock_response(
    httpx_mock: HTTPXMock, gateway_url: str, name: str, version: str
):
    mock_response = JobsForWebscriptResponseV2Stub.create_json()
    httpx_mock_kwargs = {
        "method": "GET",
        "url": re.compile(
            f"^{gateway_url}/registry/v2/webscripts/{name}/versions/{version}/jobs(\\?.*)?"
        ),
        "content": json.dumps(mock_response, default=str),
        "status_code": 200,
    }
    httpx_mock.add_response(**httpx_mock_kwargs)


@pytest.mark.asyncio
@pytest.mark.skipif(not MODELS_AVAILABLE, reason="Types not installed.")
async def test_jobs(service: RegistryService, gateway_url: str, httpx_mock: HTTPXMock):
    """Test case for jobs
    List Webscript Jobs
    """
    # set path params
    name = "name_example"

    version = "version_example"

    kwargs = {
        "query": {
            "limit": 3.4,
            "type": [],
            "state": [],
            "functionType": [],
            "createdBefore": TimestampSpecStub.create_json(),
            "createdAfter": TimestampSpecStub.create_json(),
        },
    }
    _jobs_set_mock_response(
        httpx_mock, gateway_url, quote(str(name)), quote(str(version))
    )
    resp = await service.webscript_functions.jobs(name, version, **kwargs)
    check_type(resp, JobsForWebscriptResponseV2)


@pytest.mark.asyncio
@pytest.mark.skipif(MODELS_AVAILABLE, reason="Types installed.")
async def test_jobs_without_types(
    service: RegistryService, gateway_url: str, httpx_mock: HTTPXMock
):
    """Test case for jobs with models not installed
    List Webscript Jobs
    """
    # set path params
    name = "name_example"

    version = "version_example"

    kwargs = {
        "query": {
            "limit": 3.4,
            "type": [],
            "state": [],
            "functionType": [],
            "createdBefore": TimestampSpecStub.create_json(),
            "createdAfter": TimestampSpecStub.create_json(),
        },
    }
    _jobs_set_mock_response(
        httpx_mock, gateway_url, quote(str(name)), quote(str(version))
    )
    resp = await service.webscript_functions.jobs(name, version, **kwargs)
    check_type(resp, Model)


def _list_versions_set_mock_response(
    httpx_mock: HTTPXMock, gateway_url: str, name: str
):
    mock_response = WebscriptVersionsResponseV2Stub.create_json()
    httpx_mock_kwargs = {
        "method": "GET",
        "url": re.compile(
            f"^{gateway_url}/registry/v2/webscripts/{name}/versions(\\?.*)?"
        ),
        "content": json.dumps(mock_response, default=str),
        "status_code": 200,
    }
    httpx_mock.add_response(**httpx_mock_kwargs)


@pytest.mark.asyncio
@pytest.mark.skipif(not MODELS_AVAILABLE, reason="Types not installed.")
async def test_list_versions(
    service: RegistryService, gateway_url: str, httpx_mock: HTTPXMock
):
    """Test case for list_versions
    List Webscript Versions
    """
    # set path params
    name = "name_example"

    kwargs = {
        "query": {
            "limit": 3.4,
            "page": 3.4,
            "deprecated": True,
            "draft": True,
            "version": "version_example",
            "status": [],
            "runtimeVersion": SemanticVersionRangeStub.create_json(),
            "createdBy": "@me",
            "updatedBy": "@me",
            "createdBefore": TimestampSpecStub.create_json(),
            "createdAfter": TimestampSpecStub.create_json(),
            "updatedBefore": TimestampSpecStub.create_json(),
            "updatedAfter": TimestampSpecStub.create_json(),
            "archiveFormat": [],
            "runtime": [],
        },
    }
    _list_versions_set_mock_response(httpx_mock, gateway_url, quote(str(name)))
    resp = await service.webscript_functions.list_versions(name, **kwargs)
    check_type(resp, WebscriptVersionsResponseV2)


@pytest.mark.asyncio
@pytest.mark.skipif(MODELS_AVAILABLE, reason="Types installed.")
async def test_list_versions_without_types(
    service: RegistryService, gateway_url: str, httpx_mock: HTTPXMock
):
    """Test case for list_versions with models not installed
    List Webscript Versions
    """
    # set path params
    name = "name_example"

    kwargs = {
        "query": {
            "limit": 3.4,
            "page": 3.4,
            "deprecated": True,
            "draft": True,
            "version": "version_example",
            "status": [],
            "runtimeVersion": SemanticVersionRangeStub.create_json(),
            "createdBy": "@me",
            "updatedBy": "@me",
            "createdBefore": TimestampSpecStub.create_json(),
            "createdAfter": TimestampSpecStub.create_json(),
            "updatedBefore": TimestampSpecStub.create_json(),
            "updatedAfter": TimestampSpecStub.create_json(),
            "archiveFormat": [],
            "runtime": [],
        },
    }
    _list_versions_set_mock_response(httpx_mock, gateway_url, quote(str(name)))
    resp = await service.webscript_functions.list_versions(name, **kwargs)
    check_type(resp, Model)


def _list_set_mock_response(httpx_mock: HTTPXMock, gateway_url: str):
    mock_response = LatestWebscriptsResponseV2Stub.create_json()
    httpx_mock_kwargs = {
        "method": "GET",
        "url": re.compile(f"^{gateway_url}/registry/v2/webscripts/(\\?.*)?"),
        "content": json.dumps(mock_response, default=str),
        "status_code": 200,
    }
    httpx_mock.add_response(**httpx_mock_kwargs)


@pytest.mark.asyncio
@pytest.mark.skipif(not MODELS_AVAILABLE, reason="Types not installed.")
async def test_list(service: RegistryService, gateway_url: str, httpx_mock: HTTPXMock):
    """Test case for list
    List Webscripts
    """
    # set path params
    kwargs = {
        "query": {
            "limit": 3.4,
            "page": 3.4,
            "includeDraft": True,
            "includeDeprecated": True,
            "deprecated": True,
            "draft": True,
            "nameVersion": [],
            "version": "version_example",
            "status": [],
            "runtimeVersion": SemanticVersionRangeStub.create_json(),
            "createdBy": "@me",
            "updatedBy": "@me",
            "createdBefore": TimestampSpecStub.create_json(),
            "createdAfter": TimestampSpecStub.create_json(),
            "updatedBefore": TimestampSpecStub.create_json(),
            "updatedAfter": TimestampSpecStub.create_json(),
            "name": "name_example",
            "archiveFormat": [],
            "runtime": [],
            "latest": True,
        },
    }
    _list_set_mock_response(httpx_mock, gateway_url)
    resp = await service.webscript_functions.list(**kwargs)
    check_type(resp, LatestWebscriptsResponseV2)


@pytest.mark.asyncio
@pytest.mark.skipif(MODELS_AVAILABLE, reason="Types installed.")
async def test_list_without_types(
    service: RegistryService, gateway_url: str, httpx_mock: HTTPXMock
):
    """Test case for list with models not installed
    List Webscripts
    """
    # set path params
    kwargs = {
        "query": {
            "limit": 3.4,
            "page": 3.4,
            "includeDraft": True,
            "includeDeprecated": True,
            "deprecated": True,
            "draft": True,
            "nameVersion": [],
            "version": "version_example",
            "status": [],
            "runtimeVersion": SemanticVersionRangeStub.create_json(),
            "createdBy": "@me",
            "updatedBy": "@me",
            "createdBefore": TimestampSpecStub.create_json(),
            "createdAfter": TimestampSpecStub.create_json(),
            "updatedBefore": TimestampSpecStub.create_json(),
            "updatedAfter": TimestampSpecStub.create_json(),
            "name": "name_example",
            "archiveFormat": [],
            "runtime": [],
            "latest": True,
        },
    }
    _list_set_mock_response(httpx_mock, gateway_url)
    resp = await service.webscript_functions.list(**kwargs)
    check_type(resp, Model)


def _patch_metadata_set_mock_response(
    httpx_mock: HTTPXMock, gateway_url: str, name: str, version: str
):
    mock_response = GetWebscriptResponseV2Stub.create_json()
    httpx_mock_kwargs = {
        "method": "PATCH",
        "url": re.compile(
            f"^{gateway_url}/registry/v2/webscripts/{name}/versions/{version}/metadata(\\?.*)?"
        ),
        "content": json.dumps(mock_response, default=str),
        "status_code": 200,
    }
    httpx_mock.add_response(**httpx_mock_kwargs)


@pytest.mark.asyncio
@pytest.mark.skipif(not MODELS_AVAILABLE, reason="Types not installed.")
async def test_patch_metadata(
    service: RegistryService, gateway_url: str, httpx_mock: HTTPXMock
):
    """Test case for patch_metadata
    Patch Webscript Metadata
    """
    # set path params
    name = "name_example"

    version = "version_example"

    kwargs = {
        "query": {
            "comment": "comment_example",
        },
        "json": FunctionMetaStub.create_instance(),
    }
    _patch_metadata_set_mock_response(
        httpx_mock, gateway_url, quote(str(name)), quote(str(version))
    )
    resp = await service.webscript_functions.patch_metadata(name, version, **kwargs)
    check_type(resp, GetWebscriptResponseV2)


@pytest.mark.asyncio
@pytest.mark.skipif(MODELS_AVAILABLE, reason="Types installed.")
async def test_patch_metadata_without_types(
    service: RegistryService, gateway_url: str, httpx_mock: HTTPXMock
):
    """Test case for patch_metadata with models not installed
    Patch Webscript Metadata
    """
    # set path params
    name = "name_example"

    version = "version_example"

    kwargs = {
        "query": {
            "comment": "comment_example",
        },
        "json": FunctionMetaStub.create_json(),
    }
    _patch_metadata_set_mock_response(
        httpx_mock, gateway_url, quote(str(name)), quote(str(version))
    )
    resp = await service.webscript_functions.patch_metadata(name, version, **kwargs)
    check_type(resp, Model)


def _publish_set_mock_response(
    httpx_mock: HTTPXMock, gateway_url: str, name: str, version: str
):
    mock_response = PostWebscriptJobSyncResponseV2Stub.create_json()
    httpx_mock_kwargs = {
        "method": "POST",
        "url": re.compile(
            f"^{gateway_url}/registry/v2/webscripts/{name}/versions/{version}/publish(\\?.*)?"
        ),
        "content": json.dumps(mock_response, default=str),
        "status_code": 201,
    }
    httpx_mock.add_response(**httpx_mock_kwargs)


@pytest.mark.asyncio
@pytest.mark.skipif(not MODELS_AVAILABLE, reason="Types not installed.")
async def test_publish(
    service: RegistryService, gateway_url: str, httpx_mock: HTTPXMock
):
    """Test case for publish
    Publish Draft Webscript
    """
    # set path params
    name = "name_example"

    version = "version_example"

    kwargs = {
        "query": {
            "comment": "comment_example",
            "deprecatePrevious": "none",
            "async": True,
        },
    }
    _publish_set_mock_response(
        httpx_mock, gateway_url, quote(str(name)), quote(str(version))
    )
    resp = await service.webscript_functions.publish(name, version, **kwargs)
    check_type(resp, PostWebscriptJobSyncResponseV2)


@pytest.mark.asyncio
@pytest.mark.skipif(MODELS_AVAILABLE, reason="Types installed.")
async def test_publish_without_types(
    service: RegistryService, gateway_url: str, httpx_mock: HTTPXMock
):
    """Test case for publish with models not installed
    Publish Draft Webscript
    """
    # set path params
    name = "name_example"

    version = "version_example"

    kwargs = {
        "query": {
            "comment": "comment_example",
            "deprecatePrevious": "none",
            "async": True,
        },
    }
    _publish_set_mock_response(
        httpx_mock, gateway_url, quote(str(name)), quote(str(version))
    )
    resp = await service.webscript_functions.publish(name, version, **kwargs)
    check_type(resp, Model)


def _rebuild_set_mock_response(
    httpx_mock: HTTPXMock, gateway_url: str, name: str, version: str
):
    mock_response = RebuildWebscriptSyncResponseV2Stub.create_json()
    httpx_mock_kwargs = {
        "method": "POST",
        "url": re.compile(
            f"^{gateway_url}/registry/v2/webscripts/{name}/versions/{version}/rebuild(\\?.*)?"
        ),
        "content": json.dumps(mock_response, default=str),
        "status_code": 200,
    }
    httpx_mock.add_response(**httpx_mock_kwargs)


@pytest.mark.asyncio
@pytest.mark.skipif(not MODELS_AVAILABLE, reason="Types not installed.")
async def test_rebuild(
    service: RegistryService, gateway_url: str, httpx_mock: HTTPXMock
):
    """Test case for rebuild
    Rebuild Webscript
    """
    # set path params
    name = "name_example"

    version = "version_example"

    kwargs = {
        "query": {
            "comment": "comment_example",
            "dryRun": True,
            "async": True,
            "upgrade": "patch",
            "forceVersion": "force_version_example",
            "ignoreChecks": True,
            "scaleToZero": True,
            "skipRebuild": True,
        },
    }
    _rebuild_set_mock_response(
        httpx_mock, gateway_url, quote(str(name)), quote(str(version))
    )
    resp = await service.webscript_functions.rebuild(name, version, **kwargs)
    check_type(resp, RebuildWebscriptSyncResponseV2)


@pytest.mark.asyncio
@pytest.mark.skipif(MODELS_AVAILABLE, reason="Types installed.")
async def test_rebuild_without_types(
    service: RegistryService, gateway_url: str, httpx_mock: HTTPXMock
):
    """Test case for rebuild with models not installed
    Rebuild Webscript
    """
    # set path params
    name = "name_example"

    version = "version_example"

    kwargs = {
        "query": {
            "comment": "comment_example",
            "dryRun": True,
            "async": True,
            "upgrade": "patch",
            "forceVersion": "force_version_example",
            "ignoreChecks": True,
            "scaleToZero": True,
            "skipRebuild": True,
        },
    }
    _rebuild_set_mock_response(
        httpx_mock, gateway_url, quote(str(name)), quote(str(version))
    )
    resp = await service.webscript_functions.rebuild(name, version, **kwargs)
    check_type(resp, Model)


def _remove_version_set_mock_response(
    httpx_mock: HTTPXMock, gateway_url: str, name: str, version: str
):
    mock_response = UndeployedResponseV2Stub.create_json()
    httpx_mock_kwargs = {
        "method": "DELETE",
        "url": re.compile(
            f"^{gateway_url}/registry/v2/webscripts/{name}/versions/{version}(\\?.*)?"
        ),
        "content": json.dumps(mock_response, default=str),
        "status_code": 200,
    }
    httpx_mock.add_response(**httpx_mock_kwargs)


@pytest.mark.asyncio
@pytest.mark.skipif(not MODELS_AVAILABLE, reason="Types not installed.")
async def test_remove_version(
    service: RegistryService, gateway_url: str, httpx_mock: HTTPXMock
):
    """Test case for remove_version
    Remove Webscript Version
    """
    # set path params
    name = "name_example"

    version = "version_example"

    kwargs = {
        "query": {
            "comment": "comment_example",
            "async": True,
            "force": True,
            "undeploy": True,
        },
    }
    _remove_version_set_mock_response(
        httpx_mock, gateway_url, quote(str(name)), quote(str(version))
    )
    resp = await service.webscript_functions.remove_version(name, version, **kwargs)
    check_type(resp, UndeployedResponseV2)


@pytest.mark.asyncio
@pytest.mark.skipif(MODELS_AVAILABLE, reason="Types installed.")
async def test_remove_version_without_types(
    service: RegistryService, gateway_url: str, httpx_mock: HTTPXMock
):
    """Test case for remove_version with models not installed
    Remove Webscript Version
    """
    # set path params
    name = "name_example"

    version = "version_example"

    kwargs = {
        "query": {
            "comment": "comment_example",
            "async": True,
            "force": True,
            "undeploy": True,
        },
    }
    _remove_version_set_mock_response(
        httpx_mock, gateway_url, quote(str(name)), quote(str(version))
    )
    resp = await service.webscript_functions.remove_version(name, version, **kwargs)
    check_type(resp, Model)


def _remove_versions_set_mock_response(
    httpx_mock: HTTPXMock, gateway_url: str, name: str
):
    mock_response = UndeployedResponseV2Stub.create_json()
    httpx_mock_kwargs = {
        "method": "DELETE",
        "url": re.compile(f"^{gateway_url}/registry/v2/webscripts/{name}(\\?.*)?"),
        "content": json.dumps(mock_response, default=str),
        "status_code": 200,
    }
    httpx_mock.add_response(**httpx_mock_kwargs)


@pytest.mark.asyncio
@pytest.mark.skipif(not MODELS_AVAILABLE, reason="Types not installed.")
async def test_remove_versions(
    service: RegistryService, gateway_url: str, httpx_mock: HTTPXMock
):
    """Test case for remove_versions
    Remove Webscript
    """
    # set path params
    name = "name_example"

    kwargs = {
        "query": {
            "comment": "comment_example",
            "async": True,
            "force": True,
            "undeploy": True,
        },
    }
    _remove_versions_set_mock_response(httpx_mock, gateway_url, quote(str(name)))
    resp = await service.webscript_functions.remove_versions(name, **kwargs)
    check_type(resp, UndeployedResponseV2)


@pytest.mark.asyncio
@pytest.mark.skipif(MODELS_AVAILABLE, reason="Types installed.")
async def test_remove_versions_without_types(
    service: RegistryService, gateway_url: str, httpx_mock: HTTPXMock
):
    """Test case for remove_versions with models not installed
    Remove Webscript
    """
    # set path params
    name = "name_example"

    kwargs = {
        "query": {
            "comment": "comment_example",
            "async": True,
            "force": True,
            "undeploy": True,
        },
    }
    _remove_versions_set_mock_response(httpx_mock, gateway_url, quote(str(name)))
    resp = await service.webscript_functions.remove_versions(name, **kwargs)
    check_type(resp, Model)


def _update_asset_set_mock_response(
    httpx_mock: HTTPXMock, gateway_url: str, name: str, version: str, wildcard: str
):
    mock_response = PostWebscriptJobSyncResponseV2Stub.create_json()
    httpx_mock_kwargs = {
        "method": "PUT",
        "url": re.compile(
            f"^{gateway_url}/registry/v2/webscripts/{name}/versions/{version}/content/{wildcard}(\\?.*)?"
        ),
        "content": json.dumps(mock_response, default=str),
        "status_code": 201,
    }
    httpx_mock.add_response(**httpx_mock_kwargs)


@pytest.mark.asyncio
@pytest.mark.skipif(not MODELS_AVAILABLE, reason="Types not installed.")
async def test_update_asset(
    service: RegistryService, gateway_url: str, httpx_mock: HTTPXMock
):
    """Test case for update_asset
    Update Webscript Asset
    """
    # set path params
    name = "name_example"

    version = "version_example"

    wildcard = "wildcard_example"

    kwargs = {
        "query": {
            "comment": "comment_example",
            "async": True,
            "chown": False,
        },
        "content": b"some_binary_content",
        "headers": {"content-type": "application/octet-stream"},
    }
    _update_asset_set_mock_response(
        httpx_mock,
        gateway_url,
        quote(str(name)),
        quote(str(version)),
        quote(str(wildcard)),
    )
    resp = await service.webscript_functions.update_asset(
        name, version, wildcard, **kwargs
    )
    check_type(resp, PostWebscriptJobSyncResponseV2)


@pytest.mark.asyncio
@pytest.mark.skipif(MODELS_AVAILABLE, reason="Types installed.")
async def test_update_asset_without_types(
    service: RegistryService, gateway_url: str, httpx_mock: HTTPXMock
):
    """Test case for update_asset with models not installed
    Update Webscript Asset
    """
    # set path params
    name = "name_example"

    version = "version_example"

    wildcard = "wildcard_example"

    kwargs = {
        "query": {
            "comment": "comment_example",
            "async": True,
            "chown": False,
        },
        "content": b"some_binary_content",
        "headers": {"content-type": "application/octet-stream"},
    }
    _update_asset_set_mock_response(
        httpx_mock,
        gateway_url,
        quote(str(name)),
        quote(str(version)),
        quote(str(wildcard)),
    )
    resp = await service.webscript_functions.update_asset(
        name, version, wildcard, **kwargs
    )
    check_type(resp, Model)


def _update_assets_set_mock_response(
    httpx_mock: HTTPXMock, gateway_url: str, name: str, version: str
):
    mock_response = PostWebscriptJobSyncResponseV2Stub.create_json()
    httpx_mock_kwargs = {
        "method": "PUT",
        "url": re.compile(
            f"^{gateway_url}/registry/v2/webscripts/{name}/versions/{version}/content(\\?.*)?"
        ),
        "content": json.dumps(mock_response, default=str),
        "status_code": 201,
    }
    httpx_mock.add_response(**httpx_mock_kwargs)


@pytest.mark.asyncio
@pytest.mark.skipif(not MODELS_AVAILABLE, reason="Types not installed.")
async def test_update_assets(
    service: RegistryService, gateway_url: str, httpx_mock: HTTPXMock
):
    """Test case for update_assets
    Update Webscript Assets
    """
    # set path params
    name = "name_example"

    version = "version_example"

    kwargs = {
        "query": {
            "comment": "comment_example",
            "async": True,
            "chown": False,
        },
        "content": b"some_binary_content",
        "headers": {"content-type": "application/octet-stream"},
        "files": {
            "myFile1": b"...first file content...",
            "myFile2": b"...second file content...",
        },
    }
    _update_assets_set_mock_response(
        httpx_mock, gateway_url, quote(str(name)), quote(str(version))
    )
    resp = await service.webscript_functions.update_assets(name, version, **kwargs)
    check_type(resp, PostWebscriptJobSyncResponseV2)


@pytest.mark.asyncio
@pytest.mark.skipif(MODELS_AVAILABLE, reason="Types installed.")
async def test_update_assets_without_types(
    service: RegistryService, gateway_url: str, httpx_mock: HTTPXMock
):
    """Test case for update_assets with models not installed
    Update Webscript Assets
    """
    # set path params
    name = "name_example"

    version = "version_example"

    kwargs = {
        "query": {
            "comment": "comment_example",
            "async": True,
            "chown": False,
        },
        "files": {
            "myFile1": b"...first file content...",
            "myFile2": b"...second file content...",
        },
        "content": b"some_binary_content",
        "headers": {"content-type": "application/octet-stream"},
    }
    _update_assets_set_mock_response(
        httpx_mock, gateway_url, quote(str(name)), quote(str(version))
    )
    resp = await service.webscript_functions.update_assets(name, version, **kwargs)
    check_type(resp, Model)


def _verify_set_mock_response(
    httpx_mock: HTTPXMock, gateway_url: str, name: str, version: str
):
    mock_response = VerifyWebscriptSyncResponseV2Stub.create_json()
    httpx_mock_kwargs = {
        "method": "POST",
        "url": re.compile(
            f"^{gateway_url}/registry/v2/webscripts/{name}/versions/{version}/verify(\\?.*)?"
        ),
        "content": json.dumps(mock_response, default=str),
        "status_code": 200,
    }
    httpx_mock.add_response(**httpx_mock_kwargs)


@pytest.mark.asyncio
@pytest.mark.skipif(not MODELS_AVAILABLE, reason="Types not installed.")
async def test_verify(
    service: RegistryService, gateway_url: str, httpx_mock: HTTPXMock
):
    """Test case for verify
    Verify Health Of Webscript
    """
    # set path params
    name = "name_example"

    version = "version_example"

    kwargs = {
        "query": {
            "comment": "comment_example",
            "async": True,
            "scaleToZero": True,
        },
    }
    _verify_set_mock_response(
        httpx_mock, gateway_url, quote(str(name)), quote(str(version))
    )
    resp = await service.webscript_functions.verify(name, version, **kwargs)
    check_type(resp, VerifyWebscriptSyncResponseV2)


@pytest.mark.asyncio
@pytest.mark.skipif(MODELS_AVAILABLE, reason="Types installed.")
async def test_verify_without_types(
    service: RegistryService, gateway_url: str, httpx_mock: HTTPXMock
):
    """Test case for verify with models not installed
    Verify Health Of Webscript
    """
    # set path params
    name = "name_example"

    version = "version_example"

    kwargs = {
        "query": {
            "comment": "comment_example",
            "async": True,
            "scaleToZero": True,
        },
    }
    _verify_set_mock_response(
        httpx_mock, gateway_url, quote(str(name)), quote(str(version))
    )
    resp = await service.webscript_functions.verify(name, version, **kwargs)
    check_type(resp, Model)
