# coding: utf-8
"""Waylay Function Registry api tests.

This code was generated from the OpenAPI documentation of 'Waylay Function Registry'

Generated by OpenAPI Generator (https://openapi-generator.tech)

Do not edit the class manually.
"""

import json
import re
from importlib.util import find_spec
from typing import Union
from urllib.parse import quote

import pytest
from pytest_httpx import HTTPXMock
from typeguard import check_type
from waylay.sdk import ApiClient, WaylayClient
from waylay.sdk.api._models import Model
from waylay.services.registry.api import RuntimesApi
from waylay.services.registry.service import RegistryService

from ..types.list_runtimes_tags_parameter_stub import ListRuntimesTagsParameterStub
from ..types.runtime_summary_response_stub import RuntimeSummaryResponseStub
from ..types.runtime_tag_response_stub import RuntimeTagResponseStub
from ..types.runtime_tags_response_stub import RuntimeTagsResponseStub
from ..types.runtime_version_response_stub import RuntimeVersionResponseStub
from ..types.semantic_version_range_stub import SemanticVersionRangeStub

MODELS_AVAILABLE = (
    True if find_spec("waylay.services.registry.models") is not None else False
)

if MODELS_AVAILABLE:
    from waylay.services.registry.models import (
        RuntimeSummaryResponse,
        RuntimeTagResponse,
        RuntimeTagsResponse,
        RuntimeVersionResponse,
    )
    from waylay.services.registry.queries.runtimes_api import (
        ExampleArchiveQuery,
        GetExampleAssetQuery,
        GetLatestQuery,
        GetQuery,
        ListQuery,
        ListVersionsQuery,
        TagsQuery,
    )


# some mappings that are needed for some <example> interpolations
null, true, false = None, True, False


@pytest.fixture
def runtimes_api(waylay_api_client: ApiClient) -> RuntimesApi:
    return RuntimesApi(waylay_api_client)


def test_registered(waylay_client: WaylayClient):
    """Test that RuntimesApi api is registered in the sdk client."""
    assert isinstance(waylay_client.registry.runtimes, RuntimesApi)


def _example_archive_set_mock_response(
    httpx_mock: HTTPXMock, gateway_url: str, name: str, version: str
):
    mock_response = bytes(b"blah")
    httpx_mock_kwargs = {
        "method": "GET",
        "url": re.compile(
            f"^{gateway_url}/registry/v2/runtimes/{name}/versions/{version}/example(\\?.*)?"
        ),
        "content": json.dumps(mock_response, default=str),
        "status_code": 200,
    }
    httpx_mock.add_response(**httpx_mock_kwargs)


@pytest.mark.asyncio
@pytest.mark.skipif(not MODELS_AVAILABLE, reason="Types not installed.")
async def test_example_archive(
    service: RegistryService, gateway_url: str, httpx_mock: HTTPXMock
):
    """Test case for example_archive
    Get Runtime Example Archive
    """
    # set path params
    name = "name_example"

    version = SemanticVersionRangeStub.create_json()

    kwargs = {
        # optionally use ExampleArchiveQuery to validate and reuse parameters
        "query": ExampleArchiveQuery(
            ls=False,
            show_tags="embed",
            include_deprecated=True,
        ),
    }
    _example_archive_set_mock_response(
        httpx_mock, gateway_url, quote(str(name)), quote(str(version))
    )
    resp = await service.runtimes.example_archive(name, version, **kwargs)
    check_type(resp, bytes)


@pytest.mark.asyncio
@pytest.mark.skipif(MODELS_AVAILABLE, reason="Types installed.")
async def test_example_archive_without_types(
    service: RegistryService, gateway_url: str, httpx_mock: HTTPXMock
):
    """Test case for example_archive with models not installed
    Get Runtime Example Archive
    """
    # set path params
    name = "name_example"

    version = SemanticVersionRangeStub.create_json()

    kwargs = {
        "query": {
            "ls": False,
            "showTags": "embed",
            "includeDeprecated": True,
        },
    }
    _example_archive_set_mock_response(
        httpx_mock, gateway_url, quote(str(name)), quote(str(version))
    )
    resp = await service.runtimes.example_archive(name, version, **kwargs)
    check_type(resp, bytes)


def _get_example_asset_set_mock_response(
    httpx_mock: HTTPXMock, gateway_url: str, name: str, version: str, wildcard: str
):
    mock_response = bytes(b"blah")
    httpx_mock_kwargs = {
        "method": "GET",
        "url": re.compile(
            f"^{gateway_url}/registry/v2/runtimes/{name}/versions/{version}/example/{wildcard}(\\?.*)?"
        ),
        "content": json.dumps(mock_response, default=str),
        "status_code": 200,
    }
    httpx_mock.add_response(**httpx_mock_kwargs)


@pytest.mark.asyncio
@pytest.mark.skipif(not MODELS_AVAILABLE, reason="Types not installed.")
async def test_get_example_asset(
    service: RegistryService, gateway_url: str, httpx_mock: HTTPXMock
):
    """Test case for get_example_asset
    Get File From Runtime Example Archive
    """
    # set path params
    name = "name_example"

    version = SemanticVersionRangeStub.create_json()

    wildcard = "wildcard_example"

    kwargs = {
        # optionally use GetExampleAssetQuery to validate and reuse parameters
        "query": GetExampleAssetQuery(
            ls=False,
            show_tags="embed",
            include_deprecated=True,
        ),
    }
    _get_example_asset_set_mock_response(
        httpx_mock,
        gateway_url,
        quote(str(name)),
        quote(str(version)),
        quote(str(wildcard)),
    )
    resp = await service.runtimes.get_example_asset(name, version, wildcard, **kwargs)
    check_type(resp, bytes)


@pytest.mark.asyncio
@pytest.mark.skipif(MODELS_AVAILABLE, reason="Types installed.")
async def test_get_example_asset_without_types(
    service: RegistryService, gateway_url: str, httpx_mock: HTTPXMock
):
    """Test case for get_example_asset with models not installed
    Get File From Runtime Example Archive
    """
    # set path params
    name = "name_example"

    version = SemanticVersionRangeStub.create_json()

    wildcard = "wildcard_example"

    kwargs = {
        "query": {
            "ls": False,
            "showTags": "embed",
            "includeDeprecated": True,
        },
    }
    _get_example_asset_set_mock_response(
        httpx_mock,
        gateway_url,
        quote(str(name)),
        quote(str(version)),
        quote(str(wildcard)),
    )
    resp = await service.runtimes.get_example_asset(name, version, wildcard, **kwargs)
    check_type(resp, bytes)


def _get_latest_set_mock_response(httpx_mock: HTTPXMock, gateway_url: str, name: str):
    mock_response = RuntimeVersionResponseStub.create_json()
    httpx_mock_kwargs = {
        "method": "GET",
        "url": re.compile(f"^{gateway_url}/registry/v2/runtimes/{name}(\\?.*)?"),
        "content": json.dumps(mock_response, default=str),
        "status_code": 200,
    }
    httpx_mock.add_response(**httpx_mock_kwargs)


@pytest.mark.asyncio
@pytest.mark.skipif(not MODELS_AVAILABLE, reason="Types not installed.")
async def test_get_latest(
    service: RegistryService, gateway_url: str, httpx_mock: HTTPXMock
):
    """Test case for get_latest
    Get Latest Runtime Version
    """
    # set path params
    name = "name_example"

    kwargs = {
        # optionally use GetLatestQuery to validate and reuse parameters
        "query": GetLatestQuery(
            show_tags="embed",
            version=SemanticVersionRangeStub.create_json(),
            include_deprecated=False,
            tags=ListRuntimesTagsParameterStub.create_json(),
            function_type=[],
            archive_format=[],
        ),
    }
    _get_latest_set_mock_response(httpx_mock, gateway_url, quote(str(name)))
    resp = await service.runtimes.get_latest(name, **kwargs)
    check_type(resp, Union[RuntimeVersionResponse,])


@pytest.mark.asyncio
@pytest.mark.skipif(MODELS_AVAILABLE, reason="Types installed.")
async def test_get_latest_without_types(
    service: RegistryService, gateway_url: str, httpx_mock: HTTPXMock
):
    """Test case for get_latest with models not installed
    Get Latest Runtime Version
    """
    # set path params
    name = "name_example"

    kwargs = {
        "query": {
            "showTags": "embed",
            "version": SemanticVersionRangeStub.create_json(),
            "includeDeprecated": False,
            "tags": ListRuntimesTagsParameterStub.create_json(),
            "functionType": [],
            "archiveFormat": [],
        },
    }
    _get_latest_set_mock_response(httpx_mock, gateway_url, quote(str(name)))
    resp = await service.runtimes.get_latest(name, **kwargs)
    check_type(resp, Model)


def _get_set_mock_response(
    httpx_mock: HTTPXMock, gateway_url: str, name: str, version: str
):
    mock_response = RuntimeVersionResponseStub.create_json()
    httpx_mock_kwargs = {
        "method": "GET",
        "url": re.compile(
            f"^{gateway_url}/registry/v2/runtimes/{name}/versions/{version}(\\?.*)?"
        ),
        "content": json.dumps(mock_response, default=str),
        "status_code": 200,
    }
    httpx_mock.add_response(**httpx_mock_kwargs)


@pytest.mark.asyncio
@pytest.mark.skipif(not MODELS_AVAILABLE, reason="Types not installed.")
async def test_get(service: RegistryService, gateway_url: str, httpx_mock: HTTPXMock):
    """Test case for get
    Get Runtime Version
    """
    # set path params
    name = "name_example"

    version = SemanticVersionRangeStub.create_json()

    kwargs = {
        # optionally use GetQuery to validate and reuse parameters
        "query": GetQuery(
            show_tags="embed",
            include_deprecated=True,
        ),
    }
    _get_set_mock_response(
        httpx_mock, gateway_url, quote(str(name)), quote(str(version))
    )
    resp = await service.runtimes.get(name, version, **kwargs)
    check_type(resp, Union[RuntimeVersionResponse,])


@pytest.mark.asyncio
@pytest.mark.skipif(MODELS_AVAILABLE, reason="Types installed.")
async def test_get_without_types(
    service: RegistryService, gateway_url: str, httpx_mock: HTTPXMock
):
    """Test case for get with models not installed
    Get Runtime Version
    """
    # set path params
    name = "name_example"

    version = SemanticVersionRangeStub.create_json()

    kwargs = {
        "query": {
            "showTags": "embed",
            "includeDeprecated": True,
        },
    }
    _get_set_mock_response(
        httpx_mock, gateway_url, quote(str(name)), quote(str(version))
    )
    resp = await service.runtimes.get(name, version, **kwargs)
    check_type(resp, Model)


def _list_set_mock_response(httpx_mock: HTTPXMock, gateway_url: str):
    mock_response = RuntimeSummaryResponseStub.create_json()
    httpx_mock_kwargs = {
        "method": "GET",
        "url": re.compile(f"^{gateway_url}/registry/v2/runtimes/(\\?.*)?"),
        "content": json.dumps(mock_response, default=str),
        "status_code": 200,
    }
    httpx_mock.add_response(**httpx_mock_kwargs)


@pytest.mark.asyncio
@pytest.mark.skipif(not MODELS_AVAILABLE, reason="Types not installed.")
async def test_list(service: RegistryService, gateway_url: str, httpx_mock: HTTPXMock):
    """Test case for list
    List Runtimes
    """
    # set path params
    kwargs = {
        # optionally use ListQuery to validate and reuse parameters
        "query": ListQuery(
            show_tags="embed",
            version=SemanticVersionRangeStub.create_json(),
            latest="major",
            include_deprecated=False,
            tags=ListRuntimesTagsParameterStub.create_json(),
            name="node*",
            function_type=[],
            archive_format=[],
        ),
    }
    _list_set_mock_response(httpx_mock, gateway_url)
    resp = await service.runtimes.list(**kwargs)
    check_type(resp, Union[RuntimeSummaryResponse,])


@pytest.mark.asyncio
@pytest.mark.skipif(MODELS_AVAILABLE, reason="Types installed.")
async def test_list_without_types(
    service: RegistryService, gateway_url: str, httpx_mock: HTTPXMock
):
    """Test case for list with models not installed
    List Runtimes
    """
    # set path params
    kwargs = {
        "query": {
            "showTags": "embed",
            "version": SemanticVersionRangeStub.create_json(),
            "latest": "major",
            "includeDeprecated": False,
            "tags": ListRuntimesTagsParameterStub.create_json(),
            "name": "node*",
            "functionType": [],
            "archiveFormat": [],
        },
    }
    _list_set_mock_response(httpx_mock, gateway_url)
    resp = await service.runtimes.list(**kwargs)
    check_type(resp, Model)


def _list_versions_set_mock_response(
    httpx_mock: HTTPXMock, gateway_url: str, name: str
):
    mock_response = RuntimeSummaryResponseStub.create_json()
    httpx_mock_kwargs = {
        "method": "GET",
        "url": re.compile(
            f"^{gateway_url}/registry/v2/runtimes/{name}/versions(\\?.*)?"
        ),
        "content": json.dumps(mock_response, default=str),
        "status_code": 200,
    }
    httpx_mock.add_response(**httpx_mock_kwargs)


@pytest.mark.asyncio
@pytest.mark.skipif(not MODELS_AVAILABLE, reason="Types not installed.")
async def test_list_versions(
    service: RegistryService, gateway_url: str, httpx_mock: HTTPXMock
):
    """Test case for list_versions
    List Runtime Versions
    """
    # set path params
    name = "name_example"

    kwargs = {
        # optionally use ListVersionsQuery to validate and reuse parameters
        "query": ListVersionsQuery(
            version=SemanticVersionRangeStub.create_json(),
            latest="major",
            include_deprecated=False,
            tags=ListRuntimesTagsParameterStub.create_json(),
            function_type=[],
            archive_format=[],
            show_tags="embed",
        ),
    }
    _list_versions_set_mock_response(httpx_mock, gateway_url, quote(str(name)))
    resp = await service.runtimes.list_versions(name, **kwargs)
    check_type(resp, Union[RuntimeSummaryResponse,])


@pytest.mark.asyncio
@pytest.mark.skipif(MODELS_AVAILABLE, reason="Types installed.")
async def test_list_versions_without_types(
    service: RegistryService, gateway_url: str, httpx_mock: HTTPXMock
):
    """Test case for list_versions with models not installed
    List Runtime Versions
    """
    # set path params
    name = "name_example"

    kwargs = {
        "query": {
            "version": SemanticVersionRangeStub.create_json(),
            "latest": "major",
            "includeDeprecated": False,
            "tags": ListRuntimesTagsParameterStub.create_json(),
            "functionType": [],
            "archiveFormat": [],
            "showTags": "embed",
        },
    }
    _list_versions_set_mock_response(httpx_mock, gateway_url, quote(str(name)))
    resp = await service.runtimes.list_versions(name, **kwargs)
    check_type(resp, Model)


def _tag_set_mock_response(httpx_mock: HTTPXMock, gateway_url: str, tagName: str):
    mock_response = RuntimeTagResponseStub.create_json()
    httpx_mock_kwargs = {
        "method": "GET",
        "url": re.compile(f"^{gateway_url}/registry/v2/runtimeTags/{tagName}(\\?.*)?"),
        "content": json.dumps(mock_response, default=str),
        "status_code": 200,
    }
    httpx_mock.add_response(**httpx_mock_kwargs)


@pytest.mark.asyncio
@pytest.mark.skipif(not MODELS_AVAILABLE, reason="Types not installed.")
async def test_tag(service: RegistryService, gateway_url: str, httpx_mock: HTTPXMock):
    """Test case for tag
    Get Runtime Tag
    """
    # set path params
    tagName = "tag_name_example"

    kwargs = {}
    _tag_set_mock_response(httpx_mock, gateway_url, quote(str(tagName)))
    resp = await service.runtimes.tag(tagName, **kwargs)
    check_type(resp, Union[RuntimeTagResponse,])


@pytest.mark.asyncio
@pytest.mark.skipif(MODELS_AVAILABLE, reason="Types installed.")
async def test_tag_without_types(
    service: RegistryService, gateway_url: str, httpx_mock: HTTPXMock
):
    """Test case for tag with models not installed
    Get Runtime Tag
    """
    # set path params
    tagName = "tag_name_example"

    kwargs = {}
    _tag_set_mock_response(httpx_mock, gateway_url, quote(str(tagName)))
    resp = await service.runtimes.tag(tagName, **kwargs)
    check_type(resp, Model)


def _tags_set_mock_response(httpx_mock: HTTPXMock, gateway_url: str):
    mock_response = RuntimeTagsResponseStub.create_json()
    httpx_mock_kwargs = {
        "method": "GET",
        "url": re.compile(f"^{gateway_url}/registry/v2/runtimeTags/(\\?.*)?"),
        "content": json.dumps(mock_response, default=str),
        "status_code": 200,
    }
    httpx_mock.add_response(**httpx_mock_kwargs)


@pytest.mark.asyncio
@pytest.mark.skipif(not MODELS_AVAILABLE, reason="Types not installed.")
async def test_tags(service: RegistryService, gateway_url: str, httpx_mock: HTTPXMock):
    """Test case for tags
    List Runtime Tags
    """
    # set path params
    kwargs = {
        # optionally use TagsQuery to validate and reuse parameters
        "query": TagsQuery(
            name="*-demo-??",
            color="#4153ea",
        ),
    }
    _tags_set_mock_response(httpx_mock, gateway_url)
    resp = await service.runtimes.tags(**kwargs)
    check_type(resp, Union[RuntimeTagsResponse,])


@pytest.mark.asyncio
@pytest.mark.skipif(MODELS_AVAILABLE, reason="Types installed.")
async def test_tags_without_types(
    service: RegistryService, gateway_url: str, httpx_mock: HTTPXMock
):
    """Test case for tags with models not installed
    List Runtime Tags
    """
    # set path params
    kwargs = {
        "query": {
            "name": "*-demo-??",
            "color": "#4153ea",
        },
    }
    _tags_set_mock_response(httpx_mock, gateway_url)
    resp = await service.runtimes.tags(**kwargs)
    check_type(resp, Model)
