# coding: utf-8
"""Waylay Function Registry api tests.

This code was generated from the OpenAPI documentation of 'Waylay Function Registry'

Generated by OpenAPI Generator (https://openapi-generator.tech)

Do not edit the class manually.
"""

import json
import re
from importlib.util import find_spec
from typing import AsyncIterator, Union, get_args
from urllib.parse import quote

import pytest
from pytest_httpx import HTTPXMock
from typeguard import check_type
from waylay.sdk import ApiClient, WaylayClient
from waylay.sdk.api._models import Model
from waylay.services.registry.api import JobsApi
from waylay.services.registry.service import RegistryService

from ..types.event_with_close_sse_stub import EventWithCloseSSEStub
from ..types.job_response_stub import JobResponseStub
from ..types.jobs_response_stub import JobsResponseStub
from ..types.timestamp_spec_stub import TimestampSpecStub

MODELS_AVAILABLE = (
    True if find_spec("waylay.services.registry.models") is not None else False
)

if MODELS_AVAILABLE:
    from waylay.services.registry.models import (
        EventWithCloseSSE,
        JobResponse,
        JobsResponse,
    )
    from waylay.services.registry.queries.jobs_api import EventsQuery, ListQuery


# some mappings that are needed for some <example> interpolations
null, true, false = None, True, False


@pytest.fixture
def jobs_api(waylay_api_client: ApiClient) -> JobsApi:
    return JobsApi(waylay_api_client)


def test_registered(waylay_client: WaylayClient):
    """Test that JobsApi api is registered in the sdk client."""
    assert isinstance(waylay_client.registry.jobs, JobsApi)


def _events_set_mock_response(httpx_mock: HTTPXMock, gateway_url: str):
    mock_response = EventWithCloseSSEStub.create_json()
    httpx_mock_kwargs = {
        "method": "GET",
        "url": re.compile(f"^{gateway_url}/registry/v2/jobs/events(\\?.*)?"),
        "content": json.dumps(mock_response, default=str) + "\n",
        "status_code": 200,
        "headers": {"content-type": "application/x-ndjson"},
    }
    httpx_mock.add_response(**httpx_mock_kwargs)


@pytest.mark.asyncio
@pytest.mark.skipif(not MODELS_AVAILABLE, reason="Types not installed.")
async def test_events(
    service: RegistryService, gateway_url: str, httpx_mock: HTTPXMock
):
    """Test case for events
    Stream Events
    """
    # set path params
    kwargs = {
        # optionally use EventsQuery to validate and reuse parameters
        "query": EventsQuery(
            type="build",
            id="id_example",
            children=True,
        ),
    }
    _events_set_mock_response(httpx_mock, gateway_url)
    resp = await service.jobs.events(**kwargs)
    check_type(resp, Union[AsyncIterator[EventWithCloseSSE],])
    async for item in resp:
        check_type(item, get_args(Union[AsyncIterator[EventWithCloseSSE],])[0])
        break  # Test only the first value


@pytest.mark.asyncio
@pytest.mark.skipif(MODELS_AVAILABLE, reason="Types installed.")
async def test_events_without_types(
    service: RegistryService, gateway_url: str, httpx_mock: HTTPXMock
):
    """Test case for events with models not installed
    Stream Events
    """
    # set path params
    kwargs = {
        "query": {
            "type": "build",
            "id": "id_example",
            "children": True,
        },
    }
    _events_set_mock_response(httpx_mock, gateway_url)
    resp = await service.jobs.events(**kwargs)
    check_type(resp, Model)
    async for item in resp:
        check_type(item, Model)
        break  # Test only the first value


def _get_set_mock_response(httpx_mock: HTTPXMock, gateway_url: str, type: str, id: str):
    mock_response = JobResponseStub.create_json()
    httpx_mock_kwargs = {
        "method": "GET",
        "url": re.compile(f"^{gateway_url}/registry/v2/jobs/{type}/{id}(\\?.*)?"),
        "content": json.dumps(mock_response, default=str),
        "status_code": 200,
    }
    httpx_mock.add_response(**httpx_mock_kwargs)


@pytest.mark.asyncio
@pytest.mark.skipif(not MODELS_AVAILABLE, reason="Types not installed.")
async def test_get(service: RegistryService, gateway_url: str, httpx_mock: HTTPXMock):
    """Test case for get
    Get Job
    """
    # set path params
    type = "build"

    id = "id_example"

    kwargs = {}
    _get_set_mock_response(httpx_mock, gateway_url, quote(str(type)), quote(str(id)))
    resp = await service.jobs.get(type, id, **kwargs)
    check_type(resp, Union[JobResponse,])


@pytest.mark.asyncio
@pytest.mark.skipif(MODELS_AVAILABLE, reason="Types installed.")
async def test_get_without_types(
    service: RegistryService, gateway_url: str, httpx_mock: HTTPXMock
):
    """Test case for get with models not installed
    Get Job
    """
    # set path params
    type = "build"

    id = "id_example"

    kwargs = {}
    _get_set_mock_response(httpx_mock, gateway_url, quote(str(type)), quote(str(id)))
    resp = await service.jobs.get(type, id, **kwargs)
    check_type(resp, Model)


def _list_set_mock_response(httpx_mock: HTTPXMock, gateway_url: str):
    mock_response = JobsResponseStub.create_json()
    httpx_mock_kwargs = {
        "method": "GET",
        "url": re.compile(f"^{gateway_url}/registry/v2/jobs/(\\?.*)?"),
        "content": json.dumps(mock_response, default=str),
        "status_code": 200,
    }
    httpx_mock.add_response(**httpx_mock_kwargs)


@pytest.mark.asyncio
@pytest.mark.skipif(not MODELS_AVAILABLE, reason="Types not installed.")
async def test_list(service: RegistryService, gateway_url: str, httpx_mock: HTTPXMock):
    """Test case for list
    List Jobs
    """
    # set path params
    kwargs = {
        # optionally use ListQuery to validate and reuse parameters
        "query": ListQuery(
            limit=3.4,
            type=[],
            state=[],
            function_type=[],
            created_before=TimestampSpecStub.create_json(),
            created_after=TimestampSpecStub.create_json(),
        ),
    }
    _list_set_mock_response(httpx_mock, gateway_url)
    resp = await service.jobs.list(**kwargs)
    check_type(resp, Union[JobsResponse,])


@pytest.mark.asyncio
@pytest.mark.skipif(MODELS_AVAILABLE, reason="Types installed.")
async def test_list_without_types(
    service: RegistryService, gateway_url: str, httpx_mock: HTTPXMock
):
    """Test case for list with models not installed
    List Jobs
    """
    # set path params
    kwargs = {
        "query": {
            "limit": 3.4,
            "type": [],
            "state": [],
            "functionType": [],
            "createdBefore": TimestampSpecStub.create_json(),
            "createdAfter": TimestampSpecStub.create_json(),
        },
    }
    _list_set_mock_response(httpx_mock, gateway_url)
    resp = await service.jobs.list(**kwargs)
    check_type(resp, Model)
