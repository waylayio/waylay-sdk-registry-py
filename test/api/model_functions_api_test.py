# coding: utf-8
"""Waylay Function Registry api tests.

This code was generated from the OpenAPI documentation of 'Waylay Function Registry'

Generated by OpenAPI Generator (https://openapi-generator.tech)

Do not edit the class manually.
"""

import pytest
from typeguard import check_type
from pytest_httpx import HTTPXMock
import json
from waylay.sdk import ApiClient, WaylayClient
from waylay.services.registry.api import ModelFunctionsApi
from waylay.services.registry.service import RegistryService


from ..types.post_model_job_sync_response_v2_stub import PostModelJobSyncResponseV2Stub
from waylay.services.registry.models import PostModelJobSyncResponseV2


from ..types.post_model_job_sync_response_v2_stub import PostModelJobSyncResponseV2Stub
from waylay.services.registry.models import PostModelJobSyncResponseV2


from ..types.get_model_response_v2_stub import GetModelResponseV2Stub
from waylay.services.registry.models import GetModelResponseV2


from ..types.get_model_response_v2_stub import GetModelResponseV2Stub
from waylay.services.registry.models import GetModelResponseV2


from ..types.jobs_for_model_response_v2_stub import JobsForModelResponseV2Stub
from waylay.services.registry.models import JobsForModelResponseV2


from ..types.latest_models_response_v2_stub import LatestModelsResponseV2Stub
from waylay.services.registry.models import LatestModelsResponseV2


from ..types.model_versions_response_v2_stub import ModelVersionsResponseV2Stub
from waylay.services.registry.models import ModelVersionsResponseV2


from ..types.function_meta_stub import FunctionMetaStub


from ..types.get_model_response_v2_stub import GetModelResponseV2Stub
from waylay.services.registry.models import GetModelResponseV2


from ..types.post_model_job_sync_response_v2_stub import PostModelJobSyncResponseV2Stub
from waylay.services.registry.models import PostModelJobSyncResponseV2


from ..types.rebuild_model_sync_response_v2_stub import RebuildModelSyncResponseV2Stub
from waylay.services.registry.models import RebuildModelSyncResponseV2


from ..types.undeployed_response_v2_stub import UndeployedResponseV2Stub
from waylay.services.registry.models import UndeployedResponseV2


from ..types.undeployed_response_v2_stub import UndeployedResponseV2Stub
from waylay.services.registry.models import UndeployedResponseV2


from ..types.file_upload_stub import FileUploadStub


from ..types.post_model_job_sync_response_v2_stub import PostModelJobSyncResponseV2Stub
from waylay.services.registry.models import PostModelJobSyncResponseV2


from ..types.post_model_job_sync_response_v2_stub import PostModelJobSyncResponseV2Stub
from waylay.services.registry.models import PostModelJobSyncResponseV2


from ..types.verify_model_sync_response_v2_stub import VerifyModelSyncResponseV2Stub
from waylay.services.registry.models import VerifyModelSyncResponseV2


# some mappings that are needed for some <example> interpolations
null, true, false = None, True, False


@pytest.fixture
def model_functions_api(waylay_api_client: ApiClient) -> ModelFunctionsApi:
    return ModelFunctionsApi(waylay_api_client)


def test_registered(waylay_client: WaylayClient):
    """Test that ModelFunctionsApi api is registered in the sdk client."""
    assert isinstance(waylay_client.registry.model_functions, ModelFunctionsApi)


@pytest.mark.asyncio
async def test_create(
    service: RegistryService, gateway_url: str, httpx_mock: HTTPXMock
):
    """Test case for create
    Create Model
    """
    # set path params
    # set files param
    files = {
        "myFile1": b"...first file content...",
        "myFile2": b"...second file content...",
    }

    mock_response = PostModelJobSyncResponseV2Stub.create_instance().to_dict()
    httpx_mock_kwargs = {
        "method": "POST",
        "url": gateway_url + f"/registry/v2/models/",  # noqa: F541
        "content": json.dumps(mock_response, default=str),
        "status_code": 201,
    }
    httpx_mock.add_response(**httpx_mock_kwargs)
    kwargs = {
        "files": files,
    }
    resp = await service.model_functions.create(**kwargs)
    check_type(resp, PostModelJobSyncResponseV2)


@pytest.mark.asyncio
async def test_delete_asset(
    service: RegistryService, gateway_url: str, httpx_mock: HTTPXMock
):
    """Test case for delete_asset
    Delete Model Asset
    """
    # set path params
    name = "name_example"

    version = "version_example"

    wildcard = "wildcard_example"

    mock_response = PostModelJobSyncResponseV2Stub.create_instance().to_dict()
    httpx_mock_kwargs = {
        "method": "DELETE",
        "url": gateway_url
        + f"/registry/v2/models/{name}/versions/{version}/content/{wildcard}",  # noqa: F541
        "content": json.dumps(mock_response, default=str),
        "status_code": 201,
    }
    httpx_mock.add_response(**httpx_mock_kwargs)
    kwargs = {
        "name": name,
        "version": version,
        "wildcard": wildcard,
    }
    resp = await service.model_functions.delete_asset(**kwargs)
    check_type(resp, PostModelJobSyncResponseV2)


@pytest.mark.asyncio
async def test_get_archive(
    service: RegistryService, gateway_url: str, httpx_mock: HTTPXMock
):
    """Test case for get_archive
    Get Model Archive
    """
    # set path params
    name = "name_example"

    version = "version_example"

    mock_response = bytes(b"blah")
    httpx_mock_kwargs = {
        "method": "GET",
        "url": gateway_url + f"/registry/v2/models/{name}/versions/{version}/content",  # noqa: F541
        "content": json.dumps(mock_response, default=str),
        "status_code": 200,
    }
    httpx_mock.add_response(**httpx_mock_kwargs)
    kwargs = {
        "name": name,
        "version": version,
    }
    resp = await service.model_functions.get_archive(**kwargs)
    check_type(resp, bytes)


@pytest.mark.asyncio
async def test_get_asset(
    service: RegistryService, gateway_url: str, httpx_mock: HTTPXMock
):
    """Test case for get_asset
    Get File From Model Archive
    """
    # set path params
    name = "name_example"

    version = "version_example"

    wildcard = "wildcard_example"

    mock_response = bytes(b"blah")
    httpx_mock_kwargs = {
        "method": "GET",
        "url": gateway_url
        + f"/registry/v2/models/{name}/versions/{version}/content/{wildcard}",  # noqa: F541
        "content": json.dumps(mock_response, default=str),
        "status_code": 200,
    }
    httpx_mock.add_response(**httpx_mock_kwargs)
    kwargs = {
        "name": name,
        "version": version,
        "wildcard": wildcard,
    }
    resp = await service.model_functions.get_asset(**kwargs)
    check_type(resp, bytes)


@pytest.mark.asyncio
async def test_get_latest(
    service: RegistryService, gateway_url: str, httpx_mock: HTTPXMock
):
    """Test case for get_latest
    Get Latest Model Version
    """
    # set path params
    name = "name_example"

    mock_response = GetModelResponseV2Stub.create_instance().to_dict()
    httpx_mock_kwargs = {
        "method": "GET",
        "url": gateway_url + f"/registry/v2/models/{name}",  # noqa: F541
        "content": json.dumps(mock_response, default=str),
        "status_code": 200,
    }
    httpx_mock.add_response(**httpx_mock_kwargs)
    kwargs = {
        "name": name,
    }
    resp = await service.model_functions.get_latest(**kwargs)
    check_type(resp, GetModelResponseV2)


@pytest.mark.asyncio
async def test_get(service: RegistryService, gateway_url: str, httpx_mock: HTTPXMock):
    """Test case for get
    Get Model Version
    """
    # set path params
    name = "name_example"

    version = "version_example"

    mock_response = GetModelResponseV2Stub.create_instance().to_dict()
    httpx_mock_kwargs = {
        "method": "GET",
        "url": gateway_url + f"/registry/v2/models/{name}/versions/{version}",  # noqa: F541
        "content": json.dumps(mock_response, default=str),
        "status_code": 200,
    }
    httpx_mock.add_response(**httpx_mock_kwargs)
    kwargs = {
        "name": name,
        "version": version,
    }
    resp = await service.model_functions.get(**kwargs)
    check_type(resp, GetModelResponseV2)


@pytest.mark.asyncio
async def test_jobs(service: RegistryService, gateway_url: str, httpx_mock: HTTPXMock):
    """Test case for jobs
    List Model Jobs
    """
    # set path params
    name = "name_example"

    version = "version_example"

    mock_response = JobsForModelResponseV2Stub.create_instance().to_dict()
    httpx_mock_kwargs = {
        "method": "GET",
        "url": gateway_url + f"/registry/v2/models/{name}/versions/{version}/jobs",  # noqa: F541
        "content": json.dumps(mock_response, default=str),
        "status_code": 200,
    }
    httpx_mock.add_response(**httpx_mock_kwargs)
    kwargs = {
        "name": name,
        "version": version,
    }
    resp = await service.model_functions.jobs(**kwargs)
    check_type(resp, JobsForModelResponseV2)


@pytest.mark.asyncio
async def test_list(service: RegistryService, gateway_url: str, httpx_mock: HTTPXMock):
    """Test case for list
    List Models
    """
    # set path params

    mock_response = LatestModelsResponseV2Stub.create_instance().to_dict()
    httpx_mock_kwargs = {
        "method": "GET",
        "url": gateway_url + f"/registry/v2/models/",  # noqa: F541
        "content": json.dumps(mock_response, default=str),
        "status_code": 200,
    }
    httpx_mock.add_response(**httpx_mock_kwargs)
    kwargs = {}
    resp = await service.model_functions.list(**kwargs)
    check_type(resp, LatestModelsResponseV2)


@pytest.mark.asyncio
async def test_list_versions(
    service: RegistryService, gateway_url: str, httpx_mock: HTTPXMock
):
    """Test case for list_versions
    List Model Versions
    """
    # set path params
    name = "name_example"

    mock_response = ModelVersionsResponseV2Stub.create_instance().to_dict()
    httpx_mock_kwargs = {
        "method": "GET",
        "url": gateway_url + f"/registry/v2/models/{name}/versions",  # noqa: F541
        "content": json.dumps(mock_response, default=str),
        "status_code": 200,
    }
    httpx_mock.add_response(**httpx_mock_kwargs)
    kwargs = {
        "name": name,
    }
    resp = await service.model_functions.list_versions(**kwargs)
    check_type(resp, ModelVersionsResponseV2)


@pytest.mark.asyncio
async def test_patch_metadata(
    service: RegistryService, gateway_url: str, httpx_mock: HTTPXMock
):
    """Test case for patch_metadata
    Patch Model Metadata
    """
    # set path params
    name = "name_example"

    version = "version_example"

    # set body param
    body = FunctionMetaStub.create_instance()
    content_type = None
    # content_type = 'application/json'

    mock_response = GetModelResponseV2Stub.create_instance().to_dict()
    httpx_mock_kwargs = {
        "method": "PATCH",
        "url": gateway_url + f"/registry/v2/models/{name}/versions/{version}/metadata",  # noqa: F541
        "content": json.dumps(mock_response, default=str),
        "status_code": 200,
    }
    httpx_mock.add_response(**httpx_mock_kwargs)
    kwargs = {
        "name": name,
        "version": version,
        "body": body,
        "headers": {"content-type": content_type} if content_type else None,
    }
    resp = await service.model_functions.patch_metadata(**kwargs)
    check_type(resp, GetModelResponseV2)


@pytest.mark.asyncio
async def test_publish(
    service: RegistryService, gateway_url: str, httpx_mock: HTTPXMock
):
    """Test case for publish
    Publish Draft Model
    """
    # set path params
    name = "name_example"

    version = "version_example"

    mock_response = PostModelJobSyncResponseV2Stub.create_instance().to_dict()
    httpx_mock_kwargs = {
        "method": "POST",
        "url": gateway_url + f"/registry/v2/models/{name}/versions/{version}/publish",  # noqa: F541
        "content": json.dumps(mock_response, default=str),
        "status_code": 201,
    }
    httpx_mock.add_response(**httpx_mock_kwargs)
    kwargs = {
        "name": name,
        "version": version,
    }
    resp = await service.model_functions.publish(**kwargs)
    check_type(resp, PostModelJobSyncResponseV2)


@pytest.mark.asyncio
async def test_rebuild(
    service: RegistryService, gateway_url: str, httpx_mock: HTTPXMock
):
    """Test case for rebuild
    Rebuild Model
    """
    # set path params
    name = "name_example"

    version = "version_example"

    mock_response = RebuildModelSyncResponseV2Stub.create_instance().to_dict()
    httpx_mock_kwargs = {
        "method": "POST",
        "url": gateway_url + f"/registry/v2/models/{name}/versions/{version}/rebuild",  # noqa: F541
        "content": json.dumps(mock_response, default=str),
        "status_code": 200,
    }
    httpx_mock.add_response(**httpx_mock_kwargs)
    kwargs = {
        "name": name,
        "version": version,
    }
    resp = await service.model_functions.rebuild(**kwargs)
    check_type(resp, RebuildModelSyncResponseV2)


@pytest.mark.asyncio
async def test_remove_version(
    service: RegistryService, gateway_url: str, httpx_mock: HTTPXMock
):
    """Test case for remove_version
    Remove Model Version
    """
    # set path params
    name = "name_example"

    version = "version_example"

    mock_response = UndeployedResponseV2Stub.create_instance().to_dict()
    httpx_mock_kwargs = {
        "method": "DELETE",
        "url": gateway_url + f"/registry/v2/models/{name}/versions/{version}",  # noqa: F541
        "content": json.dumps(mock_response, default=str),
        "status_code": 200,
    }
    httpx_mock.add_response(**httpx_mock_kwargs)
    kwargs = {
        "name": name,
        "version": version,
    }
    resp = await service.model_functions.remove_version(**kwargs)
    check_type(resp, UndeployedResponseV2)


@pytest.mark.asyncio
async def test_remove_versions(
    service: RegistryService, gateway_url: str, httpx_mock: HTTPXMock
):
    """Test case for remove_versions
    Remove Model
    """
    # set path params
    name = "name_example"

    mock_response = UndeployedResponseV2Stub.create_instance().to_dict()
    httpx_mock_kwargs = {
        "method": "DELETE",
        "url": gateway_url + f"/registry/v2/models/{name}",  # noqa: F541
        "content": json.dumps(mock_response, default=str),
        "status_code": 200,
    }
    httpx_mock.add_response(**httpx_mock_kwargs)
    kwargs = {
        "name": name,
    }
    resp = await service.model_functions.remove_versions(**kwargs)
    check_type(resp, UndeployedResponseV2)


@pytest.mark.asyncio
async def test_update_asset(
    service: RegistryService, gateway_url: str, httpx_mock: HTTPXMock
):
    """Test case for update_asset
    Update Model Asset
    """
    # set path params
    name = "name_example"

    version = "version_example"

    wildcard = "wildcard_example"

    # set body param
    body = FileUploadStub.create_instance()
    content_type = None
    # content_type = 'application/octet-stream'

    mock_response = PostModelJobSyncResponseV2Stub.create_instance().to_dict()
    httpx_mock_kwargs = {
        "method": "PUT",
        "url": gateway_url
        + f"/registry/v2/models/{name}/versions/{version}/content/{wildcard}",  # noqa: F541
        "content": json.dumps(mock_response, default=str),
        "status_code": 201,
    }
    httpx_mock.add_response(**httpx_mock_kwargs)
    kwargs = {
        "name": name,
        "version": version,
        "wildcard": wildcard,
        "body": body,
        "headers": {"content-type": content_type} if content_type else None,
    }
    resp = await service.model_functions.update_asset(**kwargs)
    check_type(resp, PostModelJobSyncResponseV2)


@pytest.mark.asyncio
async def test_update_assets(
    service: RegistryService, gateway_url: str, httpx_mock: HTTPXMock
):
    """Test case for update_assets
    Update Model Assets
    """
    # set path params
    name = "name_example"

    version = "version_example"

    # set files param
    files = {
        "myFile1": b"...first file content...",
        "myFile2": b"...second file content...",
    }

    mock_response = PostModelJobSyncResponseV2Stub.create_instance().to_dict()
    httpx_mock_kwargs = {
        "method": "PUT",
        "url": gateway_url + f"/registry/v2/models/{name}/versions/{version}/content",  # noqa: F541
        "content": json.dumps(mock_response, default=str),
        "status_code": 201,
    }
    httpx_mock.add_response(**httpx_mock_kwargs)
    kwargs = {
        "name": name,
        "version": version,
        "files": files,
    }
    resp = await service.model_functions.update_assets(**kwargs)
    check_type(resp, PostModelJobSyncResponseV2)


@pytest.mark.asyncio
async def test_verify(
    service: RegistryService, gateway_url: str, httpx_mock: HTTPXMock
):
    """Test case for verify
    Verify Health Of Model
    """
    # set path params
    name = "name_example"

    version = "version_example"

    mock_response = VerifyModelSyncResponseV2Stub.create_instance().to_dict()
    httpx_mock_kwargs = {
        "method": "POST",
        "url": gateway_url + f"/registry/v2/models/{name}/versions/{version}/verify",  # noqa: F541
        "content": json.dumps(mock_response, default=str),
        "status_code": 200,
    }
    httpx_mock.add_response(**httpx_mock_kwargs)
    kwargs = {
        "name": name,
        "version": version,
    }
    resp = await service.model_functions.verify(**kwargs)
    check_type(resp, VerifyModelSyncResponseV2)
